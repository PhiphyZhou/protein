# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.7
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
PyOpenMM is a Python application programming interface (API) to be
used for performing molecular dynamics (MD) simulations on various
computer architectures (including GPUs).  It is implemented in Python
and C/C++, and provides a Python interface to the OpenMM libraries
(see https://simtk.org/home/openmm for OpenMM details).  The primary
motivation for creating PyOpenMM is to make it possible to write
GPU-accelerated MD code in pure Python.

See https://simtk.org/home/pyopenmm for details
"""


from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_openmm', [dirname(__file__)])
        except ImportError:
            import _openmm
            return _openmm
        if fp is not None:
            try:
                _mod = imp.load_module('_openmm', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _openmm = swig_import_helper()
    del swig_import_helper
else:
    import _openmm
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


class ios_base(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ios_base, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ios_base, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    erase_event = _openmm.ios_base_erase_event
    imbue_event = _openmm.ios_base_imbue_event
    copyfmt_event = _openmm.ios_base_copyfmt_event

    def register_callback(self, __fn, __index):
        return _openmm.ios_base_register_callback(self, __fn, __index)

    def flags(self, *args):
        return _openmm.ios_base_flags(self, *args)

    def setf(self, *args):
        return _openmm.ios_base_setf(self, *args)

    def unsetf(self, __mask):
        return _openmm.ios_base_unsetf(self, __mask)

    def precision(self, *args):
        return _openmm.ios_base_precision(self, *args)

    def width(self, *args):
        return _openmm.ios_base_width(self, *args)
    __swig_getmethods__["sync_with_stdio"] = lambda x: _openmm.ios_base_sync_with_stdio
    if _newclass:
        sync_with_stdio = staticmethod(_openmm.ios_base_sync_with_stdio)

    def imbue(self, __loc):
        return _openmm.ios_base_imbue(self, __loc)

    def getloc(self):
        return _openmm.ios_base_getloc(self)
    __swig_getmethods__["xalloc"] = lambda x: _openmm.ios_base_xalloc
    if _newclass:
        xalloc = staticmethod(_openmm.ios_base_xalloc)

    def iword(self, __ix):
        return _openmm.ios_base_iword(self, __ix)

    def pword(self, __ix):
        return _openmm.ios_base_pword(self, __ix)
    __swig_destroy__ = _openmm.delete_ios_base
    __del__ = lambda self: None
ios_base_swigregister = _openmm.ios_base_swigregister
ios_base_swigregister(ios_base)
cvar = _openmm.cvar
ios_base.boolalpha = _openmm.cvar.ios_base_boolalpha
ios_base.dec = _openmm.cvar.ios_base_dec
ios_base.fixed = _openmm.cvar.ios_base_fixed
ios_base.hex = _openmm.cvar.ios_base_hex
ios_base.internal = _openmm.cvar.ios_base_internal
ios_base.left = _openmm.cvar.ios_base_left
ios_base.oct = _openmm.cvar.ios_base_oct
ios_base.right = _openmm.cvar.ios_base_right
ios_base.scientific = _openmm.cvar.ios_base_scientific
ios_base.showbase = _openmm.cvar.ios_base_showbase
ios_base.showpoint = _openmm.cvar.ios_base_showpoint
ios_base.showpos = _openmm.cvar.ios_base_showpos
ios_base.skipws = _openmm.cvar.ios_base_skipws
ios_base.unitbuf = _openmm.cvar.ios_base_unitbuf
ios_base.uppercase = _openmm.cvar.ios_base_uppercase
ios_base.adjustfield = _openmm.cvar.ios_base_adjustfield
ios_base.basefield = _openmm.cvar.ios_base_basefield
ios_base.floatfield = _openmm.cvar.ios_base_floatfield
ios_base.badbit = _openmm.cvar.ios_base_badbit
ios_base.eofbit = _openmm.cvar.ios_base_eofbit
ios_base.failbit = _openmm.cvar.ios_base_failbit
ios_base.goodbit = _openmm.cvar.ios_base_goodbit
ios_base.app = _openmm.cvar.ios_base_app
ios_base.ate = _openmm.cvar.ios_base_ate
ios_base.binary = _openmm.cvar.ios_base_binary
ios_base.ios_base_in = _openmm.cvar.ios_base_ios_base_in
ios_base.out = _openmm.cvar.ios_base_out
ios_base.trunc = _openmm.cvar.ios_base_trunc
ios_base.beg = _openmm.cvar.ios_base_beg
ios_base.cur = _openmm.cvar.ios_base_cur
ios_base.end = _openmm.cvar.ios_base_end

def ios_base_sync_with_stdio(__sync=True):
    return _openmm.ios_base_sync_with_stdio(__sync)
ios_base_sync_with_stdio = _openmm.ios_base_sync_with_stdio

def ios_base_xalloc():
    return _openmm.ios_base_xalloc()
ios_base_xalloc = _openmm.ios_base_xalloc

class ios(ios_base):
    __swig_setmethods__ = {}
    for _s in [ios_base]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ios, name, value)
    __swig_getmethods__ = {}
    for _s in [ios_base]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ios, name)
    __repr__ = _swig_repr

    def rdstate(self):
        return _openmm.ios_rdstate(self)

    def clear(self, *args):
        return _openmm.ios_clear(self, *args)

    def setstate(self, __state):
        return _openmm.ios_setstate(self, __state)

    def good(self):
        return _openmm.ios_good(self)

    def eof(self):
        return _openmm.ios_eof(self)

    def fail(self):
        return _openmm.ios_fail(self)

    def bad(self):
        return _openmm.ios_bad(self)

    def exceptions(self, *args):
        return _openmm.ios_exceptions(self, *args)

    def __init__(self, __sb):
        this = _openmm.new_ios(__sb)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_ios
    __del__ = lambda self: None

    def tie(self, *args):
        return _openmm.ios_tie(self, *args)

    def rdbuf(self, *args):
        return _openmm.ios_rdbuf(self, *args)

    def copyfmt(self, __rhs):
        return _openmm.ios_copyfmt(self, __rhs)

    def fill(self, *args):
        return _openmm.ios_fill(self, *args)

    def imbue(self, __loc):
        return _openmm.ios_imbue(self, __loc)

    def narrow(self, __c, __dfault):
        return _openmm.ios_narrow(self, __c, __dfault)

    def widen(self, __c):
        return _openmm.ios_widen(self, __c)
ios_swigregister = _openmm.ios_swigregister
ios_swigregister(ios)

class ostream(ios):
    __swig_setmethods__ = {}
    for _s in [ios]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ostream, name, value)
    __swig_getmethods__ = {}
    for _s in [ios]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ostream, name)
    __repr__ = _swig_repr

    def __init__(self, __sb):
        this = _openmm.new_ostream(__sb)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_ostream
    __del__ = lambda self: None

    def __lshift__(self, *args):
        return _openmm.ostream___lshift__(self, *args)

    def put(self, __c):
        return _openmm.ostream_put(self, __c)

    def write(self, __s, __n):
        return _openmm.ostream_write(self, __s, __n)

    def flush(self):
        return _openmm.ostream_flush(self)

    def tellp(self):
        return _openmm.ostream_tellp(self)

    def seekp(self, *args):
        return _openmm.ostream_seekp(self, *args)
ostream_swigregister = _openmm.ostream_swigregister
ostream_swigregister(ostream)
cin = cvar.cin
cout = cvar.cout
cerr = cvar.cerr
clog = cvar.clog

class istream(ios):
    __swig_setmethods__ = {}
    for _s in [ios]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, istream, name, value)
    __swig_getmethods__ = {}
    for _s in [ios]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, istream, name)
    __repr__ = _swig_repr

    def __init__(self, __sb):
        this = _openmm.new_istream(__sb)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_istream
    __del__ = lambda self: None

    def __rshift__(self, *args):
        return _openmm.istream___rshift__(self, *args)

    def gcount(self):
        return _openmm.istream_gcount(self)

    def get(self, *args):
        return _openmm.istream_get(self, *args)

    def getline(self, *args):
        return _openmm.istream_getline(self, *args)

    def ignore(self, *args):
        return _openmm.istream_ignore(self, *args)

    def peek(self):
        return _openmm.istream_peek(self)

    def read(self, __s, __n):
        return _openmm.istream_read(self, __s, __n)

    def readsome(self, __s, __n):
        return _openmm.istream_readsome(self, __s, __n)

    def putback(self, __c):
        return _openmm.istream_putback(self, __c)

    def unget(self):
        return _openmm.istream_unget(self)

    def sync(self):
        return _openmm.istream_sync(self)

    def tellg(self):
        return _openmm.istream_tellg(self)

    def seekg(self, *args):
        return _openmm.istream_seekg(self, *args)
istream_swigregister = _openmm.istream_swigregister
istream_swigregister(istream)

class iostream(istream, ostream):
    __swig_setmethods__ = {}
    for _s in [istream, ostream]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, iostream, name, value)
    __swig_getmethods__ = {}
    for _s in [istream, ostream]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, iostream, name)
    __repr__ = _swig_repr

    def __init__(self, __sb):
        this = _openmm.new_iostream(__sb)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_iostream
    __del__ = lambda self: None
iostream_swigregister = _openmm.iostream_swigregister
iostream_swigregister(iostream)


_openmm.endl_cb_ptr_swigconstant(_openmm)
endl_cb_ptr = _openmm.endl_cb_ptr

def endl(arg1):
    return _openmm.endl(arg1)
endl = _openmm.endl

_openmm.ends_cb_ptr_swigconstant(_openmm)
ends_cb_ptr = _openmm.ends_cb_ptr

def ends(arg1):
    return _openmm.ends(arg1)
ends = _openmm.ends

_openmm.flush_cb_ptr_swigconstant(_openmm)
flush_cb_ptr = _openmm.flush_cb_ptr

def flush(arg1):
    return _openmm.flush(arg1)
flush = _openmm.flush
class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _openmm.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _openmm.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _openmm.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _openmm.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _openmm.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _openmm.SwigPyIterator_equal(self, x)

    def copy(self):
        return _openmm.SwigPyIterator_copy(self)

    def next(self):
        return _openmm.SwigPyIterator_next(self)

    def __next__(self):
        return _openmm.SwigPyIterator___next__(self)

    def previous(self):
        return _openmm.SwigPyIterator_previous(self)

    def advance(self, n):
        return _openmm.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _openmm.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _openmm.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _openmm.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _openmm.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _openmm.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _openmm.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _openmm.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class pairii(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, pairii, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, pairii, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openmm.new_pairii(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_setmethods__["first"] = _openmm.pairii_first_set
    __swig_getmethods__["first"] = _openmm.pairii_first_get
    if _newclass:
        first = _swig_property(_openmm.pairii_first_get, _openmm.pairii_first_set)
    __swig_setmethods__["second"] = _openmm.pairii_second_set
    __swig_getmethods__["second"] = _openmm.pairii_second_get
    if _newclass:
        second = _swig_property(_openmm.pairii_second_get, _openmm.pairii_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _openmm.delete_pairii
    def __del__(self):
        """__del__(std::pair<(int,int)> self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

pairii_swigregister = _openmm.pairii_swigregister
pairii_swigregister(pairii)

class vectord(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectord, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectord, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _openmm.vectord_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _openmm.vectord___nonzero__(self)

    def __bool__(self):
        return _openmm.vectord___bool__(self)

    def __len__(self):
        return _openmm.vectord___len__(self)

    def pop(self):
        return _openmm.vectord_pop(self)

    def __getslice__(self, i, j):
        return _openmm.vectord___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _openmm.vectord___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _openmm.vectord___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _openmm.vectord___delitem__(self, *args)

    def __getitem__(self, *args):
        return _openmm.vectord___getitem__(self, *args)

    def __setitem__(self, *args):
        return _openmm.vectord___setitem__(self, *args)

    def append(self, x):
        return _openmm.vectord_append(self, x)

    def empty(self):
        return _openmm.vectord_empty(self)

    def size(self):
        return _openmm.vectord_size(self)

    def clear(self):
        return _openmm.vectord_clear(self)

    def swap(self, v):
        return _openmm.vectord_swap(self, v)

    def get_allocator(self):
        return _openmm.vectord_get_allocator(self)

    def begin(self):
        return _openmm.vectord_begin(self)

    def end(self):
        return _openmm.vectord_end(self)

    def rbegin(self):
        return _openmm.vectord_rbegin(self)

    def rend(self):
        return _openmm.vectord_rend(self)

    def pop_back(self):
        return _openmm.vectord_pop_back(self)

    def erase(self, *args):
        return _openmm.vectord_erase(self, *args)

    def __init__(self, *args):
        this = _openmm.new_vectord(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x):
        return _openmm.vectord_push_back(self, x)

    def front(self):
        return _openmm.vectord_front(self)

    def back(self):
        return _openmm.vectord_back(self)

    def assign(self, n, x):
        return _openmm.vectord_assign(self, n, x)

    def resize(self, *args):
        return _openmm.vectord_resize(self, *args)

    def insert(self, *args):
        return _openmm.vectord_insert(self, *args)

    def reserve(self, n):
        return _openmm.vectord_reserve(self, n)

    def capacity(self):
        return _openmm.vectord_capacity(self)
    __swig_destroy__ = _openmm.delete_vectord
    def __del__(self):
        """__del__(std::vector<(double)> self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

vectord_swigregister = _openmm.vectord_swigregister
vectord_swigregister(vectord)

class vectorddd(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorddd, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorddd, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _openmm.vectorddd_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _openmm.vectorddd___nonzero__(self)

    def __bool__(self):
        return _openmm.vectorddd___bool__(self)

    def __len__(self):
        return _openmm.vectorddd___len__(self)

    def pop(self):
        return _openmm.vectorddd_pop(self)

    def __getslice__(self, i, j):
        return _openmm.vectorddd___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _openmm.vectorddd___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _openmm.vectorddd___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _openmm.vectorddd___delitem__(self, *args)

    def __getitem__(self, *args):
        return _openmm.vectorddd___getitem__(self, *args)

    def __setitem__(self, *args):
        return _openmm.vectorddd___setitem__(self, *args)

    def append(self, x):
        return _openmm.vectorddd_append(self, x)

    def empty(self):
        return _openmm.vectorddd_empty(self)

    def size(self):
        return _openmm.vectorddd_size(self)

    def clear(self):
        return _openmm.vectorddd_clear(self)

    def swap(self, v):
        return _openmm.vectorddd_swap(self, v)

    def get_allocator(self):
        return _openmm.vectorddd_get_allocator(self)

    def begin(self):
        return _openmm.vectorddd_begin(self)

    def end(self):
        return _openmm.vectorddd_end(self)

    def rbegin(self):
        return _openmm.vectorddd_rbegin(self)

    def rend(self):
        return _openmm.vectorddd_rend(self)

    def pop_back(self):
        return _openmm.vectorddd_pop_back(self)

    def erase(self, *args):
        return _openmm.vectorddd_erase(self, *args)

    def __init__(self, *args):
        this = _openmm.new_vectorddd(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x):
        return _openmm.vectorddd_push_back(self, x)

    def front(self):
        return _openmm.vectorddd_front(self)

    def back(self):
        return _openmm.vectorddd_back(self)

    def assign(self, n, x):
        return _openmm.vectorddd_assign(self, n, x)

    def resize(self, *args):
        return _openmm.vectorddd_resize(self, *args)

    def insert(self, *args):
        return _openmm.vectorddd_insert(self, *args)

    def reserve(self, n):
        return _openmm.vectorddd_reserve(self, n)

    def capacity(self):
        return _openmm.vectorddd_capacity(self)
    __swig_destroy__ = _openmm.delete_vectorddd
    def __del__(self):
        """__del__(std::vector<(std::vector<(std::vector<(double)>)>)> self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

vectorddd_swigregister = _openmm.vectorddd_swigregister
vectorddd_swigregister(vectorddd)

class vectori(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectori, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectori, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _openmm.vectori_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _openmm.vectori___nonzero__(self)

    def __bool__(self):
        return _openmm.vectori___bool__(self)

    def __len__(self):
        return _openmm.vectori___len__(self)

    def pop(self):
        return _openmm.vectori_pop(self)

    def __getslice__(self, i, j):
        return _openmm.vectori___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _openmm.vectori___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _openmm.vectori___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _openmm.vectori___delitem__(self, *args)

    def __getitem__(self, *args):
        return _openmm.vectori___getitem__(self, *args)

    def __setitem__(self, *args):
        return _openmm.vectori___setitem__(self, *args)

    def append(self, x):
        return _openmm.vectori_append(self, x)

    def empty(self):
        return _openmm.vectori_empty(self)

    def size(self):
        return _openmm.vectori_size(self)

    def clear(self):
        return _openmm.vectori_clear(self)

    def swap(self, v):
        return _openmm.vectori_swap(self, v)

    def get_allocator(self):
        return _openmm.vectori_get_allocator(self)

    def begin(self):
        return _openmm.vectori_begin(self)

    def end(self):
        return _openmm.vectori_end(self)

    def rbegin(self):
        return _openmm.vectori_rbegin(self)

    def rend(self):
        return _openmm.vectori_rend(self)

    def pop_back(self):
        return _openmm.vectori_pop_back(self)

    def erase(self, *args):
        return _openmm.vectori_erase(self, *args)

    def __init__(self, *args):
        this = _openmm.new_vectori(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x):
        return _openmm.vectori_push_back(self, x)

    def front(self):
        return _openmm.vectori_front(self)

    def back(self):
        return _openmm.vectori_back(self)

    def assign(self, n, x):
        return _openmm.vectori_assign(self, n, x)

    def resize(self, *args):
        return _openmm.vectori_resize(self, *args)

    def insert(self, *args):
        return _openmm.vectori_insert(self, *args)

    def reserve(self, n):
        return _openmm.vectori_reserve(self, n)

    def capacity(self):
        return _openmm.vectori_capacity(self)
    __swig_destroy__ = _openmm.delete_vectori
    def __del__(self):
        """__del__(std::vector<(int)> self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

vectori_swigregister = _openmm.vectori_swigregister
vectori_swigregister(vectori)

class vectorii(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorii, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorii, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _openmm.vectorii_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _openmm.vectorii___nonzero__(self)

    def __bool__(self):
        return _openmm.vectorii___bool__(self)

    def __len__(self):
        return _openmm.vectorii___len__(self)

    def pop(self):
        return _openmm.vectorii_pop(self)

    def __getslice__(self, i, j):
        return _openmm.vectorii___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _openmm.vectorii___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _openmm.vectorii___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _openmm.vectorii___delitem__(self, *args)

    def __getitem__(self, *args):
        return _openmm.vectorii___getitem__(self, *args)

    def __setitem__(self, *args):
        return _openmm.vectorii___setitem__(self, *args)

    def append(self, x):
        return _openmm.vectorii_append(self, x)

    def empty(self):
        return _openmm.vectorii_empty(self)

    def size(self):
        return _openmm.vectorii_size(self)

    def clear(self):
        return _openmm.vectorii_clear(self)

    def swap(self, v):
        return _openmm.vectorii_swap(self, v)

    def get_allocator(self):
        return _openmm.vectorii_get_allocator(self)

    def begin(self):
        return _openmm.vectorii_begin(self)

    def end(self):
        return _openmm.vectorii_end(self)

    def rbegin(self):
        return _openmm.vectorii_rbegin(self)

    def rend(self):
        return _openmm.vectorii_rend(self)

    def pop_back(self):
        return _openmm.vectorii_pop_back(self)

    def erase(self, *args):
        return _openmm.vectorii_erase(self, *args)

    def __init__(self, *args):
        this = _openmm.new_vectorii(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x):
        return _openmm.vectorii_push_back(self, x)

    def front(self):
        return _openmm.vectorii_front(self)

    def back(self):
        return _openmm.vectorii_back(self)

    def assign(self, n, x):
        return _openmm.vectorii_assign(self, n, x)

    def resize(self, *args):
        return _openmm.vectorii_resize(self, *args)

    def insert(self, *args):
        return _openmm.vectorii_insert(self, *args)

    def reserve(self, n):
        return _openmm.vectorii_reserve(self, n)

    def capacity(self):
        return _openmm.vectorii_capacity(self)
    __swig_destroy__ = _openmm.delete_vectorii
    def __del__(self):
        """__del__(std::vector<(std::vector<(int)>)> self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

vectorii_swigregister = _openmm.vectorii_swigregister
vectorii_swigregister(vectorii)

class vectorpairii(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorpairii, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorpairii, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _openmm.vectorpairii_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _openmm.vectorpairii___nonzero__(self)

    def __bool__(self):
        return _openmm.vectorpairii___bool__(self)

    def __len__(self):
        return _openmm.vectorpairii___len__(self)

    def pop(self):
        return _openmm.vectorpairii_pop(self)

    def __getslice__(self, i, j):
        return _openmm.vectorpairii___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _openmm.vectorpairii___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _openmm.vectorpairii___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _openmm.vectorpairii___delitem__(self, *args)

    def __getitem__(self, *args):
        return _openmm.vectorpairii___getitem__(self, *args)

    def __setitem__(self, *args):
        return _openmm.vectorpairii___setitem__(self, *args)

    def append(self, x):
        return _openmm.vectorpairii_append(self, x)

    def empty(self):
        return _openmm.vectorpairii_empty(self)

    def size(self):
        return _openmm.vectorpairii_size(self)

    def clear(self):
        return _openmm.vectorpairii_clear(self)

    def swap(self, v):
        return _openmm.vectorpairii_swap(self, v)

    def get_allocator(self):
        return _openmm.vectorpairii_get_allocator(self)

    def begin(self):
        return _openmm.vectorpairii_begin(self)

    def end(self):
        return _openmm.vectorpairii_end(self)

    def rbegin(self):
        return _openmm.vectorpairii_rbegin(self)

    def rend(self):
        return _openmm.vectorpairii_rend(self)

    def pop_back(self):
        return _openmm.vectorpairii_pop_back(self)

    def erase(self, *args):
        return _openmm.vectorpairii_erase(self, *args)

    def __init__(self, *args):
        this = _openmm.new_vectorpairii(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x):
        return _openmm.vectorpairii_push_back(self, x)

    def front(self):
        return _openmm.vectorpairii_front(self)

    def back(self):
        return _openmm.vectorpairii_back(self)

    def assign(self, n, x):
        return _openmm.vectorpairii_assign(self, n, x)

    def resize(self, *args):
        return _openmm.vectorpairii_resize(self, *args)

    def insert(self, *args):
        return _openmm.vectorpairii_insert(self, *args)

    def reserve(self, n):
        return _openmm.vectorpairii_reserve(self, n)

    def capacity(self):
        return _openmm.vectorpairii_capacity(self)
    __swig_destroy__ = _openmm.delete_vectorpairii
    def __del__(self):
        """__del__(std::vector<(std::pair<(int,int)>)> self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

vectorpairii_swigregister = _openmm.vectorpairii_swigregister
vectorpairii_swigregister(vectorpairii)

class vectorstring(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorstring, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorstring, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _openmm.vectorstring_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _openmm.vectorstring___nonzero__(self)

    def __bool__(self):
        return _openmm.vectorstring___bool__(self)

    def __len__(self):
        return _openmm.vectorstring___len__(self)

    def pop(self):
        return _openmm.vectorstring_pop(self)

    def __getslice__(self, i, j):
        return _openmm.vectorstring___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _openmm.vectorstring___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _openmm.vectorstring___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _openmm.vectorstring___delitem__(self, *args)

    def __getitem__(self, *args):
        return _openmm.vectorstring___getitem__(self, *args)

    def __setitem__(self, *args):
        return _openmm.vectorstring___setitem__(self, *args)

    def append(self, x):
        return _openmm.vectorstring_append(self, x)

    def empty(self):
        return _openmm.vectorstring_empty(self)

    def size(self):
        return _openmm.vectorstring_size(self)

    def clear(self):
        return _openmm.vectorstring_clear(self)

    def swap(self, v):
        return _openmm.vectorstring_swap(self, v)

    def get_allocator(self):
        return _openmm.vectorstring_get_allocator(self)

    def begin(self):
        return _openmm.vectorstring_begin(self)

    def end(self):
        return _openmm.vectorstring_end(self)

    def rbegin(self):
        return _openmm.vectorstring_rbegin(self)

    def rend(self):
        return _openmm.vectorstring_rend(self)

    def pop_back(self):
        return _openmm.vectorstring_pop_back(self)

    def erase(self, *args):
        return _openmm.vectorstring_erase(self, *args)

    def __init__(self, *args):
        this = _openmm.new_vectorstring(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x):
        return _openmm.vectorstring_push_back(self, x)

    def front(self):
        return _openmm.vectorstring_front(self)

    def back(self):
        return _openmm.vectorstring_back(self)

    def assign(self, n, x):
        return _openmm.vectorstring_assign(self, n, x)

    def resize(self, *args):
        return _openmm.vectorstring_resize(self, *args)

    def insert(self, *args):
        return _openmm.vectorstring_insert(self, *args)

    def reserve(self, n):
        return _openmm.vectorstring_reserve(self, n)

    def capacity(self):
        return _openmm.vectorstring_capacity(self)
    __swig_destroy__ = _openmm.delete_vectorstring
    def __del__(self):
        """__del__(std::vector<(std::string)> self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

vectorstring_swigregister = _openmm.vectorstring_swigregister
vectorstring_swigregister(vectorstring)

class mapstringstring(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, mapstringstring, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, mapstringstring, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _openmm.mapstringstring_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _openmm.mapstringstring___nonzero__(self)

    def __bool__(self):
        return _openmm.mapstringstring___bool__(self)

    def __len__(self):
        return _openmm.mapstringstring___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _openmm.mapstringstring___getitem__(self, key)

    def __delitem__(self, key):
        return _openmm.mapstringstring___delitem__(self, key)

    def has_key(self, key):
        return _openmm.mapstringstring_has_key(self, key)

    def keys(self):
        return _openmm.mapstringstring_keys(self)

    def values(self):
        return _openmm.mapstringstring_values(self)

    def items(self):
        return _openmm.mapstringstring_items(self)

    def __contains__(self, key):
        return _openmm.mapstringstring___contains__(self, key)

    def key_iterator(self):
        return _openmm.mapstringstring_key_iterator(self)

    def value_iterator(self):
        return _openmm.mapstringstring_value_iterator(self)

    def __setitem__(self, *args):
        return _openmm.mapstringstring___setitem__(self, *args)

    def asdict(self):
        return _openmm.mapstringstring_asdict(self)

    def __init__(self, *args):
        this = _openmm.new_mapstringstring(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def empty(self):
        return _openmm.mapstringstring_empty(self)

    def size(self):
        return _openmm.mapstringstring_size(self)

    def clear(self):
        return _openmm.mapstringstring_clear(self)

    def swap(self, v):
        return _openmm.mapstringstring_swap(self, v)

    def get_allocator(self):
        return _openmm.mapstringstring_get_allocator(self)

    def begin(self):
        return _openmm.mapstringstring_begin(self)

    def end(self):
        return _openmm.mapstringstring_end(self)

    def rbegin(self):
        return _openmm.mapstringstring_rbegin(self)

    def rend(self):
        return _openmm.mapstringstring_rend(self)

    def count(self, x):
        return _openmm.mapstringstring_count(self, x)

    def erase(self, *args):
        return _openmm.mapstringstring_erase(self, *args)

    def find(self, x):
        return _openmm.mapstringstring_find(self, x)

    def lower_bound(self, x):
        return _openmm.mapstringstring_lower_bound(self, x)

    def upper_bound(self, x):
        return _openmm.mapstringstring_upper_bound(self, x)
    __swig_destroy__ = _openmm.delete_mapstringstring
    def __del__(self):
        """__del__(std::map<(std::string,std::string)> self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

mapstringstring_swigregister = _openmm.mapstringstring_swigregister
mapstringstring_swigregister(mapstringstring)

class mapstringdouble(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, mapstringdouble, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, mapstringdouble, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _openmm.mapstringdouble_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _openmm.mapstringdouble___nonzero__(self)

    def __bool__(self):
        return _openmm.mapstringdouble___bool__(self)

    def __len__(self):
        return _openmm.mapstringdouble___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _openmm.mapstringdouble___getitem__(self, key)

    def __delitem__(self, key):
        return _openmm.mapstringdouble___delitem__(self, key)

    def has_key(self, key):
        return _openmm.mapstringdouble_has_key(self, key)

    def keys(self):
        return _openmm.mapstringdouble_keys(self)

    def values(self):
        return _openmm.mapstringdouble_values(self)

    def items(self):
        return _openmm.mapstringdouble_items(self)

    def __contains__(self, key):
        return _openmm.mapstringdouble___contains__(self, key)

    def key_iterator(self):
        return _openmm.mapstringdouble_key_iterator(self)

    def value_iterator(self):
        return _openmm.mapstringdouble_value_iterator(self)

    def __setitem__(self, *args):
        return _openmm.mapstringdouble___setitem__(self, *args)

    def asdict(self):
        return _openmm.mapstringdouble_asdict(self)

    def __init__(self, *args):
        this = _openmm.new_mapstringdouble(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def empty(self):
        return _openmm.mapstringdouble_empty(self)

    def size(self):
        return _openmm.mapstringdouble_size(self)

    def clear(self):
        return _openmm.mapstringdouble_clear(self)

    def swap(self, v):
        return _openmm.mapstringdouble_swap(self, v)

    def get_allocator(self):
        return _openmm.mapstringdouble_get_allocator(self)

    def begin(self):
        return _openmm.mapstringdouble_begin(self)

    def end(self):
        return _openmm.mapstringdouble_end(self)

    def rbegin(self):
        return _openmm.mapstringdouble_rbegin(self)

    def rend(self):
        return _openmm.mapstringdouble_rend(self)

    def count(self, x):
        return _openmm.mapstringdouble_count(self, x)

    def erase(self, *args):
        return _openmm.mapstringdouble_erase(self, *args)

    def find(self, x):
        return _openmm.mapstringdouble_find(self, x)

    def lower_bound(self, x):
        return _openmm.mapstringdouble_lower_bound(self, x)

    def upper_bound(self, x):
        return _openmm.mapstringdouble_upper_bound(self, x)
    __swig_destroy__ = _openmm.delete_mapstringdouble
    def __del__(self):
        """__del__(std::map<(std::string,double)> self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

mapstringdouble_swigregister = _openmm.mapstringdouble_swigregister
mapstringdouble_swigregister(mapstringdouble)

class mapii(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, mapii, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, mapii, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _openmm.mapii_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _openmm.mapii___nonzero__(self)

    def __bool__(self):
        return _openmm.mapii___bool__(self)

    def __len__(self):
        return _openmm.mapii___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _openmm.mapii___getitem__(self, key)

    def __delitem__(self, key):
        return _openmm.mapii___delitem__(self, key)

    def has_key(self, key):
        return _openmm.mapii_has_key(self, key)

    def keys(self):
        return _openmm.mapii_keys(self)

    def values(self):
        return _openmm.mapii_values(self)

    def items(self):
        return _openmm.mapii_items(self)

    def __contains__(self, key):
        return _openmm.mapii___contains__(self, key)

    def key_iterator(self):
        return _openmm.mapii_key_iterator(self)

    def value_iterator(self):
        return _openmm.mapii_value_iterator(self)

    def __setitem__(self, *args):
        return _openmm.mapii___setitem__(self, *args)

    def asdict(self):
        return _openmm.mapii_asdict(self)

    def __init__(self, *args):
        this = _openmm.new_mapii(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def empty(self):
        return _openmm.mapii_empty(self)

    def size(self):
        return _openmm.mapii_size(self)

    def clear(self):
        return _openmm.mapii_clear(self)

    def swap(self, v):
        return _openmm.mapii_swap(self, v)

    def get_allocator(self):
        return _openmm.mapii_get_allocator(self)

    def begin(self):
        return _openmm.mapii_begin(self)

    def end(self):
        return _openmm.mapii_end(self)

    def rbegin(self):
        return _openmm.mapii_rbegin(self)

    def rend(self):
        return _openmm.mapii_rend(self)

    def count(self, x):
        return _openmm.mapii_count(self, x)

    def erase(self, *args):
        return _openmm.mapii_erase(self, *args)

    def find(self, x):
        return _openmm.mapii_find(self, x)

    def lower_bound(self, x):
        return _openmm.mapii_lower_bound(self, x)

    def upper_bound(self, x):
        return _openmm.mapii_upper_bound(self, x)
    __swig_destroy__ = _openmm.delete_mapii
    def __del__(self):
        """__del__(std::map<(int,int)> self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

mapii_swigregister = _openmm.mapii_swigregister
mapii_swigregister(mapii)

class seti(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, seti, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, seti, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _openmm.seti_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _openmm.seti___nonzero__(self)

    def __bool__(self):
        return _openmm.seti___bool__(self)

    def __len__(self):
        return _openmm.seti___len__(self)

    def append(self, x):
        return _openmm.seti_append(self, x)

    def __contains__(self, x):
        return _openmm.seti___contains__(self, x)

    def __getitem__(self, i):
        return _openmm.seti___getitem__(self, i)

    def add(self, x):
        return _openmm.seti_add(self, x)

    def discard(self, x):
        return _openmm.seti_discard(self, x)

    def __init__(self, *args):
        this = _openmm.new_seti(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def empty(self):
        return _openmm.seti_empty(self)

    def size(self):
        return _openmm.seti_size(self)

    def clear(self):
        return _openmm.seti_clear(self)

    def swap(self, v):
        return _openmm.seti_swap(self, v)

    def count(self, x):
        return _openmm.seti_count(self, x)

    def begin(self):
        return _openmm.seti_begin(self)

    def end(self):
        return _openmm.seti_end(self)

    def rbegin(self):
        return _openmm.seti_rbegin(self)

    def rend(self):
        return _openmm.seti_rend(self)

    def erase(self, *args):
        return _openmm.seti_erase(self, *args)

    def find(self, x):
        return _openmm.seti_find(self, x)

    def lower_bound(self, x):
        return _openmm.seti_lower_bound(self, x)

    def upper_bound(self, x):
        return _openmm.seti_upper_bound(self, x)

    def equal_range(self, x):
        return _openmm.seti_equal_range(self, x)

    def insert(self, __x):
        return _openmm.seti_insert(self, __x)
    __swig_destroy__ = _openmm.delete_seti
    def __del__(self):
        """__del__(std::set<(int)> self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

seti_swigregister = _openmm.seti_swigregister
seti_swigregister(seti)



try:
    import numpy
except:
    pass

import sys
import math
RMIN_PER_SIGMA=math.pow(2, 1/6.0)
RVDW_PER_SIGMA=math.pow(2, 1/6.0)/2.0
if sys.version_info[0] == 2:
    _string_types = (basestring,)
else:
    _string_types = (bytes, str)

import simtk.unit as unit
from simtk.openmm.vec3 import Vec3

class State(_object):
    """
     A State object records a snapshot of the
     current state of a simulation at a point
     in time.  You create it by calling
     getState() on a Context.

     When a State is created, you specify what
     information should be stored in it.  This
     saves time and memory by only copying in
     the information that you actually want.
     This is especially important for forces
     and energies, since they may need to be
     calculated.  If you query a State object
     for a piece of information which is not
     available (because it was not requested
     when the State was created), it will
     return None.

     In general return values are Python Units
     (https://simtk.org/home/python_units).
     Among other things Python Units provides a
     container class, Quantity, which holds a
     value and a representation of the value's
     unit.  Values can be integers, floats,
     lists, numarrays, etc.  Quantity objects
     can be used in arithmetic operation just
     like number, except they also keep track
     of units.   To extract the value from a
     quantity, us the value_in_unit() method.
     For example, to extract the value from a
     length quantity, in units of nanometers,
     do the following:
     myLengthQuantity.value_in_unit(unit.nanometer)

"""
    def __init__(self,
                 simTime=None,
                 energy=None,
                 coordList=None,
                 velList=None,
                 forceList=None,
                 periodicBoxVectorsList=None,
                 paramMap=None):
        self._simTime=simTime
        self._periodicBoxVectorsList=periodicBoxVectorsList
        self._periodicBoxVectorsListNumpy=None
        if energy:
            self._eK0=energy[0]
            self._eP0=energy[1]
        else:
            self._eK0=None
            self._eP0=None
        self._coordList=coordList
        self._coordListNumpy=None
        self._velList=velList
        self._velListNumpy=None
        self._forceList=forceList
        self._forceListNumpy=None
        self._paramMap=paramMap

    def __getstate__(self):
        serializationString = XmlSerializer.serialize(self)
        return serializationString

    def __setstate__(self, serializationString):
        dState = XmlSerializer.deserialize(serializationString)
# Safe provided no __slots__ or other weird things are used
        self.__dict__.update(dState.__dict__)

    def getTime(self):
        """Get the time for which this State was created."""
        return self._simTime * unit.picosecond

    def getPeriodicBoxVectors(self, asNumpy=False):
        """Get the three periodic box vectors if this state is from a
           simulation using PBC ."""
        if self._periodicBoxVectorsList is None:
            raise TypeError('periodic box vectors were not available.')

        if asNumpy:
            if self._periodicBoxVectorsListNumpy is None:
                self._periodicBoxVectorsListNumpy = \
                     numpy.array(self._periodicBoxVectorsList)
            returnValue=self._periodicBoxVectorsListNumpy
        else:
            returnValue=self._periodicBoxVectorsList

        returnValue = unit.Quantity(returnValue, unit.nanometers)
        return returnValue

    def getPeriodicBoxVolume(self):
        """Get the volume of the periodic box."""
        a = self._periodicBoxVectorsList[0]
        b = self._periodicBoxVectorsList[1]
        c = self._periodicBoxVectorsList[2]
        bcrossc = Vec3(b[1]*c[2]-b[2]*c[1], b[2]*c[0]-b[0]*c[2], b[0]*c[1]-b[1]*c[0])
        return unit.Quantity(unit.dot(a, bcrossc), unit.nanometers*unit.nanometers*unit.nanometers)

    def getPositions(self, asNumpy=False):
        """Get the position of each particle with units.
           Raises an exception if postions where not requested in
           the context.getState() call.
           Returns a list of tuples, unless asNumpy is True, in
           which  case a Numpy array of arrays will be returned.
           To remove the units, divide return value by unit.angstrom
           or unit.nanometer.  See the following for details:
           https://simtk.org/home/python_units
           """
        if self._coordList is None:
            raise TypeError('Positions were not requested in getState() call, so are not available.')

        if asNumpy:
            if self._coordListNumpy is None:
                self._coordListNumpy=numpy.array(self._coordList)
            returnValue=self._coordListNumpy
        else:
            returnValue=self._coordList

        returnValue = unit.Quantity(returnValue, unit.nanometers)
        return returnValue

    def getVelocities(self, asNumpy=False):
        """Get the velocity of each particle with units.
           Raises an exception if velocities where not requested in
           the context.getState() call.
           Returns a list of tuples, unless asNumpy is True, in
           which  case a Numpy array of arrays will be returned.
           To remove the units, you can divide the return value by
           unit.angstrom/unit.picosecond or unit.meter/unit.second,
           etc.  See the following for details:
           https://simtk.org/home/python_units
           """
        if self._velList is None:
            raise TypeError('Velocities were not requested in getState() call, so are not available.')

        if asNumpy:
            if self._velListNumpy is None:
                self._velListNumpy=numpy.array(self._velList)
            returnValue=self._velListNumpy
        else:
            returnValue=self._velList

        returnValue = unit.Quantity(returnValue, unit.nanometers/unit.picosecond)
        return returnValue

    def getForces(self, asNumpy=False):
        """Get the force acting on each particle with units.
           Raises an exception if forces where not requested in
           the context.getState() call.
           Returns a list of tuples, unless asNumpy is True, in
           which  case a Numpy array of arrays will be returned.
           To remove the units, you can divide the return value by
           unit.kilojoule_per_mole/unit.angstrom or
           unit.calorie_per_mole/unit.nanometer, etc.
           See the following for details:
           https://simtk.org/home/python_units
           """
        if self._forceList is None:
            raise TypeError('Forces were not requested in getState() call, so are not available.')

        if asNumpy:
            if self._forceListNumpy is None:
                self._forceListNumpy=numpy.array(self._forceList)
            returnValue=self._forceListNumpy
        else:
            returnValue=self._forceList

        returnValue = unit.Quantity(returnValue,
                                    unit.kilojoule_per_mole/unit.nanometer)
        return returnValue

    def getKineticEnergy(self):
        """Get the total kinetic energy of the system with units.
           To remove the units, you can divide the return value by
           unit.kilojoule_per_mole or unit.calorie_per_mole, etc.
           See the following for details:
           https://simtk.org/home/python_units
        """
        if self._eK0 is None:
            raise TypeError('Energy was not requested in getState() call, so it is not available.')
        return self._eK0 * unit.kilojoule_per_mole

    def getPotentialEnergy(self):
        """Get the total potential energy of the system with units.
           To remove the units, you can divide the return value by
           unit.kilojoule_per_mole or unit.kilocalorie_per_mole, etc.
           See the following for details:
           https://simtk.org/home/python_units
        """
        if self._eP0 is None:
            raise TypeError('Energy was not requested in getState() call, so it is not available.')
        return self._eP0 * unit.kilojoule_per_mole

    def getParameters(self):
        """Get a map containing the values of all parameters.
        """
        if self._paramMap is None:
            raise TypeError('Parameters were not requested in getState() call, so are not available.')
        return self._paramMap


def stripUnits(args):
    """
    getState(self, quantity)
          -> value with *no* units

    Examples
    >>> import simtk

    >>> x = 5
    >>> print x
    5

    >>> x = stripUnits((5*simtk.unit.nanometer,))
    >>> x
    (5,)

    >>> arg1 = 5*simtk.unit.angstrom
    >>> x = stripUnits((arg1,))
    >>> x
    (0.5,)

    >>> arg1 = 5
    >>> x = stripUnits((arg1,))
    >>> x
    (5,)

    >>> arg1 = (1*simtk.unit.angstrom, 5*simtk.unit.angstrom)
    >>> x = stripUnits((arg1,))
    >>> x
    ((0.10000000000000001, 0.5),)

    >>> arg1 = (1*simtk.unit.angstrom,
    ...         5*simtk.unit.kilojoule_per_mole,
    ...         1*simtk.unit.kilocalorie_per_mole)
    >>> y = stripUnits((arg1,))
    >>> y
    ((0.10000000000000001, 5, 4.1840000000000002),)

    """
    newArgList=[]
    for arg in args:
        if 'numpy' in sys.modules and isinstance(arg, numpy.ndarray):
           arg = arg.tolist()
        elif unit.is_quantity(arg):
# JDC: Ugly workaround for OpenMM using 'bar' for fundamental pressure unit.
            if arg.unit.is_compatible(unit.bar):
                arg = arg / unit.bar
            else:
                arg = arg.value_in_unit_system(unit.md_unit_system)
# JDC: End workaround.
        elif isinstance(arg, dict):
            newKeys = stripUnits(arg.keys())
            newValues = stripUnits(arg.values())
            arg = dict(zip(newKeys, newValues))
        elif not isinstance(arg, _string_types):
            try:
# Reclusively strip units from all quantities
                arg=stripUnits(arg)
            except TypeError:
                pass
        newArgList.append(arg)
    return tuple(newArgList)

class TabulatedFunction(_object):
    """
    A TabulatedFunction uses a set of tabulated values to define a mathematical function. It can be used by various custom forces.

    TabulatedFunction is an abstract class with concrete subclasses for more specific types of functions. There are subclasses for:

    <ul>
    <li>
    1, 2, and 3 dimensional functions. The dimensionality of a function means the number of input arguments it takes. 

    </li>
    <li>
    Continuous and discrete functions. A continuous function is interpolated by fitting a natural cubic spline to the tabulated values. A discrete function is only defined for integer values of its arguments (that is, at the tabulated points), and does not try to interpolate between them. Discrete function can be evaluated more quickly than continuous ones. 

    </li>
    </ul>
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TabulatedFunction, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TabulatedFunction, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _openmm.delete_TabulatedFunction
    def __del__(self):
        """__del__(OpenMM::TabulatedFunction self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass


    def Copy(self, *args):
        """Copy(TabulatedFunction self) -> TabulatedFunction"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.TabulatedFunction_Copy(self, *args)

TabulatedFunction_swigregister = _openmm.TabulatedFunction_swigregister
TabulatedFunction_swigregister(TabulatedFunction)
NmPerAngstrom = cvar.NmPerAngstrom
AngstromsPerNm = cvar.AngstromsPerNm
PsPerFs = cvar.PsPerFs
FsPerPs = cvar.FsPerPs
KJPerKcal = cvar.KJPerKcal
KcalPerKJ = cvar.KcalPerKJ
RadiansPerDegree = cvar.RadiansPerDegree
DegreesPerRadian = cvar.DegreesPerRadian
SigmaPerVdwRadius = cvar.SigmaPerVdwRadius
VdwRadiusPerSigma = cvar.VdwRadiusPerSigma

class Discrete2DFunction(TabulatedFunction):
    """This is a TabulatedFunction that computes a discrete two dimensional function f(x,y). To evaluate it, x and y are each rounded to the nearest integer and the table element with those indices is returned. If either index is outside the range [0, size), the result is undefined."""
    __swig_setmethods__ = {}
    for _s in [TabulatedFunction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Discrete2DFunction, name, value)
    __swig_getmethods__ = {}
    for _s in [TabulatedFunction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Discrete2DFunction, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OpenMM::Discrete2DFunction self, int xsize, int ysize, vectord values) -> Discrete2DFunction

        This is a TabulatedFunction that computes a discrete two dimensional function f(x,y). To evaluate it, x and y are each rounded to the nearest integer and the table element with those indices is returned. If either index is outside the range [0, size), the result is undefined.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_Discrete2DFunction(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def getFunctionParameters(self, *args):
        """getFunctionParameters(Discrete2DFunction self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Discrete2DFunction_getFunctionParameters(self, *args)


    def setFunctionParameters(self, *args):
        """setFunctionParameters(Discrete2DFunction self, int xsize, int ysize, vectord values)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Discrete2DFunction_setFunctionParameters(self, *args)


    def Copy(self, *args):
        """Copy(Discrete2DFunction self) -> Discrete2DFunction"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Discrete2DFunction_Copy(self, *args)

    __swig_destroy__ = _openmm.delete_Discrete2DFunction
    def __del__(self):
        """__del__(OpenMM::Discrete2DFunction self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

Discrete2DFunction_swigregister = _openmm.Discrete2DFunction_swigregister
Discrete2DFunction_swigregister(Discrete2DFunction)

class Integrator(_object):
    """
    An Integrator defines a method for simulating a System by integrating the equations of motion. This is an abstract class. Subclasses define particular integration methods.

    Each Integrator object is bound to a particular Context which it integrates. This connection is specified by passing the Integrator as an argument to the constructor of the Context.
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Integrator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Integrator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _openmm.delete_Integrator
    def __del__(self):
        """__del__(OpenMM::Integrator self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass


    def getStepSize(self, *args):
        """
        getStepSize(Integrator self) -> double

        Get the size of each time step, in picoseconds. If this integrator uses variable time steps, the size of the most recent step is returned.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.Integrator_getStepSize(self, *args)

        val=unit.Quantity(val, unit.picosecond)


        return val


    def setStepSize(self, *args):
        """
        setStepSize(Integrator self, double size)

        Set the size of each time step, in picoseconds. If this integrator uses variable time steps, the effect of calling this method is undefined, and it may simply be ignored.
           Parameters:
            - size the step size, measured in ps
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Integrator_setStepSize(self, *args)


    def getConstraintTolerance(self, *args):
        """
        getConstraintTolerance(Integrator self) -> double

        Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Integrator_getConstraintTolerance(self, *args)


    def setConstraintTolerance(self, *args):
        """
        setConstraintTolerance(Integrator self, double tol)

        Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Integrator_setConstraintTolerance(self, *args)


    def step(self, *args):
        """
        step(Integrator self, int steps)

        Advance a simulation through time by taking a series of time steps.
           Parameters:
            - steps the number of time steps to take
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Integrator_step(self, *args)


    def __getstate__(self):
        serializationString = XmlSerializer.serialize(self)
        return serializationString

    def __setstate__(self, serializationString):
        system = XmlSerializer.deserialize(serializationString)
        self.this = system.this

Integrator_swigregister = _openmm.Integrator_swigregister
Integrator_swigregister(Integrator)

class LangevinIntegrator(Integrator):
    """This is an Integrator which simulates a System using Langevin dynamics."""
    __swig_setmethods__ = {}
    for _s in [Integrator]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LangevinIntegrator, name, value)
    __swig_getmethods__ = {}
    for _s in [Integrator]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LangevinIntegrator, name)
    __repr__ = _swig_repr

    def getTemperature(self, *args):
        """
        getTemperature(LangevinIntegrator self) -> double

        Get the temperature of the heat bath (in Kelvin).
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.LangevinIntegrator_getTemperature(self, *args)

        val=unit.Quantity(val, unit.kelvin)


        return val


    def setTemperature(self, *args):
        """
        setTemperature(LangevinIntegrator self, double temp)

        Set the temperature of the heat bath (in Kelvin).
           Parameters:
            - temp the temperature of the heat bath, measured in Kelvin
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.LangevinIntegrator_setTemperature(self, *args)


    def getFriction(self, *args):
        """
        getFriction(LangevinIntegrator self) -> double

        Get the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps).
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.LangevinIntegrator_getFriction(self, *args)

        val=unit.Quantity(val, 1/unit.picosecond)


        return val


    def setFriction(self, *args):
        """
        setFriction(LangevinIntegrator self, double coeff)

        Set the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps).
           Parameters:
            - coeff the friction coefficient, measured in 1/ps
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.LangevinIntegrator_setFriction(self, *args)


    def getRandomNumberSeed(self, *args):
        """
        getRandomNumberSeed(LangevinIntegrator self) -> int

        Get the random number seed. See setRandomNumberSeed() for details.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.LangevinIntegrator_getRandomNumberSeed(self, *args)


    def setRandomNumberSeed(self, *args):
        """
        setRandomNumberSeed(LangevinIntegrator self, int seed)

        Set the random number seed. The precise meaning of this parameter is undefined, and is left up to each Platform to interpret in an appropriate way. It is guaranteed that if two simulations are run with different random number seeds, the sequence of random forces will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically.

        If seed is set to 0 (which is the default value assigned), a unique seed is chosen when a Context is created from this Force. This is done to ensure that each Context receives unique random seeds without you needing to set them explicitly.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.LangevinIntegrator_setRandomNumberSeed(self, *args)


    def step(self, *args):
        """
        step(LangevinIntegrator self, int steps)

        Advance a simulation through time by taking a series of time steps.
           Parameters:
            - steps the number of time steps to take
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.LangevinIntegrator_step(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::LangevinIntegrator self, double temperature, double frictionCoeff, double stepSize) -> LangevinIntegrator
        __init__(OpenMM::LangevinIntegrator self, LangevinIntegrator other) -> LangevinIntegrator

        Create a LangevinIntegrator.
           Parameters:
            - temperature the temperature of the heat bath (in Kelvin)
            - frictionCoeff the friction coefficient which couples the system to the heat bath (in inverse picoseconds)
            - stepSize the step size with which to integrate the system (in picoseconds)
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_LangevinIntegrator(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_LangevinIntegrator
    def __del__(self):
        """__del__(OpenMM::LangevinIntegrator self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

LangevinIntegrator_swigregister = _openmm.LangevinIntegrator_swigregister
LangevinIntegrator_swigregister(LangevinIntegrator)

class Force(_object):
    """
    Force objects apply forces to the particles in a System, or alter their behavior in other ways. This is an abstract class. Subclasses define particular forces.

    More specifically, a Force object can do any or all of the following:

    <ul>
    <li>
    Add a contribution to the force on each particle 

    </li>
    <li>
    Add a contribution to the potential energy of the System 

    </li>
    <li>
    Modify the positions and velocities of particles at the start of each time step 

    </li>
    <li>
    Define parameters which are stored in the Context and can be modified by the user 

    </li>
    <li>
    Change the values of parameters defined by other Force objects at the start of each time step 

    </li>
    </ul>


    Forces may be organized into "force groups". This is used for multiple time step integration, and allows subsets of the Forces in a System to be evaluated at different times. By default, all Forces are in group 0. Call setForceGroup() to change this. Some Force subclasses may provide additional methods to further split their computations into multiple groups. Be aware that particular Platforms may place restrictions on the use of force groups, such as requiring all nonbonded forces to be in the same group.
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Force, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Force, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _openmm.delete_Force
    def __del__(self):
        """__del__(OpenMM::Force self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass


    def getForceGroup(self, *args):
        """
        getForceGroup(Force self) -> int

        Get the force group this Force belongs to.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Force_getForceGroup(self, *args)


    def setForceGroup(self, *args):
        """
        setForceGroup(Force self, int group)

        Set the force group this Force belongs to.
           Parameters:
            - group the group index. Legal values are between 0 and 31 (inclusive).
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Force_setForceGroup(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(Force self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions. This method should be overridden for all Force subclasses, or a OpenMM::OpenMMException will be thrown
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Force_usesPeriodicBoundaryConditions(self, *args)


    def __copy__(self):
        copy = self.__class__.__new__(self.__class__)
        copy.__init__(self)
        return copy

    def __deepcopy__(self, memo):
        return self.__copy__()

Force_swigregister = _openmm.Force_swigregister
Force_swigregister(Force)

class CustomGBForce(Force):
    """
    This class implements complex, multiple stage nonbonded interactions between particles. It is designed primarily for implementing Generalized Born implicit solvation models, although it is not strictly limited to that purpose. The interaction is specified as a series of computations, each defined by an arbitrary algebraic expression. It also allows tabulated functions to be defined and used with the computations. It optionally supports periodic boundary conditions and cutoffs for long range interactions.

    The computation consists of calculating some number of per-particle <i>computed values</i>, followed by one or more <i>energy terms</i>. A computed value is a scalar value that is computed for each particle in the system. It may depend on an arbitrary set of global and per-particle parameters, and well as on other computed values that have been calculated before it. Once all computed values have been calculated, the energy terms and their derivatives are evaluated to determine the system energy and particle forces. The energy terms may depend on global parameters, per-particle parameters, and per-particle computed values.

    When specifying a computed value or energy term, you provide an algebraic expression to evaluate and a <i>computation type</i> describing how the expression is to be evaluated. There are two main types of computations:

    <ul>
    <li>
    <b>Single Particle</b>: The expression is evaluated once for each particle in the System. In the case of a computed value, this means the value for a particle depends only on other properties of that particle (its position, parameters, and other computed values). In the case of an energy term, it means each particle makes an independent contribution to the System energy. 

    </li>
    <li>
    <b>Particle Pairs</b>: The expression is evaluated for every pair of particles in the system. In the case of a computed value, the value for a particular particle is calculated by pairing it with every other particle in the system, evaluating the expression for each pair, and summing them. For an energy term, each particle pair makes an independent contribution to the System energy. (Note that energy terms are assumed to be symmetric with respect to the two interacting particles, and therefore are evaluated only once per pair. In contrast, expressions for computed values need not be symmetric and therefore are calculated twice for each pair: once when calculating the value for the first particle, and again when calculating the value for the second particle.) 

    </li>
    </ul>


    Be aware that, although this class is extremely general in the computations it can define, particular Platforms may only support more restricted types of computations. In particular, all currently existing Platforms require that the first computed value <i>must</i> be a particle pair computation, and all computed values after the first <i>must</i> be single particle computations. This is sufficient for most Generalized Born models, but might not permit some other types of calculations to be implemented.

    This is a complicated class to use, and an example may help to clarify it. The following code implements the OBC variant of the GB/SA solvation model, using the ACE approximation to estimate surface area:

    <tt><pre>
    CustomGBForce* custom = new CustomGBForce();
    custom->addPerParticleParameter("q");
    custom->addPerParticleParameter("radius");
    custom->addPerParticleParameter("scale");
    custom->addGlobalParameter("solventDielectric", obc->getSolventDielectric());
    custom->addGlobalParameter("soluteDielectric", obc->getSoluteDielectric());
    custom->addComputedValue("I", "step(r+sr2-or1)*0.5*(1/L-1/U+0.25*(1/U^2-1/L^2)*(r-sr2*sr2/r)+0.5*log(L/U)/r+C);"
                                  "U=r+sr2;"
                                  "C=2*(1/or1-1/L)*step(sr2-r-or1);"
                                  "L=max(or1, D);"
                                  "D=abs(r-sr2);"
                                  "sr2 = scale2*or2;"
                                  "or1 = radius1-0.009; or2 = radius2-0.009", CustomGBForce::ParticlePairNoExclusions);
    custom->addComputedValue("B", "1/(1/or-tanh(1*psi-0.8*psi^2+4.85*psi^3)/radius);"
                                  "psi=I*or; or=radius-0.009", CustomGBForce::SingleParticle);
    custom->addEnergyTerm("28.3919551*(radius+0.14)^2*(radius/B)^6-0.5*138.935456*(1/soluteDielectric-1/solventDielectric)*q^2/B",
                          CustomGBForce::SingleParticle);
    custom->addEnergyTerm("-138.935456*(1/soluteDielectric-1/solventDielectric)*q1*q2/f;"
                          "f=sqrt(r^2+B1*B2*exp(-r^2/(4*B1*B2)))", CustomGBForce::ParticlePair);
    </pre></tt>

    It begins by defining three per-particle parameters (charge, atomic radius, and scale factor) and two global parameters (the dielectric constants for the solute and solvent). It then defines a computed value "I" of type ParticlePair. The expression for evaluating it is a complicated function of the distance between each pair of particles (r), their atomic radii (radius1 and radius2), and their scale factors (scale1 and scale2). Very roughly speaking, it is a measure of the distance between each particle and other nearby particles.

    Next a computation is defined for the Born Radius (B). It is computed independently for each particle, and is a function of that particle's atomic radius and the intermediate value I defined above.

    Finally, two energy terms are defined. The first one is computed for each particle and represents the surface area term, as well as the self interaction part of the polarization energy. The second term is calculated for each pair of particles, and represents the screening of electrostatic interactions by the solvent.

    After defining the force as shown above, you should then call addParticle() once for each particle in the System to set the values of its per-particle parameters (q, radius, and scale). The number of particles for which you set parameters must be exactly equal to the number of particles in the System, or else an exception will be thrown when you try to create a Context. After a particle has been added, you can modify its parameters by calling setParticleParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext().

    CustomGBForce also lets you specify "exclusions", particular pairs of particles whose interactions should be omitted from calculations. This is most often used for particles that are bonded to each other. Even if you specify exclusions, however, you can use the computation type ParticlePairNoExclusions to indicate that exclusions should not be applied to a particular piece of the computation.

    Expressions may involve the operators + (add), - (subtract), * (multiply), / (divide), and ^ (power), and the following functions: sqrt, exp, log, sin, cos, sec, csc, tan, cot, asin, acos, atan, sinh, cosh, tanh, erf, erfc, min, max, abs, floor, ceil, step, delta, select. All trigonometric functions are defined in radians, and log is the natural logarithm. step(x) = 0 if x is less than 0, 1 otherwise. delta(x) = 1 if x is 0, 0 otherwise. select(x,y,z) = z if x = 0, y otherwise. In expressions for particle pair calculations, the names of per-particle parameters and computed values have the suffix "1" or "2" appended to them to indicate the values for the two interacting particles. As seen in the above example, an expression may also involve intermediate quantities that are defined following the main expression, using ";" as a separator.

    In addition, you can call addTabulatedFunction() to define a new function based on tabulated values. You specify the function by creating a TabulatedFunction object. That function can then appear in expressions.
    """
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomGBForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomGBForce, name)
    __repr__ = _swig_repr
    NoCutoff = _openmm.CustomGBForce_NoCutoff
    CutoffNonPeriodic = _openmm.CustomGBForce_CutoffNonPeriodic
    CutoffPeriodic = _openmm.CustomGBForce_CutoffPeriodic
    SingleParticle = _openmm.CustomGBForce_SingleParticle
    ParticlePair = _openmm.CustomGBForce_ParticlePair
    ParticlePairNoExclusions = _openmm.CustomGBForce_ParticlePairNoExclusions
    __swig_destroy__ = _openmm.delete_CustomGBForce
    def __del__(self):
        """__del__(OpenMM::CustomGBForce self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass


    def getNumParticles(self, *args):
        """
        getNumParticles(CustomGBForce self) -> int

        Get the number of particles for which force field parameters have been defined.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getNumParticles(self, *args)


    def getNumExclusions(self, *args):
        """
        getNumExclusions(CustomGBForce self) -> int

        Get the number of particle pairs whose interactions should be excluded.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getNumExclusions(self, *args)


    def getNumPerParticleParameters(self, *args):
        """
        getNumPerParticleParameters(CustomGBForce self) -> int

        Get the number of per-particle parameters that the interaction depends on.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getNumPerParticleParameters(self, *args)


    def getNumGlobalParameters(self, *args):
        """
        getNumGlobalParameters(CustomGBForce self) -> int

        Get the number of global parameters that the interaction depends on.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getNumGlobalParameters(self, *args)


    def getNumTabulatedFunctions(self, *args):
        """
        getNumTabulatedFunctions(CustomGBForce self) -> int

        Get the number of tabulated functions that have been defined.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getNumTabulatedFunctions(self, *args)


    def getNumFunctions(self, *args):
        """
        getNumFunctions(CustomGBForce self) -> int

        Get the number of tabulated functions that have been defined.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getNumFunctions(self, *args)


    def getNumComputedValues(self, *args):
        """
        getNumComputedValues(CustomGBForce self) -> int

        Get the number of per-particle computed values the interaction depends on.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getNumComputedValues(self, *args)


    def getNumEnergyTerms(self, *args):
        """
        getNumEnergyTerms(CustomGBForce self) -> int

        Get the number of terms in the energy computation.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getNumEnergyTerms(self, *args)


    def getNonbondedMethod(self, *args):
        """
        getNonbondedMethod(CustomGBForce self) -> OpenMM::CustomGBForce::NonbondedMethod

        Get the method used for handling long range nonbonded interactions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getNonbondedMethod(self, *args)


    def setNonbondedMethod(self, *args):
        """
        setNonbondedMethod(CustomGBForce self, OpenMM::CustomGBForce::NonbondedMethod method)

        Set the method used for handling long range nonbonded interactions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_setNonbondedMethod(self, *args)


    def getCutoffDistance(self, *args):
        """
        getCutoffDistance(CustomGBForce self) -> double

        Get the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.CustomGBForce_getCutoffDistance(self, *args)

        val=unit.Quantity(val, unit.nanometers)


        return val


    def setCutoffDistance(self, *args):
        """
        setCutoffDistance(CustomGBForce self, double distance)

        Set the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
           Parameters:
            - distance the cutoff distance, measured in nm
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_setCutoffDistance(self, *args)


    def addPerParticleParameter(self, *args):
        """
        addPerParticleParameter(CustomGBForce self, std::string const & name) -> int

        Add a new per-particle parameter that the interaction may depend on.
           Parameters:
            - name the name of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_addPerParticleParameter(self, *args)


    def getPerParticleParameterName(self, *args):
        """
        getPerParticleParameterName(CustomGBForce self, int index) -> std::string const &

        Get the name of a per-particle parameter.
           Parameters:
            - index the index of the parameter for which to get the name
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getPerParticleParameterName(self, *args)


    def setPerParticleParameterName(self, *args):
        """
        setPerParticleParameterName(CustomGBForce self, int index, std::string const & name)

        Set the name of a per-particle parameter.
           Parameters:
            - index the index of the parameter for which to set the name
            - name the name of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_setPerParticleParameterName(self, *args)


    def addGlobalParameter(self, *args):
        """
        addGlobalParameter(CustomGBForce self, std::string const & name, double defaultValue) -> int

        Add a new global parameter that the interaction may depend on.
           Parameters:
            - name the name of the parameter
            - defaultValue the default value of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_addGlobalParameter(self, *args)


    def getGlobalParameterName(self, *args):
        """
        getGlobalParameterName(CustomGBForce self, int index) -> std::string const &

        Get the name of a global parameter.
           Parameters:
            - index the index of the parameter for which to get the name
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getGlobalParameterName(self, *args)


    def setGlobalParameterName(self, *args):
        """
        setGlobalParameterName(CustomGBForce self, int index, std::string const & name)

        Set the name of a global parameter.
           Parameters:
            - index the index of the parameter for which to set the name
            - name the name of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_setGlobalParameterName(self, *args)


    def getGlobalParameterDefaultValue(self, *args):
        """
        getGlobalParameterDefaultValue(CustomGBForce self, int index) -> double

        Get the default value of a global parameter.
           Parameters:
            - index the index of the parameter for which to get the default value
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getGlobalParameterDefaultValue(self, *args)


    def setGlobalParameterDefaultValue(self, *args):
        """
        setGlobalParameterDefaultValue(CustomGBForce self, int index, double defaultValue)

        Set the default value of a global parameter.
           Parameters:
            - index the index of the parameter for which to set the default value
            - name the default value of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_setGlobalParameterDefaultValue(self, *args)


    def addParticle(self, *args):
        """
        addParticle(CustomGBForce self, vectord parameters) -> int

        Add the nonbonded force parameters for a particle. This should be called once for each particle in the System. When it is called for the i'th time, it specifies the parameters for the i'th particle.
           Parameters:
            - parameters the list of parameters for the new particle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_addParticle(self, *args)


    def getParticleParameters(self, *args):
        """
        getParticleParameters(CustomGBForce self, int index)

        Get the nonbonded force parameters for a particle.
           Parameters:
            - index the index of the particle for which to get parameters
            - parameters the list of parameters for the specified particle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getParticleParameters(self, *args)


    def setParticleParameters(self, *args):
        """
        setParticleParameters(CustomGBForce self, int index, vectord parameters)

        Set the nonbonded force parameters for a particle.
           Parameters:
            - index the index of the particle for which to set parameters
            - parameters the list of parameters for the specified particle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_setParticleParameters(self, *args)


    def addComputedValue(self, *args):
        """
        addComputedValue(CustomGBForce self, std::string const & name, std::string const & expression, OpenMM::CustomGBForce::ComputationType type) -> int

        Add a computed value to calculate for each particle.
           Parameters:
            - name the name of the value
            - expression an algebraic expression to evaluate when calculating the computed value. If the ComputationType is SingleParticle, the expression is evaluated independently for each particle, and may depend on its x, y, and z coordinates, as well as the per-particle parameters and previous computed values for that particle. If the ComputationType is ParticlePair or ParticlePairNoExclusions, the expression is evaluated once for every other particle in the system and summed to get the final value. In the latter case, the expression may depend on the distance r between the two particles, and on the per-particle parameters and previous computed values for each of them. Append "1" to a variable name to indicate the parameter for the particle whose value is being calculated, and "2" to indicate the particle it is interacting with.
            - type the method to use for computing this value
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_addComputedValue(self, *args)


    def getComputedValueParameters(self, *args):
        """
        getComputedValueParameters(CustomGBForce self, int index)

        Get the properties of a computed value.
           Parameters:
            - index the index of the computed value for which to get parameters
            - name the name of the value
            - expression an algebraic expression to evaluate when calculating the computed value. If the ComputationType is SingleParticle, the expression is evaluated independently for each particle, and may depend on its x, y, and z coordinates, as well as the per-particle parameters and previous computed values for that particle. If the ComputationType is ParticlePair or ParticlePairNoExclusions, the expression is evaluated once for every other particle in the system and summed to get the final value. In the latter case, the expression may depend on the distance r between the two particles, and on the per-particle parameters and previous computed values for each of them. Append "1" to a variable name to indicate the parameter for the particle whose value is being calculated, and "2" to indicate the particle it is interacting with.
            - type the method to use for computing this value
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getComputedValueParameters(self, *args)


    def setComputedValueParameters(self, *args):
        """
        setComputedValueParameters(CustomGBForce self, int index, std::string const & name, std::string const & expression, OpenMM::CustomGBForce::ComputationType type)

        Set the properties of a computed value.
           Parameters:
            - index the index of the computed value for which to set parameters
            - name the name of the value
            - expression an algebraic expression to evaluate when calculating the computed value. If the ComputationType is SingleParticle, the expression is evaluated independently for each particle, and may depend on its x, y, and z coordinates, as well as the per-particle parameters and previous computed values for that particle. If the ComputationType is ParticlePair or ParticlePairNoExclusions, the expression is evaluated once for every other particle in the system and summed to get the final value. In the latter case, the expression may depend on the distance r between the two particles, and on the per-particle parameters and previous computed values for each of them. Append "1" to a variable name to indicate the parameter for the particle whose value is being calculated, and "2" to indicate the particle it is interacting with.
            - type the method to use for computing this value
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_setComputedValueParameters(self, *args)


    def addEnergyTerm(self, *args):
        """
        addEnergyTerm(CustomGBForce self, std::string const & expression, OpenMM::CustomGBForce::ComputationType type) -> int

        Add a term to the energy computation.
           Parameters:
            - expression an algebraic expression to evaluate when calculating the energy. If the ComputationType is SingleParticle, the expression is evaluated once for each particle, and may depend on its x, y, and z coordinates, as well as the per-particle parameters and computed values for that particle. If the ComputationType is ParticlePair or ParticlePairNoExclusions, the expression is evaluated once for every pair of particles in the system. In the latter case, the expression may depend on the distance r between the two particles, and on the per-particle parameters and computed values for each of them. Append "1" to a variable name to indicate the parameter for the first particle in the pair and "2" to indicate the second particle in the pair.
            - type the method to use for computing this value
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_addEnergyTerm(self, *args)


    def getEnergyTermParameters(self, *args):
        """
        getEnergyTermParameters(CustomGBForce self, int index)

        Get the properties of a term to the energy computation.
           Parameters:
            - index the index of the term for which to get parameters
            - expression an algebraic expression to evaluate when calculating the energy. If the ComputationType is SingleParticle, the expression is evaluated once for each particle, and may depend on its x, y, and z coordinates, as well as the per-particle parameters and computed values for that particle. If the ComputationType is ParticlePair or ParticlePairNoExclusions, the expression is evaluated once for every pair of particles in the system. In the latter case, the expression may depend on the distance r between the two particles, and on the per-particle parameters and computed values for each of them. Append "1" to a variable name to indicate the parameter for the first particle in the pair and "2" to indicate the second particle in the pair.
            - type the method to use for computing this value
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getEnergyTermParameters(self, *args)


    def setEnergyTermParameters(self, *args):
        """
        setEnergyTermParameters(CustomGBForce self, int index, std::string const & expression, OpenMM::CustomGBForce::ComputationType type)

        Set the properties of a term to the energy computation.
           Parameters:
            - index the index of the term for which to set parameters
            - expression an algebraic expression to evaluate when calculating the energy. If the ComputationType is SingleParticle, the expression is evaluated once for each particle, and may depend on its x, y, and z coordinates, as well as the per-particle parameters and computed values for that particle. If the ComputationType is ParticlePair or ParticlePairNoExclusions, the expression is evaluated once for every pair of particles in the system. In the latter case, the expression may depend on the distance r between the two particles, and on the per-particle parameters and computed values for each of them. Append "1" to a variable name to indicate the parameter for the first particle in the pair and "2" to indicate the second particle in the pair.
            - type the method to use for computing this value
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_setEnergyTermParameters(self, *args)


    def addExclusion(self, *args):
        """
        addExclusion(CustomGBForce self, int particle1, int particle2) -> int

        Add a particle pair to the list of interactions that should be excluded.
           Parameters:
            - particle1 the index of the first particle in the pair
            - particle2 the index of the second particle in the pair
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_addExclusion(self, *args)


    def getExclusionParticles(self, *args):
        """
        getExclusionParticles(CustomGBForce self, int index)

        Get the particles in a pair whose interaction should be excluded.
           Parameters:
            - index the index of the exclusion for which to get particle indices
            - particle1 the index of the first particle in the pair
            - particle2 the index of the second particle in the pair
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getExclusionParticles(self, *args)


    def setExclusionParticles(self, *args):
        """
        setExclusionParticles(CustomGBForce self, int index, int particle1, int particle2)

        Set the particles in a pair whose interaction should be excluded.
           Parameters:
            - index the index of the exclusion for which to set particle indices
            - particle1 the index of the first particle in the pair
            - particle2 the index of the second particle in the pair
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_setExclusionParticles(self, *args)


    def addTabulatedFunction(self, *args):
        """
        addTabulatedFunction(CustomGBForce self, std::string const & name, TabulatedFunction function) -> int

        Add a tabulated function that may appear in expressions.
           Parameters:
            - name the name of the function as it appears in expressions
            - function a TabulatedFunction object defining the function. The TabulatedFunction should have been created on the heap with the "new" operator. The Force takes over ownership of it, and deletes it when the Force itself is deleted.
        """

        if not args[1].thisown:
           s = "the %s object does not own its corresponding OpenMM object" \
              % args[1].__class__.__name__
           raise Exception(s)


        val = _openmm.CustomGBForce_addTabulatedFunction(self, *args)

        args[1].thisown=0


        return val


    def getTabulatedFunction(self, *args):
        """
        getTabulatedFunction(CustomGBForce self, int index) -> TabulatedFunction
        getTabulatedFunction(CustomGBForce self, int index) -> TabulatedFunction

        Get a reference to a tabulated function that may appear in expressions.
           Parameters:
            - index the index of the function to get
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getTabulatedFunction(self, *args)


    def getTabulatedFunctionName(self, *args):
        """
        getTabulatedFunctionName(CustomGBForce self, int index) -> std::string const &

        Get the name of a tabulated function that may appear in expressions.
           Parameters:
            - index the index of the function to get
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getTabulatedFunctionName(self, *args)


    def addFunction(self, *args):
        """
        addFunction(CustomGBForce self, std::string const & name, vectord values, double min, double max) -> int

        Add a tabulated function that may appear in expressions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_addFunction(self, *args)


    def getFunctionParameters(self, *args):
        """
        getFunctionParameters(CustomGBForce self, int index)

        Get the parameters for a tabulated function that may appear in expressions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_getFunctionParameters(self, *args)


    def setFunctionParameters(self, *args):
        """
        setFunctionParameters(CustomGBForce self, int index, std::string const & name, vectord values, double min, double max)

        Set the parameters for a tabulated function that may appear in expressions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_setFunctionParameters(self, *args)


    def updateParametersInContext(self, *args):
        """
        updateParametersInContext(CustomGBForce self, Context context)

        Update the per-particle parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setParticleParameters() to modify this object's parameters, then call updateParametersInContext() to copy them over to the Context.

        This method has several limitations. The only information it updates is the values of per-particle parameters. All other aspects of the Force (such as the energy function) are unaffected and can only be changed by reinitializing the Context. Also, this method cannot be used to add new particles, only to change the parameters of existing ones.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_updateParametersInContext(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(CustomGBForce self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomGBForce_usesPeriodicBoundaryConditions(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::CustomGBForce self) -> CustomGBForce
        __init__(OpenMM::CustomGBForce self, CustomGBForce other) -> CustomGBForce

        Create a CustomGBForce.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_CustomGBForce(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
CustomGBForce_swigregister = _openmm.CustomGBForce_swigregister
CustomGBForce_swigregister(CustomGBForce)

class CustomNonbondedForce(Force):
    """
    This class implements nonbonded interactions between particles. Unlike NonbondedForce, the functional form of the interaction is completely customizable, and may involve arbitrary algebraic expressions and tabulated functions. It may depend on the distance between particles, as well as on arbitrary global and per-particle parameters. It also optionally supports periodic boundary conditions and cutoffs for long range interactions.

    To use this class, create a CustomNonbondedForce object, passing an algebraic expression to the constructor that defines the interaction energy between each pair of particles. The expression may depend on r, the distance between the particles, as well as on any parameters you choose. Then call addPerParticleParameter() to define per-particle parameters, and addGlobalParameter() to define global parameters. The values of per-particle parameters are specified as part of the system definition, while values of global parameters may be modified during a simulation by calling Context::setParameter().

    Next, call addParticle() once for each particle in the System to set the values of its per-particle parameters. The number of particles for which you set parameters must be exactly equal to the number of particles in the System, or else an exception will be thrown when you try to create a Context. After a particle has been added, you can modify its parameters by calling setParticleParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext().

    CustomNonbondedForce also lets you specify "exclusions", particular pairs of particles whose interactions should be omitted from force and energy calculations. This is most often used for particles that are bonded to each other.

    As an example, the following code creates a CustomNonbondedForce that implements a 12-6 Lennard-Jones potential:

    <tt>CustomNonbondedForce* force = new CustomNonbondedForce("4*epsilon*((sigma/r)^12-(sigma/r)^6); sigma=0.5*(sigma1+sigma2); epsilon=sqrt(epsilon1*epsilon2)");</tt>

    This force depends on two parameters: sigma and epsilon. The following code defines these as per-particle parameters:

    <tt><pre>
    force->addPerParticleParameter("sigma");
    force->addPerParticleParameter("epsilon");
    </pre></tt>

    The expression <i>must</i> be symmetric with respect to the two particles. It typically will only be evaluated once for each pair of particles, and no guarantee is made about which particle will be identified as "particle 1". In the above example, the energy only depends on the products sigma1*sigma2 and epsilon1*epsilon2, both of which are unchanged if the labels 1 and 2 are reversed. In contrast, if it depended on the difference sigma1-sigma2, the results would be undefined, because reversing the labels 1 and 2 would change the energy.

    CustomNonbondedForce can operate in two modes. By default, it computes the interaction of every particle in the System with every other particle. Alternatively, you can restrict it to only a subset of particle pairs. To do this, specify one or more "interaction groups". An interaction group consists of two sets of particles that should interact with each other. Every particle in the first set interacts with every particle in the second set. For example, you might use this feature to compute a solute-solvent interaction energy, while omitting all interactions between two solute atoms or two solvent atoms.

    To create an interaction group, call addInteractionGroup(). You may add as many interaction groups as you want. Be aware of the following:

    <ul>
    <li>
    Exclusions are still taken into account, so the interactions between excluded pairs are omitted. 

    </li>
    <li>
    Likewise, a particle will never interact with itself, even if it appears in both sets of an interaction group. 

    </li>
    <li>
    If a particle pair appears in two different interaction groups, its interaction will be computed twice. This is sometimes useful, but be aware of it so you do not accidentally create unwanted duplicate interactions. 

    </li>
    <li>
    If you do not add any interaction groups to a CustomNonbondedForce, it operates in the default mode where every particle interacts with every other particle. 

    </li>
    </ul>


    When using a cutoff, by default the interaction is sharply truncated at the cutoff distance. Optionally you can instead use a switching function to make the interaction smoothly go to zero over a finite distance range. To enable this, call setUseSwitchingFunction(). You must also call setSwitchingDistance() to specify the distance at which the interaction should begin to decrease. The switching distance must be less than the cutoff distance. Of course, you could also incorporate the switching function directly into your energy expression, but there are several advantages to keeping it separate. It makes your energy expression simpler to write and understand. It allows you to use the same energy expression with or without a cutoff. Also, when using a long range correction (see below), separating out the switching function allows the correction to be calculated more accurately.

    Another optional feature of this class is to add a contribution to the energy which approximates the effect of all interactions beyond the cutoff in a periodic system. When running a simulation at constant pressure, this can improve the quality of the result. Call setUseLongRangeCorrection() to enable it.

    Computing the long range correction takes negligible work in each time step, but it does require an expensive precomputation at the start of the simulation. Furthermore, that precomputation must be repeated every time a global parameter changes (or when you modify per-particle parameters by calling updateParametersInContext()). This means that if parameters change frequently, the long range correction can be very slow. For this reason, it is disabled by default.

    Expressions may involve the operators + (add), - (subtract), * (multiply), / (divide), and ^ (power), and the following functions: sqrt, exp, log, sin, cos, sec, csc, tan, cot, asin, acos, atan, sinh, cosh, tanh, erf, erfc, min, max, abs, floor, ceil, step, delta, select. All trigonometric functions are defined in radians, and log is the natural logarithm. step(x) = 0 if x is less than 0, 1 otherwise. delta(x) = 1 if x is 0, 0 otherwise. select(x,y,z) = z if x = 0, y otherwise. The names of per-particle parameters have the suffix "1" or "2" appended to them to indicate the values for the two interacting particles. As seen in the above example, the expression may also involve intermediate quantities that are defined following the main expression, using ";" as a separator.

    In addition, you can call addTabulatedFunction() to define a new function based on tabulated values. You specify the function by creating a TabulatedFunction object. That function can then appear in the expression.
    """
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomNonbondedForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomNonbondedForce, name)
    __repr__ = _swig_repr
    NoCutoff = _openmm.CustomNonbondedForce_NoCutoff
    CutoffNonPeriodic = _openmm.CustomNonbondedForce_CutoffNonPeriodic
    CutoffPeriodic = _openmm.CustomNonbondedForce_CutoffPeriodic

    def __init__(self, *args):
        """
        __init__(OpenMM::CustomNonbondedForce self, std::string const & energy) -> CustomNonbondedForce
        __init__(OpenMM::CustomNonbondedForce self, CustomNonbondedForce rhs) -> CustomNonbondedForce

        Create a CustomNonbondedForce.
           Parameters:
            - energy an algebraic expression giving the interaction energy between two particles as a function of r, the distance between them, as well as any global and per-particle parameters
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_CustomNonbondedForce(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_CustomNonbondedForce
    def __del__(self):
        """__del__(OpenMM::CustomNonbondedForce self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass


    def getNumParticles(self, *args):
        """
        getNumParticles(CustomNonbondedForce self) -> int

        Get the number of particles for which force field parameters have been defined.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_getNumParticles(self, *args)


    def getNumExclusions(self, *args):
        """
        getNumExclusions(CustomNonbondedForce self) -> int

        Get the number of particle pairs whose interactions should be excluded.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_getNumExclusions(self, *args)


    def getNumPerParticleParameters(self, *args):
        """
        getNumPerParticleParameters(CustomNonbondedForce self) -> int

        Get the number of per-particle parameters that the interaction depends on.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_getNumPerParticleParameters(self, *args)


    def getNumGlobalParameters(self, *args):
        """
        getNumGlobalParameters(CustomNonbondedForce self) -> int

        Get the number of global parameters that the interaction depends on.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_getNumGlobalParameters(self, *args)


    def getNumTabulatedFunctions(self, *args):
        """
        getNumTabulatedFunctions(CustomNonbondedForce self) -> int

        Get the number of tabulated functions that have been defined.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_getNumTabulatedFunctions(self, *args)


    def getNumFunctions(self, *args):
        """
        getNumFunctions(CustomNonbondedForce self) -> int

        Get the number of tabulated functions that have been defined.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_getNumFunctions(self, *args)


    def getNumInteractionGroups(self, *args):
        """
        getNumInteractionGroups(CustomNonbondedForce self) -> int

        Get the number of interaction groups that have been defined.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_getNumInteractionGroups(self, *args)


    def getEnergyFunction(self, *args):
        """
        getEnergyFunction(CustomNonbondedForce self) -> std::string const &

        Get the algebraic expression that gives the interaction energy between two particles
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_getEnergyFunction(self, *args)


    def setEnergyFunction(self, *args):
        """
        setEnergyFunction(CustomNonbondedForce self, std::string const & energy)

        Set the algebraic expression that gives the interaction energy between two particles
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_setEnergyFunction(self, *args)


    def getNonbondedMethod(self, *args):
        """
        getNonbondedMethod(CustomNonbondedForce self) -> OpenMM::CustomNonbondedForce::NonbondedMethod

        Get the method used for handling long range nonbonded interactions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_getNonbondedMethod(self, *args)


    def setNonbondedMethod(self, *args):
        """
        setNonbondedMethod(CustomNonbondedForce self, OpenMM::CustomNonbondedForce::NonbondedMethod method)

        Set the method used for handling long range nonbonded interactions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_setNonbondedMethod(self, *args)


    def getCutoffDistance(self, *args):
        """
        getCutoffDistance(CustomNonbondedForce self) -> double

        Get the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.CustomNonbondedForce_getCutoffDistance(self, *args)

        val=unit.Quantity(val, unit.nanometers)


        return val


    def setCutoffDistance(self, *args):
        """
        setCutoffDistance(CustomNonbondedForce self, double distance)

        Set the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
           Parameters:
            - distance the cutoff distance, measured in nm
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_setCutoffDistance(self, *args)


    def getUseSwitchingFunction(self, *args):
        """
        getUseSwitchingFunction(CustomNonbondedForce self) -> bool

        Get whether a switching function is applied to the interaction. If the nonbonded method is set to NoCutoff, this option is ignored.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_getUseSwitchingFunction(self, *args)


    def setUseSwitchingFunction(self, *args):
        """
        setUseSwitchingFunction(CustomNonbondedForce self, bool use)

        Set whether a switching function is applied to the interaction. If the nonbonded method is set to NoCutoff, this option is ignored.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_setUseSwitchingFunction(self, *args)


    def getSwitchingDistance(self, *args):
        """
        getSwitchingDistance(CustomNonbondedForce self) -> double

        Get the distance at which the switching function begins to reduce the interaction. This must be less than the cutoff distance.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.CustomNonbondedForce_getSwitchingDistance(self, *args)

        val=unit.Quantity(val, unit.nanometers)


        return val


    def setSwitchingDistance(self, *args):
        """
        setSwitchingDistance(CustomNonbondedForce self, double distance)

        Set the distance at which the switching function begins to reduce the interaction. This must be less than the cutoff distance.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_setSwitchingDistance(self, *args)


    def getUseLongRangeCorrection(self, *args):
        """
        getUseLongRangeCorrection(CustomNonbondedForce self) -> bool

        Get whether to add a correction to the energy to compensate for the cutoff and switching function. This has no effect if periodic boundary conditions are not used.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_getUseLongRangeCorrection(self, *args)


    def setUseLongRangeCorrection(self, *args):
        """
        setUseLongRangeCorrection(CustomNonbondedForce self, bool use)

        Set whether to add a correction to the energy to compensate for the cutoff and switching function. This has no effect if periodic boundary conditions are not used.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_setUseLongRangeCorrection(self, *args)


    def addPerParticleParameter(self, *args):
        """
        addPerParticleParameter(CustomNonbondedForce self, std::string const & name) -> int

        Add a new per-particle parameter that the interaction may depend on.
           Parameters:
            - name the name of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_addPerParticleParameter(self, *args)


    def getPerParticleParameterName(self, *args):
        """
        getPerParticleParameterName(CustomNonbondedForce self, int index) -> std::string const &

        Get the name of a per-particle parameter.
           Parameters:
            - index the index of the parameter for which to get the name
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_getPerParticleParameterName(self, *args)


    def setPerParticleParameterName(self, *args):
        """
        setPerParticleParameterName(CustomNonbondedForce self, int index, std::string const & name)

        Set the name of a per-particle parameter.
           Parameters:
            - index the index of the parameter for which to set the name
            - name the name of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_setPerParticleParameterName(self, *args)


    def addGlobalParameter(self, *args):
        """
        addGlobalParameter(CustomNonbondedForce self, std::string const & name, double defaultValue) -> int

        Add a new global parameter that the interaction may depend on.
           Parameters:
            - name the name of the parameter
            - defaultValue the default value of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_addGlobalParameter(self, *args)


    def getGlobalParameterName(self, *args):
        """
        getGlobalParameterName(CustomNonbondedForce self, int index) -> std::string const &

        Get the name of a global parameter.
           Parameters:
            - index the index of the parameter for which to get the name
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_getGlobalParameterName(self, *args)


    def setGlobalParameterName(self, *args):
        """
        setGlobalParameterName(CustomNonbondedForce self, int index, std::string const & name)

        Set the name of a global parameter.
           Parameters:
            - index the index of the parameter for which to set the name
            - name the name of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_setGlobalParameterName(self, *args)


    def getGlobalParameterDefaultValue(self, *args):
        """
        getGlobalParameterDefaultValue(CustomNonbondedForce self, int index) -> double

        Get the default value of a global parameter.
           Parameters:
            - index the index of the parameter for which to get the default value
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_getGlobalParameterDefaultValue(self, *args)


    def setGlobalParameterDefaultValue(self, *args):
        """
        setGlobalParameterDefaultValue(CustomNonbondedForce self, int index, double defaultValue)

        Set the default value of a global parameter.
           Parameters:
            - index the index of the parameter for which to set the default value
            - name the default value of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_setGlobalParameterDefaultValue(self, *args)


    def addParticle(self, *args):
        """
        addParticle(CustomNonbondedForce self, vectord parameters) -> int

        Add the nonbonded force parameters for a particle. This should be called once for each particle in the System. When it is called for the i'th time, it specifies the parameters for the i'th particle.
           Parameters:
            - parameters the list of parameters for the new particle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_addParticle(self, *args)


    def getParticleParameters(self, *args):
        """
        getParticleParameters(CustomNonbondedForce self, int index)

        Get the nonbonded force parameters for a particle.
           Parameters:
            - index the index of the particle for which to get parameters
            - parameters the list of parameters for the specified particle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_getParticleParameters(self, *args)


    def setParticleParameters(self, *args):
        """
        setParticleParameters(CustomNonbondedForce self, int index, vectord parameters)

        Set the nonbonded force parameters for a particle.
           Parameters:
            - index the index of the particle for which to set parameters
            - parameters the list of parameters for the specified particle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_setParticleParameters(self, *args)


    def addExclusion(self, *args):
        """
        addExclusion(CustomNonbondedForce self, int particle1, int particle2) -> int

        Add a particle pair to the list of interactions that should be excluded.

        In many cases, you can use createExclusionsFromBonds() rather than adding each exclusion explicitly.
           Parameters:
            - particle1 the index of the first particle in the pair
            - particle2 the index of the second particle in the pair
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_addExclusion(self, *args)


    def getExclusionParticles(self, *args):
        """
        getExclusionParticles(CustomNonbondedForce self, int index)

        Get the particles in a pair whose interaction should be excluded.
           Parameters:
            - index the index of the exclusion for which to get particle indices
            - particle1 the index of the first particle in the pair
            - particle2 the index of the second particle in the pair
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_getExclusionParticles(self, *args)


    def setExclusionParticles(self, *args):
        """
        setExclusionParticles(CustomNonbondedForce self, int index, int particle1, int particle2)

        Set the particles in a pair whose interaction should be excluded.
           Parameters:
            - index the index of the exclusion for which to set particle indices
            - particle1 the index of the first particle in the pair
            - particle2 the index of the second particle in the pair
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_setExclusionParticles(self, *args)


    def createExclusionsFromBonds(self, *args):
        """
        createExclusionsFromBonds(CustomNonbondedForce self, vectorpairii bonds, int bondCutoff)

        Identify exclusions based on the molecular topology. Particles which are separated by up to a specified number of bonds are added as exclusions.
           Parameters:
            - bonds the set of bonds based on which to construct exclusions. Each element specifies the indices of two particles that are bonded to each other.
            - bondCutoff pairs of particles that are separated by this many bonds or fewer are added to the list of exclusions
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_createExclusionsFromBonds(self, *args)


    def addTabulatedFunction(self, *args):
        """
        addTabulatedFunction(CustomNonbondedForce self, std::string const & name, TabulatedFunction function) -> int

        Add a tabulated function that may appear in the energy expression.
           Parameters:
            - name the name of the function as it appears in expressions
            - function a TabulatedFunction object defining the function. The TabulatedFunction should have been created on the heap with the "new" operator. The Force takes over ownership of it, and deletes it when the Force itself is deleted.
        """

        if not args[1].thisown:
           s = "the %s object does not own its corresponding OpenMM object" \
              % args[1].__class__.__name__
           raise Exception(s)


        val = _openmm.CustomNonbondedForce_addTabulatedFunction(self, *args)

        args[1].thisown=0


        return val


    def getTabulatedFunction(self, *args):
        """
        getTabulatedFunction(CustomNonbondedForce self, int index) -> TabulatedFunction
        getTabulatedFunction(CustomNonbondedForce self, int index) -> TabulatedFunction

        Get a reference to a tabulated function that may appear in the energy expression.
           Parameters:
            - index the index of the function to get
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_getTabulatedFunction(self, *args)


    def getTabulatedFunctionName(self, *args):
        """
        getTabulatedFunctionName(CustomNonbondedForce self, int index) -> std::string const &

        Get the name of a tabulated function that may appear in the energy expression.
           Parameters:
            - index the index of the function to get
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_getTabulatedFunctionName(self, *args)


    def addFunction(self, *args):
        """
        addFunction(CustomNonbondedForce self, std::string const & name, vectord values, double min, double max) -> int

        Add a tabulated function that may appear in the energy expression.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_addFunction(self, *args)


    def getFunctionParameters(self, *args):
        """
        getFunctionParameters(CustomNonbondedForce self, int index)

        Get the parameters for a tabulated function that may appear in the energy expression.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_getFunctionParameters(self, *args)


    def setFunctionParameters(self, *args):
        """
        setFunctionParameters(CustomNonbondedForce self, int index, std::string const & name, vectord values, double min, double max)

        Set the parameters for a tabulated function that may appear in the energy expression.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_setFunctionParameters(self, *args)


    def addInteractionGroup(self, *args):
        """
        addInteractionGroup(CustomNonbondedForce self, seti set1, seti set2) -> int

        Add an interaction group. An interaction will be computed between every particle in set1 and every particle in set2.
           Parameters:
            - set1 the first set of particles forming the interaction group
            - set2 the second set of particles forming the interaction group
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_addInteractionGroup(self, *args)


    def getInteractionGroupParameters(self, *args):
        """
        getInteractionGroupParameters(CustomNonbondedForce self, int index)

        Get the parameters for an interaction group.
           Parameters:
            - index the index of the interaction group for which to get parameters
            - set1 the first set of particles forming the interaction group
            - set2 the second set of particles forming the interaction group
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_getInteractionGroupParameters(self, *args)


    def setInteractionGroupParameters(self, *args):
        """
        setInteractionGroupParameters(CustomNonbondedForce self, int index, seti set1, seti set2)

        Set the parameters for an interaction group.
           Parameters:
            - index the index of the interaction group for which to set parameters
            - set1 the first set of particles forming the interaction group
            - set2 the second set of particles forming the interaction group
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_setInteractionGroupParameters(self, *args)


    def updateParametersInContext(self, *args):
        """
        updateParametersInContext(CustomNonbondedForce self, Context context)

        Update the per-particle parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setParticleParameters() to modify this object's parameters, then call updateParametersInContext() to copy them over to the Context.

        This method has several limitations. The only information it updates is the values of per-particle parameters. All other aspects of the Force (the energy function, nonbonded method, cutoff distance, etc.) are unaffected and can only be changed by reinitializing the Context. Also, this method cannot be used to add new particles, only to change the parameters of existing ones.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_updateParametersInContext(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(CustomNonbondedForce self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomNonbondedForce_usesPeriodicBoundaryConditions(self, *args)

CustomNonbondedForce_swigregister = _openmm.CustomNonbondedForce_swigregister
CustomNonbondedForce_swigregister(CustomNonbondedForce)

class VariableLangevinIntegrator(Integrator):
    """
    This is an error contolled, variable time step Integrator that simulates a System using Langevin dynamics. It compares the result of the Langevin integrator to that of an explicit Euler integrator, takes the difference between the two as a measure of the integration error in each time step, and continuously adjusts the step size to keep the error below a specified tolerance. This both improves the stability of the integrator and allows it to take larger steps on average, while still maintaining comparable accuracy to a fixed step size integrator.

    It is best not to think of the error tolerance as having any absolute meaning. It is just an adjustable parameter that affects the step size and integration accuracy. You should try different values to find the largest one that produces a trajectory sufficiently accurate for your purposes. 0.001 is often a good starting point.
    """
    __swig_setmethods__ = {}
    for _s in [Integrator]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VariableLangevinIntegrator, name, value)
    __swig_getmethods__ = {}
    for _s in [Integrator]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, VariableLangevinIntegrator, name)
    __repr__ = _swig_repr

    def getTemperature(self, *args):
        """
        getTemperature(VariableLangevinIntegrator self) -> double

        Get the temperature of the heat bath (in Kelvin).
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.VariableLangevinIntegrator_getTemperature(self, *args)

        val=unit.Quantity(val, unit.kelvin)


        return val


    def setTemperature(self, *args):
        """
        setTemperature(VariableLangevinIntegrator self, double temp)

        Set the temperature of the heat bath (in Kelvin).
           Parameters:
            - temp the temperature of the heat bath, measured in Kelvin
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.VariableLangevinIntegrator_setTemperature(self, *args)


    def getFriction(self, *args):
        """
        getFriction(VariableLangevinIntegrator self) -> double

        Get the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps).
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.VariableLangevinIntegrator_getFriction(self, *args)

        val=unit.Quantity(val, 1/unit.picosecond)


        return val


    def setFriction(self, *args):
        """
        setFriction(VariableLangevinIntegrator self, double coeff)

        Set the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps).
           Parameters:
            - coeff the friction coefficient, measured in 1/ps
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.VariableLangevinIntegrator_setFriction(self, *args)


    def getErrorTolerance(self, *args):
        """
        getErrorTolerance(VariableLangevinIntegrator self) -> double

        Get the error tolerance.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.VariableLangevinIntegrator_getErrorTolerance(self, *args)


    def setErrorTolerance(self, *args):
        """
        setErrorTolerance(VariableLangevinIntegrator self, double tol)

        Set the error tolerance.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.VariableLangevinIntegrator_setErrorTolerance(self, *args)


    def getRandomNumberSeed(self, *args):
        """
        getRandomNumberSeed(VariableLangevinIntegrator self) -> int

        Get the random number seed. See setRandomNumberSeed() for details.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.VariableLangevinIntegrator_getRandomNumberSeed(self, *args)


    def setRandomNumberSeed(self, *args):
        """
        setRandomNumberSeed(VariableLangevinIntegrator self, int seed)

        Set the random number seed. The precise meaning of this parameter is undefined, and is left up to each Platform to interpret in an appropriate way. It is guaranteed that if two simulations are run with different random number seeds, the sequence of random forces will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically.

        If seed is set to 0 (which is the default value assigned), a unique seed is chosen when a Context is created from this Force. This is done to ensure that each Context receives unique random seeds without you needing to set them explicitly.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.VariableLangevinIntegrator_setRandomNumberSeed(self, *args)


    def step(self, *args):
        """
        step(VariableLangevinIntegrator self, int steps)

        Advance a simulation through time by taking a series of time steps.
           Parameters:
            - steps the number of time steps to take
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.VariableLangevinIntegrator_step(self, *args)


    def stepTo(self, *args):
        """
        stepTo(VariableLangevinIntegrator self, double time)

        Advance a simulation through time by taking a series of steps until a specified time is reached. When this method returns, the simulation time will exactly equal the time which was specified. If you call this method and specify a time that is earlier than the current time, it will return without doing anything.
           Parameters:
            - time the time to which the simulation should be advanced
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.VariableLangevinIntegrator_stepTo(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::VariableLangevinIntegrator self, double temperature, double frictionCoeff, double errorTol) -> VariableLangevinIntegrator
        __init__(OpenMM::VariableLangevinIntegrator self, VariableLangevinIntegrator other) -> VariableLangevinIntegrator

        Create a VariableLangevinIntegrator.
           Parameters:
            - temperature the temperature of the heat bath (in Kelvin)
            - frictionCoeff the friction coefficient which couples the system to the heat bath (in inverse picoseconds)
            - errorTol the error tolerance
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_VariableLangevinIntegrator(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_VariableLangevinIntegrator
    def __del__(self):
        """__del__(OpenMM::VariableLangevinIntegrator self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

VariableLangevinIntegrator_swigregister = _openmm.VariableLangevinIntegrator_swigregister
VariableLangevinIntegrator_swigregister(VariableLangevinIntegrator)

class AmoebaWcaDispersionForce(Force):
    """
    This class implements a nonbonded interaction between pairs of particles typically used along with AmoebaGeneralizedKirkwoodForce as part of an implicit solvent model.

    To use it, create an AmoebaWcaDispersionForce object then call addParticle() once for each particle. After a particle has been added, you can modify its force field parameters by calling setParticleParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext().
    """
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AmoebaWcaDispersionForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AmoebaWcaDispersionForce, name)
    __repr__ = _swig_repr

    def getNumParticles(self, *args):
        """
        getNumParticles(AmoebaWcaDispersionForce self) -> int

        Get the number of particles
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaWcaDispersionForce_getNumParticles(self, *args)


    def setParticleParameters(self, *args):
        """
        setParticleParameters(AmoebaWcaDispersionForce self, int particleIndex, double radius, double epsilon)

        Set the force field parameters for a WCA dispersion particle.
           Parameters:
            - particleIndex the particle index
            - radius radius
            - epsilon epsilon
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaWcaDispersionForce_setParticleParameters(self, *args)


    def getParticleParameters(self, *args):
        """
        getParticleParameters(AmoebaWcaDispersionForce self, int particleIndex)

        Get the force field parameters for a WCA dispersion particle.
           Parameters:
            - particleIndex the particle index
            - radius radius
            - epsilon epsilon
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaWcaDispersionForce_getParticleParameters(self, *args)

        val[0]=unit.Quantity(val[0], unit.nanometer)
        val[1]=unit.Quantity(val[1], unit.kilojoule_per_mole)


        return val


    def addParticle(self, *args):
        """
        addParticle(AmoebaWcaDispersionForce self, double radius, double epsilon) -> int

        Set the force field parameters for a WCA dispersion particle.
           Parameters:
            - radius radius
            - epsilon epsilon
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaWcaDispersionForce_addParticle(self, *args)


    def updateParametersInContext(self, *args):
        """
        updateParametersInContext(AmoebaWcaDispersionForce self, Context context)

        Update the per-particle parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setParticleParameters() to modify this object's parameters, then call updateParametersInContext() to copy them over to the Context.

        The only information this method updates is the values of per-particle parameters. All other aspects of the Force are unaffected and can only be changed by reinitializing the Context.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaWcaDispersionForce_updateParametersInContext(self, *args)


    def getEpso(self, *args):
        """getEpso(AmoebaWcaDispersionForce self) -> double"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaWcaDispersionForce_getEpso(self, *args)

        val=unit.Quantity(val, unit.kilojoule_per_mole)


        return val


    def getEpsh(self, *args):
        """getEpsh(AmoebaWcaDispersionForce self) -> double"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaWcaDispersionForce_getEpsh(self, *args)

        val=unit.Quantity(val, unit.kilojoule_per_mole)


        return val


    def getRmino(self, *args):
        """getRmino(AmoebaWcaDispersionForce self) -> double"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaWcaDispersionForce_getRmino(self, *args)

        val=unit.Quantity(val, unit.nanometer)


        return val


    def getRminh(self, *args):
        """getRminh(AmoebaWcaDispersionForce self) -> double"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaWcaDispersionForce_getRminh(self, *args)

        val=unit.Quantity(val, unit.nanometer)


        return val


    def getAwater(self, *args):
        """getAwater(AmoebaWcaDispersionForce self) -> double"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaWcaDispersionForce_getAwater(self, *args)

        val=unit.Quantity(val, 1/(unit.nanometer*unit.nanometer*unit.nanometer))


        return val


    def getShctd(self, *args):
        """getShctd(AmoebaWcaDispersionForce self) -> double"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaWcaDispersionForce_getShctd(self, *args)


    def getDispoff(self, *args):
        """getDispoff(AmoebaWcaDispersionForce self) -> double"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaWcaDispersionForce_getDispoff(self, *args)

        val=unit.Quantity(val, unit.nanometer)


        return val


    def getSlevy(self, *args):
        """getSlevy(AmoebaWcaDispersionForce self) -> double"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaWcaDispersionForce_getSlevy(self, *args)


    def setEpso(self, *args):
        """setEpso(AmoebaWcaDispersionForce self, double inputValue)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaWcaDispersionForce_setEpso(self, *args)


    def setEpsh(self, *args):
        """setEpsh(AmoebaWcaDispersionForce self, double inputValue)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaWcaDispersionForce_setEpsh(self, *args)


    def setRmino(self, *args):
        """setRmino(AmoebaWcaDispersionForce self, double inputValue)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaWcaDispersionForce_setRmino(self, *args)


    def setRminh(self, *args):
        """setRminh(AmoebaWcaDispersionForce self, double inputValue)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaWcaDispersionForce_setRminh(self, *args)


    def setAwater(self, *args):
        """setAwater(AmoebaWcaDispersionForce self, double inputValue)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaWcaDispersionForce_setAwater(self, *args)


    def setShctd(self, *args):
        """setShctd(AmoebaWcaDispersionForce self, double inputValue)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaWcaDispersionForce_setShctd(self, *args)


    def setDispoff(self, *args):
        """setDispoff(AmoebaWcaDispersionForce self, double inputValue)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaWcaDispersionForce_setDispoff(self, *args)


    def setSlevy(self, *args):
        """setSlevy(AmoebaWcaDispersionForce self, double inputValue)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaWcaDispersionForce_setSlevy(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(AmoebaWcaDispersionForce self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaWcaDispersionForce_usesPeriodicBoundaryConditions(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::AmoebaWcaDispersionForce self) -> AmoebaWcaDispersionForce
        __init__(OpenMM::AmoebaWcaDispersionForce self, AmoebaWcaDispersionForce other) -> AmoebaWcaDispersionForce

        Create an AmoebaWcaDispersionForce.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_AmoebaWcaDispersionForce(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_AmoebaWcaDispersionForce
    def __del__(self):
        """__del__(OpenMM::AmoebaWcaDispersionForce self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

AmoebaWcaDispersionForce_swigregister = _openmm.AmoebaWcaDispersionForce_swigregister
AmoebaWcaDispersionForce_swigregister(AmoebaWcaDispersionForce)

class RPMDIntegrator(Integrator):
    """
    This is an Integrator which simulates a System using ring polymer molecular dynamics (RPMD). It simulates many copies of the System, with successive copies connected by harmonic springs to form a ring. This allows certain quantum mechanical effects to be efficiently simulated.

    By default this Integrator applies a PILE thermostat to the system to simulate constant temperature dynamics. You can disable the thermostat by calling setApplyThermostat(false).

    Because this Integrator simulates many copies of the System at once, it must be used differently from other Integrators. Instead of setting positions and velocities by calling methods of the Context, you should use the corresponding methods of the Integrator to set them for specific copies of the System. Similarly, you should retrieve state information for particular copies by calling getState() on the Integrator. Do not query the Context for state information.

    You can optionally specify a set of "ring polymer contractions", by which different force groups are evaluated on different numbers of copies, instead of computing every force on every copy. This can be much more efficient, since different forces may vary widely in how many times they must be evaluated to produce sufficient accuracy. For example, you might simulate a 32 copy ring polymer and evaluate bonded forces on every copy, but contract it down to only 6 copies for computing nonbonded interactions, and down to only a single copy (the centroid) for computing the reciprocal space part of PME.
    """
    __swig_setmethods__ = {}
    for _s in [Integrator]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RPMDIntegrator, name, value)
    __swig_getmethods__ = {}
    for _s in [Integrator]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RPMDIntegrator, name)
    __repr__ = _swig_repr

    def getNumCopies(self, *args):
        """
        getNumCopies(RPMDIntegrator self) -> int

        Get the number of copies of the system being simulated.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.RPMDIntegrator_getNumCopies(self, *args)


    def getTemperature(self, *args):
        """
        getTemperature(RPMDIntegrator self) -> double

        Get the temperature of the heat bath (in Kelvin).
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.RPMDIntegrator_getTemperature(self, *args)

        val=unit.Quantity(val, unit.kelvin)


        return val


    def setTemperature(self, *args):
        """
        setTemperature(RPMDIntegrator self, double temp)

        Set the temperature of the heat bath (in Kelvin).
           Parameters:
            - temp the temperature of the heat bath, measured in Kelvin
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.RPMDIntegrator_setTemperature(self, *args)


    def getFriction(self, *args):
        """
        getFriction(RPMDIntegrator self) -> double

        Get the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps).
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.RPMDIntegrator_getFriction(self, *args)

        val=unit.Quantity(val, 1/unit.picosecond)


        return val


    def setFriction(self, *args):
        """
        setFriction(RPMDIntegrator self, double coeff)

        Set the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps).
           Parameters:
            - coeff the friction coefficient, measured in 1/ps
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.RPMDIntegrator_setFriction(self, *args)


    def getApplyThermostat(self, *args):
        """
        getApplyThermostat(RPMDIntegrator self) -> bool

        Get whether a thermostat is applied to the system.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.RPMDIntegrator_getApplyThermostat(self, *args)


    def setApplyThermostat(self, *args):
        """
        setApplyThermostat(RPMDIntegrator self, bool apply)

        Set whether a thermostat is applied to the system.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.RPMDIntegrator_setApplyThermostat(self, *args)


    def getRandomNumberSeed(self, *args):
        """
        getRandomNumberSeed(RPMDIntegrator self) -> int

        Get the random number seed. See setRandomNumberSeed() for details.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.RPMDIntegrator_getRandomNumberSeed(self, *args)


    def setRandomNumberSeed(self, *args):
        """
        setRandomNumberSeed(RPMDIntegrator self, int seed)

        Set the random number seed. The precise meaning of this parameter is undefined, and is left up to each Platform to interpret in an appropriate way. It is guaranteed that if two simulations are run with different random number seeds, the sequence of random forces will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically.

        If seed is set to 0 (which is the default value assigned), a unique seed is chosen when a Context is created from this Force. This is done to ensure that each Context receives unique random seeds without you needing to set them explicitly.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.RPMDIntegrator_setRandomNumberSeed(self, *args)


    def getContractions(self, *args):
        """
        getContractions(RPMDIntegrator self) -> mapii

        Get the ring polymer contractions to use for evaluating different force groups. Each key in the map is the index of a force group, and the corresponding value is the number of copies to evaluate that force group on. If no entry is provided for a force group, it is evaluated independently on every copy.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.RPMDIntegrator_getContractions(self, *args)


    def setPositions(self, *args):
        """
        setPositions(RPMDIntegrator self, int copy, std::vector< Vec3,std::allocator< Vec3 > > const & positions)

        Set the positions of all particles in one copy of the system.
           Parameters:
            - copy the index of the copy for which to set positions
            - positions the positions of all particles in the system
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.RPMDIntegrator_setPositions(self, *args)


    def setVelocities(self, *args):
        """
        setVelocities(RPMDIntegrator self, int copy, std::vector< Vec3,std::allocator< Vec3 > > const & velocities)

        Get the velocities of all particles in one copy of the system.
           Parameters:
            - copy the index of the copy for which to set velocities
            - velocities the velocities of all particles in the system
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.RPMDIntegrator_setVelocities(self, *args)


    def getTotalEnergy(self, *args):
        """
        getTotalEnergy(RPMDIntegrator self) -> double

        Get the total energy of the ring polymer. This includes the potential and kinetic energies of all copies, plus the potential energy of the harmonic springs that link copies together.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.RPMDIntegrator_getTotalEnergy(self, *args)

        val=unit.Quantity(val, unit.kilojoules_per_mole)


        return val


    def step(self, *args):
        """
        step(RPMDIntegrator self, int steps)

        Advance a simulation through time by taking a series of time steps.
           Parameters:
            - steps the number of time steps to take
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.RPMDIntegrator_step(self, *args)


    def _getStateAsLists(self, copy, getPositions, getVelocities, getForces, getEnergy, getParameters, enforcePeriodic, groups):
        """_getStateAsLists(RPMDIntegrator self, int copy, int getPositions, int getVelocities, int getForces, int getEnergy, int getParameters, int enforcePeriodic, int groups) -> PyObject *"""
        return _openmm.RPMDIntegrator__getStateAsLists(self, copy, getPositions, getVelocities, getForces, getEnergy, getParameters, enforcePeriodic, groups)


    def getState(self,
                 copy,
                 getPositions=False,
                 getVelocities=False,
                 getForces=False,
                 getEnergy=False,
                 getParameters=False,
                 enforcePeriodicBox=False,
                 groups=-1):
        """
        getState(self,
                 copy,
                 getPositions = False,
                 getVelocities = False,
                 getForces = False,
                 getEnergy = False,
                 getParameters = False,
                 enforcePeriodicBox = False,
                 groups = -1)
              -> State

        Get a State object recording the current state information about one copy of the system.

        Parameters:
         - copy (int) the index of the copy for which to retrieve state information
         - getPositions (bool=False) whether to store particle positions in the State
         - getVelocities (bool=False) whether to store particle velocities in the State
         - getForces (bool=False) whether to store the forces acting on particles in the State
         - getEnergy (bool=False) whether to store potential and kinetic energy in the State
         - getParameter (bool=False) whether to store context parameters in the State
         - enforcePeriodicBox (bool=False) if false, the position of each particle will be whatever position is stored in the Context, regardless of periodic boundary conditions.  If true, particle positions will be translated so the center of every molecule lies in the same periodic box.
         - groups (int=-1) a set of bit flags for which force groups to include when computing forces and energies.  Group i will be included if (groups&(1<<i)) != 0.  The default value includes all groups.
        """

        if getPositions: getP=1
        else: getP=0
        if getVelocities: getV=1
        else: getV=0
        if getForces: getF=1
        else: getF=0
        if getEnergy: getE=1
        else: getE=0
        if getParameters: getPa=1
        else: getPa=0
        if enforcePeriodicBox: enforcePeriodic=1
        else: enforcePeriodic=0

        (simTime, periodicBoxVectorsList, energy, coordList, velList,
         forceList, paramMap) = \
            self._getStateAsLists(copy, getP, getV, getF, getE, getPa, enforcePeriodic, groups)

        state = State(simTime=simTime,
                      energy=energy,
                      coordList=coordList,
                      velList=velList,
                      forceList=forceList,
                      periodicBoxVectorsList=periodicBoxVectorsList,
                      paramMap=paramMap)
        return state


    def __init__(self, *args):
        """
        __init__(OpenMM::RPMDIntegrator self, int numCopies, double temperature, double frictionCoeff, double stepSize) -> RPMDIntegrator
        __init__(OpenMM::RPMDIntegrator self, int numCopies, double temperature, double frictionCoeff, double stepSize, mapii contractions) -> RPMDIntegrator
        __init__(OpenMM::RPMDIntegrator self, RPMDIntegrator other) -> RPMDIntegrator

        Create a RPMDIntegrator.
           Parameters:
            - numCopies the number of copies of the system that should be simulated
            - temperature the temperature of the heat bath (in Kelvin)
            - frictionCoeff the friction coefficient which couples the system to the heat bath (in inverse picoseconds)
            - stepSize the step size with which to integrator the system (in picoseconds)
            - contractions the ring polymer contractions to use for evaluating different force groups. Each key in the map is the index of a force group, and the corresponding value is the number of copies to evaluate that force group on. If no entry is provided for a force group (the default), it is evaluated independently on every copy.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_RPMDIntegrator(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_RPMDIntegrator
    def __del__(self):
        """__del__(OpenMM::RPMDIntegrator self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

RPMDIntegrator_swigregister = _openmm.RPMDIntegrator_swigregister
RPMDIntegrator_swigregister(RPMDIntegrator)

class AmoebaInPlaneAngleForce(Force):
    """
    This class implements an interaction at trigonal centers corresponding to the projected in-plane angle bend energy between four particles. The interaction is defined by a 6th order polynomial in the angle between them. Only the quadratic term is set per-angle. The coefficients of the higher order terms each have a single value that is set globally.

    To use it, create an AmoebaInPlaneAngleForce object then call addAngle() once for each angle. After an angle has been added, you can modify its force field parameters by calling setAngleParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext().
    """
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AmoebaInPlaneAngleForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AmoebaInPlaneAngleForce, name)
    __repr__ = _swig_repr

    def getNumAngles(self, *args):
        """
        getNumAngles(AmoebaInPlaneAngleForce self) -> int

        Get the number of in-plane angle terms in the potential function
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaInPlaneAngleForce_getNumAngles(self, *args)


    def setAmoebaGlobalInPlaneAngleCubic(self, *args):
        """
        setAmoebaGlobalInPlaneAngleCubic(AmoebaInPlaneAngleForce self, double cubicK)

        Set the global cubic term
           Parameters:
            - cubicK the cubic force constant for the angle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaInPlaneAngleForce_setAmoebaGlobalInPlaneAngleCubic(self, *args)


    def getAmoebaGlobalInPlaneAngleCubic(self, *args):
        """
        getAmoebaGlobalInPlaneAngleCubic(AmoebaInPlaneAngleForce self) -> double

        Get the global cubic term
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaInPlaneAngleForce_getAmoebaGlobalInPlaneAngleCubic(self, *args)


    def setAmoebaGlobalInPlaneAngleQuartic(self, *args):
        """
        setAmoebaGlobalInPlaneAngleQuartic(AmoebaInPlaneAngleForce self, double quarticK)

        Set the global quartic term
           Parameters:
            - quarticK the quartic force constant for the angle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaInPlaneAngleForce_setAmoebaGlobalInPlaneAngleQuartic(self, *args)


    def getAmoebaGlobalInPlaneAngleQuartic(self, *args):
        """
        getAmoebaGlobalInPlaneAngleQuartic(AmoebaInPlaneAngleForce self) -> double

        Get the global quartic term
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaInPlaneAngleForce_getAmoebaGlobalInPlaneAngleQuartic(self, *args)


    def setAmoebaGlobalInPlaneAnglePentic(self, *args):
        """
        setAmoebaGlobalInPlaneAnglePentic(AmoebaInPlaneAngleForce self, double penticK)

        Set the global pentic term
           Parameters:
            - penticK the pentic force constant for the angle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaInPlaneAngleForce_setAmoebaGlobalInPlaneAnglePentic(self, *args)


    def getAmoebaGlobalInPlaneAnglePentic(self, *args):
        """
        getAmoebaGlobalInPlaneAnglePentic(AmoebaInPlaneAngleForce self) -> double

        Get the global pentic term
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaInPlaneAngleForce_getAmoebaGlobalInPlaneAnglePentic(self, *args)


    def setAmoebaGlobalInPlaneAngleSextic(self, *args):
        """
        setAmoebaGlobalInPlaneAngleSextic(AmoebaInPlaneAngleForce self, double sexticK)

        Set the global sextic term
           Parameters:
            - sexticK the sextic force constant for the angle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaInPlaneAngleForce_setAmoebaGlobalInPlaneAngleSextic(self, *args)


    def getAmoebaGlobalInPlaneAngleSextic(self, *args):
        """
        getAmoebaGlobalInPlaneAngleSextic(AmoebaInPlaneAngleForce self) -> double

        Get the global sextic term
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaInPlaneAngleForce_getAmoebaGlobalInPlaneAngleSextic(self, *args)


    def addAngle(self, *args):
        """
        addAngle(AmoebaInPlaneAngleForce self, int particle1, int particle2, int particle3, int particle4, double length, double quadraticK) -> int

        Add an angle term to the force field.
           Parameters:
            - particle1 the index of the first particle connected by the angle
            - particle2 the index of the second particle connected by the angle
            - particle3 the index of the third particle connected by the angle
            - particle4 the index of the fourth particle connected by the angle
            - length the equilibrium angle, measured in radians
            - quadratic k the quadratic force constant for the angle measured in kJ/mol/radian^2
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaInPlaneAngleForce_addAngle(self, *args)


    def getAngleParameters(self, *args):
        """
        getAngleParameters(AmoebaInPlaneAngleForce self, int index)

        Get the force field parameters for an angle term.
           Parameters:
            - index the index of the angle for which to get parameters
            - particle1 the index of the first particle connected by the angle
            - particle2 the index of the second particle connected by the angle
            - particle3 the index of the third particle connected by the angle
            - particle4 the index of the fourth particle connected by the angle
            - length the equilibrium angle, measured in radians
            - quadratic k the quadratic force constant for the angle measured in kJ/mol/radian^2
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaInPlaneAngleForce_getAngleParameters(self, *args)

        val[4]=unit.Quantity(val[4], unit.radian)
        val[5]=unit.Quantity(val[5], unit.kilojoule_per_mole/(unit.radian*unit.radian))


        return val


    def setAngleParameters(self, *args):
        """
        setAngleParameters(AmoebaInPlaneAngleForce self, int index, int particle1, int particle2, int particle3, int particle4, double length, double quadraticK)

        Set the force field parameters for an angle term.
           Parameters:
            - index the index of the angle for which to set parameters
            - particle1 the index of the first particle connected by the angle
            - particle2 the index of the second particle connected by the angle
            - particle3 the index of the third particle connected by the angle
            - particle4 the index of the fourth particle connected by the angle
            - length the equilibrium angle, measured in radians
            - quadratic k the quadratic force constant for the angle, measured in kJ/mol/radian^2
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaInPlaneAngleForce_setAngleParameters(self, *args)


    def updateParametersInContext(self, *args):
        """
        updateParametersInContext(AmoebaInPlaneAngleForce self, Context context)

        Update the per-angle parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setAngleParameters() to modify this object's parameters, then call updateParametersInContext() to copy them over to the Context.

        The only information this method updates is the values of per-angle parameters. The set of particles involved in an angle cannot be changed, nor can new angles be added.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaInPlaneAngleForce_updateParametersInContext(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(AmoebaInPlaneAngleForce self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaInPlaneAngleForce_usesPeriodicBoundaryConditions(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::AmoebaInPlaneAngleForce self) -> AmoebaInPlaneAngleForce
        __init__(OpenMM::AmoebaInPlaneAngleForce self, AmoebaInPlaneAngleForce other) -> AmoebaInPlaneAngleForce

        Create an AmoebaAngleForce.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_AmoebaInPlaneAngleForce(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_AmoebaInPlaneAngleForce
    def __del__(self):
        """__del__(OpenMM::AmoebaInPlaneAngleForce self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

AmoebaInPlaneAngleForce_swigregister = _openmm.AmoebaInPlaneAngleForce_swigregister
AmoebaInPlaneAngleForce_swigregister(AmoebaInPlaneAngleForce)

class VirtualSite(_object):
    """A VirtualSite describes the rules for computing a particle's position based on other particles. This is an abstract class. Subclasses define particular rules. To define a virtual site, create an instance of a VirtualSite subclass and then call setVirtualSite() on the System."""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VirtualSite, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VirtualSite, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _openmm.delete_VirtualSite
    def __del__(self):
        """__del__(OpenMM::VirtualSite self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass


    def getNumParticles(self, *args):
        """
        getNumParticles(VirtualSite self) -> int

        Get the number of particles this virtual site depends on.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.VirtualSite_getNumParticles(self, *args)


    def getParticle(self, *args):
        """
        getParticle(VirtualSite self, int particle) -> int

        Get the index of a particle this virtual site depends on.
           Parameters:
            - particle the particle to get (between 0 and getNumParticles())
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.VirtualSite_getParticle(self, *args)

VirtualSite_swigregister = _openmm.VirtualSite_swigregister
VirtualSite_swigregister(VirtualSite)

class ThreeParticleAverageSite(VirtualSite):
    """This is a VirtualSite that computes the particle location as a weighted average of three other particle's locations. Assuming the weights add up to 1, this means the virtual site is in the plane of the three particles."""
    __swig_setmethods__ = {}
    for _s in [VirtualSite]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ThreeParticleAverageSite, name, value)
    __swig_getmethods__ = {}
    for _s in [VirtualSite]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ThreeParticleAverageSite, name)
    __repr__ = _swig_repr

    def getWeight(self, *args):
        """
        getWeight(ThreeParticleAverageSite self, int particle) -> double

        Get the weight factor used for a particle this virtual site depends on.
           Parameters:
            - particle the particle to get (between 0 and getNumParticles())
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.ThreeParticleAverageSite_getWeight(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::ThreeParticleAverageSite self, int particle1, int particle2, int particle3, double weight1, double weight2, double weight3) -> ThreeParticleAverageSite
        __init__(OpenMM::ThreeParticleAverageSite self, ThreeParticleAverageSite other) -> ThreeParticleAverageSite

        Create a new ThreeParticleAverageSite virtual site. Normally the weights should add up to 1, although this is not strictly required.
           Parameters:
            - particle1 the index of the first particle
            - particle2 the index of the second particle
            - particle3 the index of the third particle
            - weight1 the weight factor (between 0 and 1) for the first particle
            - weight2 the weight factor (between 0 and 1) for the second particle
            - weight2 the weight factor (between 0 and 1) for the third particle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_ThreeParticleAverageSite(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_ThreeParticleAverageSite
    def __del__(self):
        """__del__(OpenMM::ThreeParticleAverageSite self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

ThreeParticleAverageSite_swigregister = _openmm.ThreeParticleAverageSite_swigregister
ThreeParticleAverageSite_swigregister(ThreeParticleAverageSite)

class OutOfPlaneSite(VirtualSite):
    """
    This is a VirtualSite that computes the particle location based on three other particles' locations. If r<sub>1</sub> is the location of particle 1, r<sub>12</sub> is the vector from particle 1 to particle 2, and r<sub>13</sub> is the vector from particle 1 to particle 3, then the virtual site location is given by

    r<sub>1</sub> + w<sub>12</sub>r<sub>12</sub> + w<sub>13</sub>r<sub>13</sub> + w<sub>cross</sub>(r<sub>12</sub> x r<sub>13</sub>)

    The three weight factors are user-specified. This allows the virtual site location to be out of the plane of the three particles.
    """
    __swig_setmethods__ = {}
    for _s in [VirtualSite]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OutOfPlaneSite, name, value)
    __swig_getmethods__ = {}
    for _s in [VirtualSite]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, OutOfPlaneSite, name)
    __repr__ = _swig_repr

    def getWeight12(self, *args):
        """
        getWeight12(OutOfPlaneSite self) -> double

        Get the weight factor for the vector from particle1 to particle2.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.OutOfPlaneSite_getWeight12(self, *args)


    def getWeight13(self, *args):
        """
        getWeight13(OutOfPlaneSite self) -> double

        Get the weight factor for the vector from particle1 to particle3.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.OutOfPlaneSite_getWeight13(self, *args)


    def getWeightCross(self, *args):
        """
        getWeightCross(OutOfPlaneSite self) -> double

        Get the weight factor for the cross product.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.OutOfPlaneSite_getWeightCross(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::OutOfPlaneSite self, int particle1, int particle2, int particle3, double weight12, double weight13, double weightCross) -> OutOfPlaneSite
        __init__(OpenMM::OutOfPlaneSite self, OutOfPlaneSite other) -> OutOfPlaneSite

        Create a new OutOfPlaneSite virtual site.
           Parameters:
            - particle1 the index of the first particle
            - particle2 the index of the second particle
            - particle3 the index of the third particle
            - weight12 the weight factor for the vector from particle1 to particle2
            - weight13 the weight factor for the vector from particle1 to particle3
            - weightCross the weight factor for the cross product
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_OutOfPlaneSite(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_OutOfPlaneSite
    def __del__(self):
        """__del__(OpenMM::OutOfPlaneSite self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

OutOfPlaneSite_swigregister = _openmm.OutOfPlaneSite_swigregister
OutOfPlaneSite_swigregister(OutOfPlaneSite)

class Platform(_object):
    """
    A Platform defines an implementation of all the kernels needed to perform some calculation. More precisely, a Platform object acts as a registry for a set of KernelFactory objects which together implement the kernels. The Platform class, in turn, provides a static registry of all available Platform objects.

    To get a Platform object, call

    <pre>
    Platform& platform Platform::findPlatform(kernelNames);
    </pre>

    passing in the names of all kernels that will be required for the calculation you plan to perform. It will return the fastest available Platform which provides implementations of all the specified kernels. You can then call createKernel() to construct particular kernels as needed.
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Platform, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Platform, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _openmm.delete_Platform
    def __del__(self):
        """__del__(OpenMM::Platform self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass


    def registerPlatform(*args):
        """
        registerPlatform(Platform platform)

        Register a new Platform.
        """

        if not args[0].thisown:
           s = "the %s object does not own its corresponding OpenMM object" \
              % args[0].__class__.__name__
           raise Exception(s)


        val = _openmm.Platform_registerPlatform(*args)

        args[0].thisown=0


        return val

    if _newclass:
        registerPlatform = staticmethod(registerPlatform)
    __swig_getmethods__["registerPlatform"] = lambda x: registerPlatform

    def getNumPlatforms(*args):
        """
        getNumPlatforms() -> int

        Get the number of Platforms that have been registered.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_getNumPlatforms(*args)

    if _newclass:
        getNumPlatforms = staticmethod(getNumPlatforms)
    __swig_getmethods__["getNumPlatforms"] = lambda x: getNumPlatforms

    def getPlatform(*args):
        """
        getPlatform(int index) -> Platform

        Get a registered Platform by index.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_getPlatform(*args)

    if _newclass:
        getPlatform = staticmethod(getPlatform)
    __swig_getmethods__["getPlatform"] = lambda x: getPlatform

    def getPluginLoadFailures(*args):
        """
        getPluginLoadFailures() -> vectorstring

        Get any failures caused during the last call to loadPluginsFromDirectory
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_getPluginLoadFailures(*args)

    if _newclass:
        getPluginLoadFailures = staticmethod(getPluginLoadFailures)
    __swig_getmethods__["getPluginLoadFailures"] = lambda x: getPluginLoadFailures

    def getPlatformByName(*args):
        """
        getPlatformByName(std::string const & name) -> Platform

        Get the registered Platform with a particular name. If no Platform with that name has been registered, this throws an exception.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_getPlatformByName(*args)

    if _newclass:
        getPlatformByName = staticmethod(getPlatformByName)
    __swig_getmethods__["getPlatformByName"] = lambda x: getPlatformByName

    def findPlatform(*args):
        """
        findPlatform(vectorstring kernelNames) -> Platform

        Find a Platform which can be used to perform a calculation.
           Parameters:
            - kernelNames the names of all kernels which will be needed for the calculation
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_findPlatform(*args)

    if _newclass:
        findPlatform = staticmethod(findPlatform)
    __swig_getmethods__["findPlatform"] = lambda x: findPlatform

    def loadPluginLibrary(*args):
        """
        loadPluginLibrary(std::string const & file)

        Load a dynamic library (DLL) which contains an OpenMM plugin. Typically, each Platform is distributed as a separate dynamic library. This method can then be called at runtime to load each available library. Each library should contain an initializer function to register any Platforms and KernelFactories that it contains.

        If the file does not exist or cannot be loaded, an exception is thrown.
           Parameters:
            - file the path to the dynamic library file. This is interpreted using the operating system's rules for loading libraries. Typically it may be either an absolute path or relative to a set of standard locations.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_loadPluginLibrary(*args)

    if _newclass:
        loadPluginLibrary = staticmethod(loadPluginLibrary)
    __swig_getmethods__["loadPluginLibrary"] = lambda x: loadPluginLibrary

    def loadPluginsFromDirectory(*args):
        """
        loadPluginsFromDirectory(std::string const & directory) -> vectorstring

        Load multiple dynamic libraries (DLLs) which contain OpenMM plugins from a single directory. This method loops over every file contained in the specified directory and calls loadPluginLibrary() for each one. If an error occurs while trying to load a particular file, that file is simply ignored. You can retrieve a list of all such errors by calling getPluginLoadFailures().
           Parameters:
            - directory the path to the directory containing libraries to load
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_loadPluginsFromDirectory(*args)

    if _newclass:
        loadPluginsFromDirectory = staticmethod(loadPluginsFromDirectory)
    __swig_getmethods__["loadPluginsFromDirectory"] = lambda x: loadPluginsFromDirectory

    def getDefaultPluginsDirectory(*args):
        """
        getDefaultPluginsDirectory() -> std::string const &

        Get the default directory from which to load plugins. If the environment variable OPENMM_PLUGIN_DIR is set, this returns its value. Otherwise, it returns a platform specific default location.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_getDefaultPluginsDirectory(*args)

    if _newclass:
        getDefaultPluginsDirectory = staticmethod(getDefaultPluginsDirectory)
    __swig_getmethods__["getDefaultPluginsDirectory"] = lambda x: getDefaultPluginsDirectory

    def getOpenMMVersion(*args):
        """
        getOpenMMVersion() -> std::string const &

        Get a string containing the version number of the OpenMM library.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_getOpenMMVersion(*args)

    if _newclass:
        getOpenMMVersion = staticmethod(getOpenMMVersion)
    __swig_getmethods__["getOpenMMVersion"] = lambda x: getOpenMMVersion

    def getName(self, *args):
        """
        getName(Platform self) -> std::string const &

        Get the name of this platform. This should be a unique identifier which can be used to recognized it.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_getName(self, *args)


    def getSpeed(self, *args):
        """
        getSpeed(Platform self) -> double

        Get an estimate of how fast this Platform class is. This need not be precise. It only is expected to return an order or magnitude estimate of the relative performance of different Platform classes. An unoptimized reference implementation should return 1.0, and all other Platforms should return a larger value that is an estimate of how many times faster they are than the reference implementation.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_getSpeed(self, *args)


    def supportsDoublePrecision(self, *args):
        """
        supportsDoublePrecision(Platform self) -> bool

        Get whether this Platform supports double precision arithmetic. If this returns false, the platform is permitted to represent double precision values internally as single precision.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_supportsDoublePrecision(self, *args)


    def getPropertyNames(self, *args):
        """
        getPropertyNames(Platform self) -> vectorstring

        Get the names of all Platform-specific properties this Platform supports.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_getPropertyNames(self, *args)


    def getPropertyValue(self, *args):
        """
        getPropertyValue(Platform self, Context context, std::string const & property) -> std::string const &

        Get the value of a Platform-specific property for a Context.
           Parameters:
            - context the Context for which to get the property
            - property the name of the property to get
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_getPropertyValue(self, *args)


    def setPropertyValue(self, *args):
        """
        setPropertyValue(Platform self, Context context, std::string const & property, std::string const & value)

        Set the value of a Platform-specific property for a Context.
           Parameters:
            - context the Context for which to set the property
            - property the name of the property to set
            - value the value to set for the property
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_setPropertyValue(self, *args)


    def getPropertyDefaultValue(self, *args):
        """
        getPropertyDefaultValue(Platform self, std::string const & property) -> std::string const &

        Get the default value of a Platform-specific property. This is the value that will be used for newly created Contexts.
           Parameters:
            - property the name of the property to get
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_getPropertyDefaultValue(self, *args)


    def setPropertyDefaultValue(self, *args):
        """
        setPropertyDefaultValue(Platform self, std::string const & property, std::string const & value)

        Set the default value of a Platform-specific property. This is the value that will be used for newly created Contexts.
           Parameters:
            - property the name of the property to set
            - value the value to set for the property
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_setPropertyDefaultValue(self, *args)


    def supportsKernels(self, *args):
        """
        supportsKernels(Platform self, vectorstring kernelNames) -> bool

        Determine whether this Platforms provides implementations of a set of kernels.
           Parameters:
            - kernelNames the names of the kernels of interests
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Platform_supportsKernels(self, *args)

Platform_swigregister = _openmm.Platform_swigregister
Platform_swigregister(Platform)

def Platform_registerPlatform(*args):
    """
    Platform_registerPlatform(Platform platform)

    Register a new Platform.
    """

    if not args[0].thisown:
       s = "the %s object does not own its corresponding OpenMM object" \
          % args[0].__class__.__name__
       raise Exception(s)


    val = _openmm.Platform_registerPlatform(*args)

    args[0].thisown=0


    return val

def Platform_getNumPlatforms(*args):
    """
    Platform_getNumPlatforms() -> int

    Get the number of Platforms that have been registered.
    """

    try: args=stripUnits(args)
    except UnboundLocalError: pass


    return _openmm.Platform_getNumPlatforms(*args)

def Platform_getPlatform(*args):
    """
    Platform_getPlatform(int index) -> Platform

    Get a registered Platform by index.
    """

    try: args=stripUnits(args)
    except UnboundLocalError: pass


    return _openmm.Platform_getPlatform(*args)

def Platform_getPluginLoadFailures(*args):
    """
    Platform_getPluginLoadFailures() -> vectorstring

    Get any failures caused during the last call to loadPluginsFromDirectory
    """

    try: args=stripUnits(args)
    except UnboundLocalError: pass


    return _openmm.Platform_getPluginLoadFailures(*args)

def Platform_getPlatformByName(*args):
    """
    Platform_getPlatformByName(std::string const & name) -> Platform

    Get the registered Platform with a particular name. If no Platform with that name has been registered, this throws an exception.
    """

    try: args=stripUnits(args)
    except UnboundLocalError: pass


    return _openmm.Platform_getPlatformByName(*args)

def Platform_findPlatform(*args):
    """
    Platform_findPlatform(vectorstring kernelNames) -> Platform

    Find a Platform which can be used to perform a calculation.
       Parameters:
        - kernelNames the names of all kernels which will be needed for the calculation
    """

    try: args=stripUnits(args)
    except UnboundLocalError: pass


    return _openmm.Platform_findPlatform(*args)

def Platform_loadPluginLibrary(*args):
    """
    Platform_loadPluginLibrary(std::string const & file)

    Load a dynamic library (DLL) which contains an OpenMM plugin. Typically, each Platform is distributed as a separate dynamic library. This method can then be called at runtime to load each available library. Each library should contain an initializer function to register any Platforms and KernelFactories that it contains.

    If the file does not exist or cannot be loaded, an exception is thrown.
       Parameters:
        - file the path to the dynamic library file. This is interpreted using the operating system's rules for loading libraries. Typically it may be either an absolute path or relative to a set of standard locations.
    """

    try: args=stripUnits(args)
    except UnboundLocalError: pass


    return _openmm.Platform_loadPluginLibrary(*args)

def Platform_loadPluginsFromDirectory(*args):
    """
    Platform_loadPluginsFromDirectory(std::string const & directory) -> vectorstring

    Load multiple dynamic libraries (DLLs) which contain OpenMM plugins from a single directory. This method loops over every file contained in the specified directory and calls loadPluginLibrary() for each one. If an error occurs while trying to load a particular file, that file is simply ignored. You can retrieve a list of all such errors by calling getPluginLoadFailures().
       Parameters:
        - directory the path to the directory containing libraries to load
    """

    try: args=stripUnits(args)
    except UnboundLocalError: pass


    return _openmm.Platform_loadPluginsFromDirectory(*args)

def Platform_getDefaultPluginsDirectory(*args):
    """
    Platform_getDefaultPluginsDirectory() -> std::string const &

    Get the default directory from which to load plugins. If the environment variable OPENMM_PLUGIN_DIR is set, this returns its value. Otherwise, it returns a platform specific default location.
    """

    try: args=stripUnits(args)
    except UnboundLocalError: pass


    return _openmm.Platform_getDefaultPluginsDirectory(*args)

def Platform_getOpenMMVersion(*args):
    """
    Platform_getOpenMMVersion() -> std::string const &

    Get a string containing the version number of the OpenMM library.
    """

    try: args=stripUnits(args)
    except UnboundLocalError: pass


    return _openmm.Platform_getOpenMMVersion(*args)

class VerletIntegrator(Integrator):
    """This is an Integrator which simulates a System using the leap-frog Verlet algorithm."""
    __swig_setmethods__ = {}
    for _s in [Integrator]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VerletIntegrator, name, value)
    __swig_getmethods__ = {}
    for _s in [Integrator]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, VerletIntegrator, name)
    __repr__ = _swig_repr

    def step(self, *args):
        """
        step(VerletIntegrator self, int steps)

        Advance a simulation through time by taking a series of time steps.
           Parameters:
            - steps the number of time steps to take
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.VerletIntegrator_step(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::VerletIntegrator self, double stepSize) -> VerletIntegrator
        __init__(OpenMM::VerletIntegrator self, VerletIntegrator other) -> VerletIntegrator

        Create a VerletIntegrator.
           Parameters:
            - stepSize the step size with which to integrate the system (in picoseconds)
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_VerletIntegrator(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_VerletIntegrator
    def __del__(self):
        """__del__(OpenMM::VerletIntegrator self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

VerletIntegrator_swigregister = _openmm.VerletIntegrator_swigregister
VerletIntegrator_swigregister(VerletIntegrator)

class DrudeSCFIntegrator(Integrator):
    """
    This is a leap-frog Verlet Integrator that simulates systems with Drude particles. It uses the self-consistent field (SCF) method: at every time step, the positions of Drude particles are adjusted to minimize the potential energy.

    This Integrator requires the System to include a DrudeForce, which it uses to identify the Drude particles.
    """
    __swig_setmethods__ = {}
    for _s in [Integrator]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DrudeSCFIntegrator, name, value)
    __swig_getmethods__ = {}
    for _s in [Integrator]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DrudeSCFIntegrator, name)
    __repr__ = _swig_repr

    def getMinimizationErrorTolerance(self, *args):
        """
        getMinimizationErrorTolerance(DrudeSCFIntegrator self) -> double

        Get the error tolerance to use when minimizing the potential energy. This roughly corresponds to the maximum allowed force magnitude on the Drude particles after minimization.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.DrudeSCFIntegrator_getMinimizationErrorTolerance(self, *args)

        val=unit.Quantity(val, unit.kilojoules_per_mole/unit.nanometer)


        return val


    def setMinimizationErrorTolerance(self, *args):
        """
        setMinimizationErrorTolerance(DrudeSCFIntegrator self, double tol)

        Set the error tolerance to use when minimizing the potential energy. This roughly corresponds to the maximum allowed force magnitude on the Drude particles after minimization.
           Parameters:
            - tol the error tolerance to use, measured in kJ/mol/nm
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.DrudeSCFIntegrator_setMinimizationErrorTolerance(self, *args)


    def step(self, *args):
        """
        step(DrudeSCFIntegrator self, int steps)

        Advance a simulation through time by taking a series of time steps.
           Parameters:
            - steps the number of time steps to take
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.DrudeSCFIntegrator_step(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::DrudeSCFIntegrator self, double stepSize) -> DrudeSCFIntegrator
        __init__(OpenMM::DrudeSCFIntegrator self, DrudeSCFIntegrator other) -> DrudeSCFIntegrator

        Create a DrudeSCFIntegrator.
           Parameters:
            - stepSize the step size with which to integrator the system (in picoseconds)
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_DrudeSCFIntegrator(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_DrudeSCFIntegrator
    def __del__(self):
        """__del__(OpenMM::DrudeSCFIntegrator self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

DrudeSCFIntegrator_swigregister = _openmm.DrudeSCFIntegrator_swigregister
DrudeSCFIntegrator_swigregister(DrudeSCFIntegrator)

class MonteCarloMembraneBarostat(Force):
    """
    This is a Monte Carlo barostat designed specifically for membrane simulations. It assumes the membrane lies in the XY plane. The Monte Carlo acceptance criterion includes a term to model isotropic pressure, which depends on the volume of the periodic box, and a second term to model surface tension, which depends on the cross sectional area of the box in the XY plane. Note that pressure and surface tension are defined with opposite senses: a larger pressure tends to make the box smaller, but a larger surface tension tends to make the box larger.

    There are options for configuring exactly how the various box dimensions are allowed to change:

    <ul>
    <li>
    The X and Y axes may be treated isotropically, in which case they always scale by the same amount and remain in proportion to each other; or they may be treated anisotropically, in which case they can vary independently of each other. 

    </li>
    <li>
    The Z axis can be allowed to vary independently of the other axes; or held fixed; or constrained to vary in inverse proportion to the other two axes, so that the total box volume remains fixed. 

    </li>
    </ul>


    This class assumes the simulation is also being run at constant temperature, and requires you to specify the system temperature (since it affects the acceptance probability for Monte Carlo moves). It does not actually perform temperature regulation, however. You must use another mechanism along with it to maintain the temperature, such as LangevinIntegrator or AndersenThermostat.
    """
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MonteCarloMembraneBarostat, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MonteCarloMembraneBarostat, name)
    __repr__ = _swig_repr
    XYIsotropic = _openmm.MonteCarloMembraneBarostat_XYIsotropic
    XYAnisotropic = _openmm.MonteCarloMembraneBarostat_XYAnisotropic
    ZFree = _openmm.MonteCarloMembraneBarostat_ZFree
    ZFixed = _openmm.MonteCarloMembraneBarostat_ZFixed
    ConstantVolume = _openmm.MonteCarloMembraneBarostat_ConstantVolume

    def Pressure(*args):
        """
        Pressure() -> std::string const &

        This is the name of the parameter which stores the current pressure acting on the system (in bar).
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloMembraneBarostat_Pressure(*args)

    if _newclass:
        Pressure = staticmethod(Pressure)
    __swig_getmethods__["Pressure"] = lambda x: Pressure

    def SurfaceTension(*args):
        """
        SurfaceTension() -> std::string const &

        This is the name of the parameter which stores the current surface tension acting on the system (in bar*nm).
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloMembraneBarostat_SurfaceTension(*args)

    if _newclass:
        SurfaceTension = staticmethod(SurfaceTension)
    __swig_getmethods__["SurfaceTension"] = lambda x: SurfaceTension

    def getDefaultPressure(self, *args):
        """
        getDefaultPressure(MonteCarloMembraneBarostat self) -> double

        Get the default pressure acting on the system (in bar).
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.MonteCarloMembraneBarostat_getDefaultPressure(self, *args)

        val=unit.Quantity(val, unit.bar)


        return val


    def setDefaultPressure(self, *args):
        """
        setDefaultPressure(MonteCarloMembraneBarostat self, double pressure)

        Set the default pressure acting on the system. This will affect any new Contexts you create, but not ones that already exist.
           Parameters:
            - pressure the default pressure acting on the system, measured in bar.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloMembraneBarostat_setDefaultPressure(self, *args)


    def getDefaultSurfaceTension(self, *args):
        """
        getDefaultSurfaceTension(MonteCarloMembraneBarostat self) -> double

        Get the default surface tension acting on the system (in bar*nm).
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.MonteCarloMembraneBarostat_getDefaultSurfaceTension(self, *args)

        val=unit.Quantity(val, unit.bar*unit.nanometer)


        return val


    def setDefaultSurfaceTension(self, *args):
        """
        setDefaultSurfaceTension(MonteCarloMembraneBarostat self, double surfaceTension)

        Set the default surface tension acting on the system. This will affect any new Contexts you create, but not ones that already exist.
           Parameters:
            - surfaceTension the default surface tension acting on the system, measured in bar.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloMembraneBarostat_setDefaultSurfaceTension(self, *args)


    def getFrequency(self, *args):
        """
        getFrequency(MonteCarloMembraneBarostat self) -> int

        Get the frequency (in time steps) at which Monte Carlo volume changes should be attempted. If this is set to 0, the barostat is disabled.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloMembraneBarostat_getFrequency(self, *args)


    def setFrequency(self, *args):
        """
        setFrequency(MonteCarloMembraneBarostat self, int freq)

        Set the frequency (in time steps) at which Monte Carlo volume changes should be attempted. If this is set to 0, the barostat is disabled.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloMembraneBarostat_setFrequency(self, *args)


    def getTemperature(self, *args):
        """
        getTemperature(MonteCarloMembraneBarostat self) -> double

        Get the temperature at which the system is being maintained, measured in Kelvin.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.MonteCarloMembraneBarostat_getTemperature(self, *args)

        val=unit.Quantity(val, unit.kelvin)


        return val


    def setTemperature(self, *args):
        """
        setTemperature(MonteCarloMembraneBarostat self, double temp)

        Set the temperature at which the system is being maintained.
           Parameters:
            - temp the system temperature, measured in Kelvin.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloMembraneBarostat_setTemperature(self, *args)


    def getXYMode(self, *args):
        """
        getXYMode(MonteCarloMembraneBarostat self) -> OpenMM::MonteCarloMembraneBarostat::XYMode

        Get the mode specifying the behavior of the X and Y axes.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloMembraneBarostat_getXYMode(self, *args)


    def setXYMode(self, *args):
        """
        setXYMode(MonteCarloMembraneBarostat self, OpenMM::MonteCarloMembraneBarostat::XYMode mode)

        Set the mode specifying the behavior of the X and Y axes.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloMembraneBarostat_setXYMode(self, *args)


    def getZMode(self, *args):
        """
        getZMode(MonteCarloMembraneBarostat self) -> OpenMM::MonteCarloMembraneBarostat::ZMode

        Get the mode specifying the behavior of the Z axis.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloMembraneBarostat_getZMode(self, *args)


    def setZMode(self, *args):
        """
        setZMode(MonteCarloMembraneBarostat self, OpenMM::MonteCarloMembraneBarostat::ZMode mode)

        Set the mode specifying the behavior of the Z axis.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloMembraneBarostat_setZMode(self, *args)


    def getRandomNumberSeed(self, *args):
        """
        getRandomNumberSeed(MonteCarloMembraneBarostat self) -> int

        Get the random number seed. See setRandomNumberSeed() for details.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloMembraneBarostat_getRandomNumberSeed(self, *args)


    def setRandomNumberSeed(self, *args):
        """
        setRandomNumberSeed(MonteCarloMembraneBarostat self, int seed)

        Set the random number seed. It is guaranteed that if two simulations are run with different random number seeds, the sequence of Monte Carlo steps will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically.

        If seed is set to 0 (which is the default value assigned), a unique seed is chosen when a Context is created from this Force. This is done to ensure that each Context receives unique random seeds without you needing to set them explicitly.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloMembraneBarostat_setRandomNumberSeed(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(MonteCarloMembraneBarostat self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloMembraneBarostat_usesPeriodicBoundaryConditions(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::MonteCarloMembraneBarostat self, double defaultPressure, double defaultSurfaceTension, double temperature, OpenMM::MonteCarloMembraneBarostat::XYMode xymode, OpenMM::MonteCarloMembraneBarostat::ZMode zmode, int frequency=25) -> MonteCarloMembraneBarostat
        __init__(OpenMM::MonteCarloMembraneBarostat self, MonteCarloMembraneBarostat other) -> MonteCarloMembraneBarostat

        Create a MonteCarloMembraneBarostat.
           Parameters:
            - defaultPressure the default pressure acting on the system (in bar)
            - defaultSurfaceTension the default surface tension acting on the system (in bar*nm)
            - temperature the temperature at which the system is being maintained (in Kelvin)
            - xymode the mode specifying the behavior of the X and Y axes
            - zmode the mode specifying the behavior of the Z axis
            - frequency the frequency at which Monte Carlo volume changes should be attempted (in time steps)
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_MonteCarloMembraneBarostat(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_MonteCarloMembraneBarostat
    def __del__(self):
        """__del__(OpenMM::MonteCarloMembraneBarostat self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

MonteCarloMembraneBarostat_swigregister = _openmm.MonteCarloMembraneBarostat_swigregister
MonteCarloMembraneBarostat_swigregister(MonteCarloMembraneBarostat)

def MonteCarloMembraneBarostat_Pressure(*args):
    """
    MonteCarloMembraneBarostat_Pressure() -> std::string const &

    This is the name of the parameter which stores the current pressure acting on the system (in bar).
    """

    try: args=stripUnits(args)
    except UnboundLocalError: pass


    return _openmm.MonteCarloMembraneBarostat_Pressure(*args)

def MonteCarloMembraneBarostat_SurfaceTension(*args):
    """
    MonteCarloMembraneBarostat_SurfaceTension() -> std::string const &

    This is the name of the parameter which stores the current surface tension acting on the system (in bar*nm).
    """

    try: args=stripUnits(args)
    except UnboundLocalError: pass


    return _openmm.MonteCarloMembraneBarostat_SurfaceTension(*args)

class MonteCarloBarostat(Force):
    """
    This class uses a Monte Carlo algorithm to adjust the size of the periodic box, simulating the effect of constant pressure.

    This class assumes the simulation is also being run at constant temperature, and requires you to specify the system temperature (since it affects the acceptance probability for Monte Carlo moves). It does not actually perform temperature regulation, however. You must use another mechanism along with it to maintain the temperature, such as LangevinIntegrator or AndersenThermostat.
    """
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MonteCarloBarostat, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MonteCarloBarostat, name)
    __repr__ = _swig_repr

    def Pressure(*args):
        """
        Pressure() -> std::string const &

        This is the name of the parameter which stores the current pressure acting on the system (in bar).
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloBarostat_Pressure(*args)

    if _newclass:
        Pressure = staticmethod(Pressure)
    __swig_getmethods__["Pressure"] = lambda x: Pressure

    def getDefaultPressure(self, *args):
        """
        getDefaultPressure(MonteCarloBarostat self) -> double

        Get the default pressure acting on the system (in bar).
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.MonteCarloBarostat_getDefaultPressure(self, *args)

        val=unit.Quantity(val, unit.bar)


        return val


    def setDefaultPressure(self, *args):
        """
        setDefaultPressure(MonteCarloBarostat self, double pressure)

        Set the default pressure acting on the system. This will affect any new Contexts you create, but not ones that already exist.
           Parameters:
            - pressure the default pressure acting on the system, measured in bar.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloBarostat_setDefaultPressure(self, *args)


    def getFrequency(self, *args):
        """
        getFrequency(MonteCarloBarostat self) -> int

        Get the frequency (in time steps) at which Monte Carlo pressure changes should be attempted. If this is set to 0, the barostat is disabled.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloBarostat_getFrequency(self, *args)


    def setFrequency(self, *args):
        """
        setFrequency(MonteCarloBarostat self, int freq)

        Set the frequency (in time steps) at which Monte Carlo pressure changes should be attempted. If this is set to 0, the barostat is disabled.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloBarostat_setFrequency(self, *args)


    def getTemperature(self, *args):
        """
        getTemperature(MonteCarloBarostat self) -> double

        Get the temperature at which the system is being maintained, measured in Kelvin.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.MonteCarloBarostat_getTemperature(self, *args)

        val=unit.Quantity(val, unit.kelvin)


        return val


    def setTemperature(self, *args):
        """
        setTemperature(MonteCarloBarostat self, double temp)

        Set the temperature at which the system is being maintained.
           Parameters:
            - temp the system temperature, measured in Kelvin.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloBarostat_setTemperature(self, *args)


    def getRandomNumberSeed(self, *args):
        """
        getRandomNumberSeed(MonteCarloBarostat self) -> int

        Get the random number seed. See setRandomNumberSeed() for details.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloBarostat_getRandomNumberSeed(self, *args)


    def setRandomNumberSeed(self, *args):
        """
        setRandomNumberSeed(MonteCarloBarostat self, int seed)

        Set the random number seed. It is guaranteed that if two simulations are run with different random number seeds, the sequence of Monte Carlo steps will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically.

        If seed is set to 0 (which is the default value assigned), a unique seed is chosen when a Context is created from this Force. This is done to ensure that each Context receives unique random seeds without you needing to set them explicitly.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloBarostat_setRandomNumberSeed(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(MonteCarloBarostat self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloBarostat_usesPeriodicBoundaryConditions(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::MonteCarloBarostat self, double defaultPressure, double temperature, int frequency=25) -> MonteCarloBarostat
        __init__(OpenMM::MonteCarloBarostat self, MonteCarloBarostat other) -> MonteCarloBarostat

        Create a MonteCarloBarostat.
           Parameters:
            - defaultPressure the default pressure acting on the system (in bar)
            - temperature the temperature at which the system is being maintained (in Kelvin)
            - frequency the frequency at which Monte Carlo pressure changes should be attempted (in time steps)
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_MonteCarloBarostat(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_MonteCarloBarostat
    def __del__(self):
        """__del__(OpenMM::MonteCarloBarostat self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

MonteCarloBarostat_swigregister = _openmm.MonteCarloBarostat_swigregister
MonteCarloBarostat_swigregister(MonteCarloBarostat)

def MonteCarloBarostat_Pressure(*args):
    """
    MonteCarloBarostat_Pressure() -> std::string const &

    This is the name of the parameter which stores the current pressure acting on the system (in bar).
    """

    try: args=stripUnits(args)
    except UnboundLocalError: pass


    return _openmm.MonteCarloBarostat_Pressure(*args)

class AmoebaTorsionTorsionForce(Force):
    """
    This class implements the Amoeba torsion-torsion interaction.

    To use it, create an AmoebaTorsionTorsionForce object then call addTorsionTorsion() once for each torsion-torsion. After a torsion-torsion has been added, you can modify its force field parameters by calling setTorsionTorsionParameters().
    """
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AmoebaTorsionTorsionForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AmoebaTorsionTorsionForce, name)
    __repr__ = _swig_repr

    def getNumTorsionTorsions(self, *args):
        """
        getNumTorsionTorsions(AmoebaTorsionTorsionForce self) -> int

        Get the number of torsion-torsion terms in the potential function
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaTorsionTorsionForce_getNumTorsionTorsions(self, *args)


    def getNumTorsionTorsionGrids(self, *args):
        """
        getNumTorsionTorsionGrids(AmoebaTorsionTorsionForce self) -> int

        Get the number of torsion-torsion grids
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaTorsionTorsionForce_getNumTorsionTorsionGrids(self, *args)


    def addTorsionTorsion(self, *args):
        """
        addTorsionTorsion(AmoebaTorsionTorsionForce self, int particle1, int particle2, int particle3, int particle4, int particle5, int chiralCheckAtomIndex, int gridIndex) -> int

        Add a torsion-torsion term to the force field.
           Parameters:
            - particle1 the index of the first particle connected by the torsion-torsion
            - particle2 the index of the second particle connected by the torsion-torsion
            - particle3 the index of the third particle connected by the torsion-torsion
            - particle4 the index of the fourth particle connected by the torsion-torsion
            - particle5 the index of the fifth particle connected by the torsion-torsion
            - chiralCheckAtomIndex the index of the particle connected to particle3, but not particle2 or particle4 to be used in chirality check
            - gridIndex the index to the grid to be used
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaTorsionTorsionForce_addTorsionTorsion(self, *args)


    def getTorsionTorsionParameters(self, *args):
        """
        getTorsionTorsionParameters(AmoebaTorsionTorsionForce self, int index)

        Get the force field parameters for a torsion-torsion term.
           Parameters:
            - index the index of the torsion-torsion for which to get parameters
            - particle1 the index of the first particle connected by the torsion-torsion
            - particle2 the index of the second particle connected by the torsion-torsion
            - particle3 the index of the third particle connected by the torsion-torsion
            - particle4 the index of the fourth particle connected by the torsion-torsion
            - particle5 the index of the fifth particle connected by the torsion-torsion
            - chiralCheckAtomIndex the index of the particle connected to particle3, but not particle2 or particle4 to be used in chirality check
            - gridIndex the grid index
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaTorsionTorsionForce_getTorsionTorsionParameters(self, *args)


    def setTorsionTorsionParameters(self, *args):
        """
        setTorsionTorsionParameters(AmoebaTorsionTorsionForce self, int index, int particle1, int particle2, int particle3, int particle4, int particle5, int chiralCheckAtomIndex, int gridIndex)

        Set the force field parameters for a torsion-torsion term.
           Parameters:
            - index the index of the torsion-torsion for which to set parameters
            - particle1 the index of the first particle connected by the torsion-torsion
            - particle2 the index of the second particle connected by the torsion-torsion
            - particle3 the index of the third particle connected by the torsion-torsion
            - particle4 the index of the fourth particle connected by the torsion-torsion
            - particle5 the index of the fifth particle connected by the torsion-torsion
            - chiralCheckAtomIndex the index of the particle connected to particle3, but not particle2 or particle4 to be used in chirality check
            - gridIndex the grid index
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaTorsionTorsionForce_setTorsionTorsionParameters(self, *args)


    def getTorsionTorsionGrid(self, *args):
        """
        getTorsionTorsionGrid(AmoebaTorsionTorsionForce self, int index) -> vectorddd

        Get the torsion-torsion grid at the specified index
           Parameters:
            - gridIndex the grid index
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaTorsionTorsionForce_getTorsionTorsionGrid(self, *args)


    def setTorsionTorsionGrid(self, *args):
        """
        setTorsionTorsionGrid(AmoebaTorsionTorsionForce self, int index, vectorddd grid)

        Set the torsion-torsion grid at the specified index
           Parameters:
            - index the index of the torsion-torsion for which to get parameters
            - grid either 3 or 6 values may be specified per grid point. If the derivatives are omitted, they are calculated automatically by fitting a 2D spline to the energies. grid[x][y][0] = x value grid[x][y][1] = y value grid[x][y][2] = energy grid[x][y][3] = dEdx value grid[x][y][4] = dEdy value grid[x][y][5] = dEd(xy) value
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaTorsionTorsionForce_setTorsionTorsionGrid(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(AmoebaTorsionTorsionForce self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaTorsionTorsionForce_usesPeriodicBoundaryConditions(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::AmoebaTorsionTorsionForce self) -> AmoebaTorsionTorsionForce
        __init__(OpenMM::AmoebaTorsionTorsionForce self, AmoebaTorsionTorsionForce other) -> AmoebaTorsionTorsionForce

        Create an AmoebaTorsionTorsionForce.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_AmoebaTorsionTorsionForce(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_AmoebaTorsionTorsionForce
    def __del__(self):
        """__del__(OpenMM::AmoebaTorsionTorsionForce self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

AmoebaTorsionTorsionForce_swigregister = _openmm.AmoebaTorsionTorsionForce_swigregister
AmoebaTorsionTorsionForce_swigregister(AmoebaTorsionTorsionForce)

class AmoebaBondForce(Force):
    """
    This class implements an interaction between pairs of particles that varies with the distance between them. The interaction is defined by a 4th order polynomial. Only the quadratic term is set per-bond. The coefficients of the higher order terms each have a single value that is set globally.

    To use it, create an AmoebaBondForce object then call addBond() once for each bond. After a bond has been added, you can modify its force field parameters by calling setBondParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext().
    """
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AmoebaBondForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AmoebaBondForce, name)
    __repr__ = _swig_repr

    def getNumBonds(self, *args):
        """
        getNumBonds(AmoebaBondForce self) -> int

        Get the number of bond stretch terms in the potential function
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaBondForce_getNumBonds(self, *args)


    def setAmoebaGlobalBondCubic(self, *args):
        """
        setAmoebaGlobalBondCubic(AmoebaBondForce self, double cubicK)

        Set the global cubic term
           Parameters:
            - cubicK the cubic force constant for the bond
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaBondForce_setAmoebaGlobalBondCubic(self, *args)


    def getAmoebaGlobalBondCubic(self, *args):
        """
        getAmoebaGlobalBondCubic(AmoebaBondForce self) -> double

        Get the global cubic term
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaBondForce_getAmoebaGlobalBondCubic(self, *args)


    def setAmoebaGlobalBondQuartic(self, *args):
        """
        setAmoebaGlobalBondQuartic(AmoebaBondForce self, double quarticK)

        Set the global quartic term
           Parameters:
            - quarticK the quartic force constant for the bond
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaBondForce_setAmoebaGlobalBondQuartic(self, *args)


    def getAmoebaGlobalBondQuartic(self, *args):
        """
        getAmoebaGlobalBondQuartic(AmoebaBondForce self) -> double

        Get the global quartic term
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaBondForce_getAmoebaGlobalBondQuartic(self, *args)


    def addBond(self, *args):
        """
        addBond(AmoebaBondForce self, int particle1, int particle2, double length, double quadraticK) -> int

        Add a bond term to the force field.
           Parameters:
            - particle1 the index of the first particle connected by the bond
            - particle2 the index of the second particle connected by the bond
            - length the equilibrium length of the bond, measured in nm
            - k the quadratic force constant for the bond
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaBondForce_addBond(self, *args)


    def getBondParameters(self, *args):
        """
        getBondParameters(AmoebaBondForce self, int index)

        Get the force field parameters for a bond term.
           Parameters:
            - index the index of the bond for which to get parameters
            - particle1 the index of the first particle connected by the bond
            - particle2 the index of the second particle connected by the bond
            - length the equilibrium length of the bond, measured in nm
            - quadratic k the quadratic force constant for the bond
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaBondForce_getBondParameters(self, *args)

        val[2]=unit.Quantity(val[2], unit.nanometer)
        val[3]=unit.Quantity(val[3], unit.kilojoule_per_mole/(unit.nanometer*unit.nanometer))


        return val


    def setBondParameters(self, *args):
        """
        setBondParameters(AmoebaBondForce self, int index, int particle1, int particle2, double length, double quadraticK)

        Set the force field parameters for a bond term.
           Parameters:
            - index the index of the bond for which to set parameters
            - particle1 the index of the first particle connected by the bond
            - particle2 the index of the second particle connected by the bond
            - length the equilibrium length of the bond, measured in nm
            - k the quadratic force constant for the bond
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaBondForce_setBondParameters(self, *args)


    def updateParametersInContext(self, *args):
        """
        updateParametersInContext(AmoebaBondForce self, Context context)

        Update the per-bond parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setBondParameters() to modify this object's parameters, then call updateParametersInContext() to copy them over to the Context.

        The only information this method updates is the values of per-bond parameters. The set of particles involved in a bond cannot be changed, nor can new bonds be added.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaBondForce_updateParametersInContext(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(AmoebaBondForce self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaBondForce_usesPeriodicBoundaryConditions(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::AmoebaBondForce self) -> AmoebaBondForce
        __init__(OpenMM::AmoebaBondForce self, AmoebaBondForce other) -> AmoebaBondForce

        Create an AmoebaBondForce.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_AmoebaBondForce(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_AmoebaBondForce
    def __del__(self):
        """__del__(OpenMM::AmoebaBondForce self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

AmoebaBondForce_swigregister = _openmm.AmoebaBondForce_swigregister
AmoebaBondForce_swigregister(AmoebaBondForce)

class LocalEnergyMinimizer(_object):
    """Given a Context, this class searches for a new set of particle positions that represent a local minimum of the potential energy. The search is performed with the L-BFGS algorithm. Distance constraints are enforced during minimization by adding a harmonic restraining force to the potential function. The strength of the restraining force is steadily increased until the minimum energy configuration satisfies all constraints to within the tolerance specified by the Context's Integrator."""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LocalEnergyMinimizer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LocalEnergyMinimizer, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def minimize(*args):
        """
        minimize(Context context, double tolerance=10, int maxIterations=0)

        Search for a new set of particle positions that represent a local potential energy minimum. On exit, the Context will have been updated with the new positions.
           Parameters:
            - context a Context specifying the System to minimize and the initial particle positions
            - tolerance this specifies how precisely the energy minimum must be located. Minimization will be halted once the root-mean-square value of all force components reaches this tolerance. The default value is 10.
            - maxIterations the maximum number of iterations to perform. If this is 0, minimation is continued until the results converge without regard to how many iterations it takes. The default value is 0.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.LocalEnergyMinimizer_minimize(*args)

    if _newclass:
        minimize = staticmethod(minimize)
    __swig_getmethods__["minimize"] = lambda x: minimize
    __swig_destroy__ = _openmm.delete_LocalEnergyMinimizer
    def __del__(self):
        """__del__(OpenMM::LocalEnergyMinimizer self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

LocalEnergyMinimizer_swigregister = _openmm.LocalEnergyMinimizer_swigregister
LocalEnergyMinimizer_swigregister(LocalEnergyMinimizer)

def LocalEnergyMinimizer_minimize(*args):
    """
    LocalEnergyMinimizer_minimize(Context context, double tolerance=10, int maxIterations=0)

    Search for a new set of particle positions that represent a local potential energy minimum. On exit, the Context will have been updated with the new positions.
       Parameters:
        - context a Context specifying the System to minimize and the initial particle positions
        - tolerance this specifies how precisely the energy minimum must be located. Minimization will be halted once the root-mean-square value of all force components reaches this tolerance. The default value is 10.
        - maxIterations the maximum number of iterations to perform. If this is 0, minimation is continued until the results converge without regard to how many iterations it takes. The default value is 0.
    """

    try: args=stripUnits(args)
    except UnboundLocalError: pass


    return _openmm.LocalEnergyMinimizer_minimize(*args)

class Context(_object):
    """
    A Context stores the complete state of a simulation. More specifically, it includes:

    <ul>
    <li>
    The current time 

    </li>
    <li>
    The position of each particle 

    </li>
    <li>
    The velocity of each particle 

    </li>
    <li>
    The values of configurable parameters defined by Force objects in the System 

    </li>
    </ul>


    You can retrieve a snapshot of the current state at any time by calling getState(). This allows you to record the state of the simulation at various points, either for analysis or for checkpointing. getState() can also be used to retrieve the current forces on each particle and the current energy of the System.
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Context, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Context, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _openmm.delete_Context
    def __del__(self):
        """__del__(OpenMM::Context self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass


    def getSystem(self, *args):
        """
        getSystem(Context self) -> System

        Get System being simulated in this context.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Context_getSystem(self, *args)


    def getIntegrator(self, *args):
        """
        getIntegrator(Context self) -> Integrator
        getIntegrator(Context self) -> Integrator

        Get Integrator being used to by this context.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Context_getIntegrator(self, *args)


    def getPlatform(self, *args):
        """
        getPlatform(Context self) -> Platform
        getPlatform(Context self) -> Platform

        Get the Platform being used for calculations.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Context_getPlatform(self, *args)


    def setTime(self, *args):
        """
        setTime(Context self, double time)

        Set the current time of the simulation (in picoseconds).
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Context_setTime(self, *args)


    def setPositions(self, *args):
        """
        setPositions(self, positions)

        Set the positions of all particles in the System (measured in nm). This method simply sets the positions without checking to see whether they satisfy distance constraints. If you want constraints to be enforced, call applyConstraints() after setting the positions.
           Parameters:
            - positions a vector whose length equals the number of particles in the System. The i'th element contains the position of the i'th particle.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Context_setPositions(self, *args)


    def setVelocities(self, *args):
        """
        setVelocities(self, velocities)

        Set the velocities of all particles in the System (measured in nm/picosecond).
           Parameters:
            - velocities a vector whose length equals the number of particles in the System. The i'th element contains the velocity of the i'th particle.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Context_setVelocities(self, *args)


    def setVelocitiesToTemperature(self, *args):
        """
        setVelocitiesToTemperature(Context self, double temperature, int randomSeed)

        Set the velocities of all particles in the System to random values chosen from a Boltzmann distribution at a given temperature.
           Parameters:
            - temperature the temperature for which to select the velocities (measured in Kelvin)
            - randomSeed the random number seed to use when selecting velocities
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Context_setVelocitiesToTemperature(self, *args)


    def getParameter(self, *args):
        """
        getParameter(Context self, std::string const & name) -> double

        Get the value of an adjustable parameter defined by a Force object in the System.
           Parameters:
            - name the name of the parameter to get
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Context_getParameter(self, *args)


    def setParameter(self, *args):
        """
        setParameter(Context self, std::string const & name, double value)

        Set the value of an adjustable parameter defined by a Force object in the System.
           Parameters:
            - name the name of the parameter to set
            - value the value of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Context_setParameter(self, *args)


    def setPeriodicBoxVectors(self, *args):
        """
        setPeriodicBoxVectors(Context self, Vec3 const & a, Vec3 const & b, Vec3 const & c)

        Set the vectors defining the axes of the periodic box (measured in nm). They will affect any Force that uses periodic boundary conditions.

        Triclinic boxes are supported, but the vectors must satisfy certain requirements. In particular, a must point in the x direction, b must point "mostly" in the y direction, and c must point "mostly" in the z direction. See the documentation for details.
           Parameters:
            - a the vector defining the first edge of the periodic box
            - b the vector defining the second edge of the periodic box
            - c the vector defining the third edge of the periodic box
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Context_setPeriodicBoxVectors(self, *args)


    def applyConstraints(self, *args):
        """
        applyConstraints(Context self, double tol)

        Update the positions of particles so that all distance constraints are satisfied. This also recomputes the locations of all virtual sites.
           Parameters:
            - tol the distance tolerance within which constraints must be satisfied.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Context_applyConstraints(self, *args)


    def applyVelocityConstraints(self, *args):
        """
        applyVelocityConstraints(Context self, double tol)

        Update the velocities of particles so the net velocity of each constrained distance is zero.
           Parameters:
            - tol the velocity tolerance within which constraints must be satisfied.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Context_applyVelocityConstraints(self, *args)


    def computeVirtualSites(self, *args):
        """
        computeVirtualSites(Context self)

        Recompute the locations of all virtual sites. There is rarely a reason to call this, since virtual sites are also updated by applyConstraints(). This is only for the rare situations when you want to enforce virtual sites but <i>not</i> constraints.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Context_computeVirtualSites(self, *args)


    def reinitialize(self, *args):
        """
        reinitialize(Context self)

        When a Context is created, it may cache information about the System being simulated and the Force objects contained in it. This means that, if the System or Forces are then modified, the Context might not see all of the changes. Call reinitialize() to force the Context to rebuild its internal representation of the System and pick up any changes that have been made.

        This is an expensive operation, so you should try to avoid calling it too frequently.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Context_reinitialize(self, *args)


    def getMolecules(self, *args):
        """
        getMolecules(Context self) -> vectorii

        Get a description of how the particles in the system are grouped into molecules. Two particles are in the same molecule if they are connected by constraints or bonds, where every Force object can define bonds in whatever way are appropriate to that force.

        Each element lists the indices of all particles in a single molecule. Every particle is guaranteed to belong to exactly one molecule.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Context_getMolecules(self, *args)


    def _getStateAsLists(self, getPositions, getVelocities, getForces, getEnergy, getParameters, enforcePeriodic, groups):
        """_getStateAsLists(Context self, int getPositions, int getVelocities, int getForces, int getEnergy, int getParameters, int enforcePeriodic, int groups) -> PyObject *"""
        return _openmm.Context__getStateAsLists(self, getPositions, getVelocities, getForces, getEnergy, getParameters, enforcePeriodic, groups)


    def getState(self,
                 getPositions=False,
                 getVelocities=False,
                 getForces=False,
                 getEnergy=False,
                 getParameters=False,
                 enforcePeriodicBox=False,
                 groups=-1):
        """
        getState(self,
                 getPositions = False,
                 getVelocities = False,
                 getForces = False,
                 getEnergy = False,
                 getParameters = False,
                 enforcePeriodicBox = False,
                 groups = -1)
              -> State

        Get a State object recording the current state information stored in this context.

        Parameters:
         - getPositions (bool=False) whether to store particle positions in the State
         - getVelocities (bool=False) whether to store particle velocities in the State
         - getForces (bool=False) whether to store the forces acting on particles in the State
         - getEnergy (bool=False) whether to store potential and kinetic energy in the State
         - getParameter (bool=False) whether to store context parameters in the State
         - enforcePeriodicBox (bool=False) if false, the position of each particle will be whatever position is stored in the Context, regardless of periodic boundary conditions.  If true, particle positions will be translated so the center of every molecule lies in the same periodic box.
         - groups (int=-1) a set of bit flags for which force groups to include when computing forces and energies.  Group i will be included if (groups&(1<<i)) != 0.  The default value includes all groups.
        """

        if getPositions: getP=1
        else: getP=0
        if getVelocities: getV=1
        else: getV=0
        if getForces: getF=1
        else: getF=0
        if getEnergy: getE=1
        else: getE=0
        if getParameters: getPa=1
        else: getPa=0
        if enforcePeriodicBox: enforcePeriodic=1
        else: enforcePeriodic=0

        (simTime, periodicBoxVectorsList, energy, coordList, velList,
         forceList, paramMap) = \
            self._getStateAsLists(getP, getV, getF, getE, getPa, enforcePeriodic, groups)

        state = State(simTime=simTime,
                      energy=energy,
                      coordList=coordList,
                      velList=velList,
                      forceList=forceList,
                      periodicBoxVectorsList=periodicBoxVectorsList,
                      paramMap=paramMap)
        return state

    def setState(self, state):
        """
        setState(Context self, State state)

        Copy information from a State object into this Context.  This restores the Context to
        approximately the same state it was in when the State was created.  If the State does not include
        a piece of information (e.g. positions or velocities), that aspect of the Context is
        left unchanged.

        Even when all possible information is included in the State, the effect of calling this method
        is still less complete than loadCheckpoint().  For example, it does not restore the internal
        states of random number generators.  On the other hand, it has the advantage of not being hardware
        specific.
        """
        self.setTime(state._simTime)
        self.setPeriodicBoxVectors(state._periodicBoxVectorsList[0], state._periodicBoxVectorsList[1], state._periodicBoxVectorsList[2])
        if state._coordList is not None:
             self.setPositions(state._coordList)
        if state._velList is not None:
             self.setVelocities(state._velList)
        if state._paramMap is not None:
             for param in state._paramMap:
                 self.setParameter(param, state._paramMap[param])


    def createCheckpoint(self):
        """
        createCheckpoint(Context self) -> std::string

        Create a checkpoint recording the current state of the Context.
        This should be treated as an opaque block of binary data.  See loadCheckpoint() for more details.

        Returns: a string containing the checkpoint data

        """
        return _openmm.Context_createCheckpoint(self)


    def loadCheckpoint(self, checkpoint):
        """
        loadCheckpoint(Context self, std::string checkpoint)

        Load a checkpoint that was written by createCheckpoint().

        A checkpoint contains not only publicly visible data such as the particle positions and
        velocities, but also internal data such as the states of random number generators.  Ideally,
        loading a checkpoint should restore the Context to an identical state to when it was written,
        such that continuing the simulation will produce an identical trajectory.  This is not strictly
        guaranteed to be true, however, and should not be relied on.  For most purposes, however, the
        internal state should be close enough to be reasonably considered equivalent.

        A checkpoint contains data that is highly specific to the Context from which it was created.
        It depends on the details of the System, the Platform being used, and the hardware and software
        of the computer it was created on.  If you try to load it on a computer with different hardware,
        or for a System that is different in any way, loading is likely to fail.  Checkpoints created
        with different versions of OpenMM are also often incompatible.  If a checkpoint cannot be loaded,
        that is signaled by throwing an exception.

        Parameters:
         - checkpoint (string) the checkpoint data to load

        """
        return _openmm.Context_loadCheckpoint(self, checkpoint)


    def __init__(self, *args):
        """
        __init__(OpenMM::Context self, System system, Integrator integrator) -> Context
        __init__(OpenMM::Context self, System system, Integrator integrator, Platform platform) -> Context
        __init__(OpenMM::Context self, System system, Integrator integrator, Platform platform, mapstringstring properties) -> Context
        __init__(OpenMM::Context self, Context other) -> Context

        Construct a new Context in which to run a simulation, explicitly specifying what Platform should be used to perform calculations and the values of platform-specific properties.
           Parameters:
            - system the System which will be simulated
            - integrator the Integrator which will be used to simulate the System
            - platform the Platform to use for calculations
            - properties a set of values for platform-specific properties. Keys are the property names.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_Context(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

        self._system = args[0]
        self._integrator = args[1]



Context_swigregister = _openmm.Context_swigregister
Context_swigregister(Context)

class XmlSerializer(_object):
    """XmlSerializer is used for serializing objects as XML, and for reconstructing them again."""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, XmlSerializer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, XmlSerializer, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def serializeSystem(object):
        """
        serializeSystem(System object) -> std::string

        This method exists only for backward compatibility. @deprecated Use serialize() instead.
        """
        return _openmm.XmlSerializer_serializeSystem(object)

    if _newclass:
        serializeSystem = staticmethod(serializeSystem)
    __swig_getmethods__["serializeSystem"] = lambda x: serializeSystem

    def deserializeSystem(inputString):
        """
        deserializeSystem(char const * inputString) -> System

        This method exists only for backward compatibility. @deprecated Use deserialize() instead.
        """
        return _openmm.XmlSerializer_deserializeSystem(inputString)

    if _newclass:
        deserializeSystem = staticmethod(deserializeSystem)
    __swig_getmethods__["deserializeSystem"] = lambda x: deserializeSystem

    def _serializeForce(object):
        """_serializeForce(Force object) -> std::string"""
        return _openmm.XmlSerializer__serializeForce(object)

    if _newclass:
        _serializeForce = staticmethod(_serializeForce)
    __swig_getmethods__["_serializeForce"] = lambda x: _serializeForce

    def _deserializeForce(inputString):
        """_deserializeForce(char const * inputString) -> Force"""
        return _openmm.XmlSerializer__deserializeForce(inputString)

    if _newclass:
        _deserializeForce = staticmethod(_deserializeForce)
    __swig_getmethods__["_deserializeForce"] = lambda x: _deserializeForce

    def _serializeIntegrator(object):
        """_serializeIntegrator(Integrator object) -> std::string"""
        return _openmm.XmlSerializer__serializeIntegrator(object)

    if _newclass:
        _serializeIntegrator = staticmethod(_serializeIntegrator)
    __swig_getmethods__["_serializeIntegrator"] = lambda x: _serializeIntegrator

    def _deserializeIntegrator(inputString):
        """_deserializeIntegrator(char const * inputString) -> Integrator"""
        return _openmm.XmlSerializer__deserializeIntegrator(inputString)

    if _newclass:
        _deserializeIntegrator = staticmethod(_deserializeIntegrator)
    __swig_getmethods__["_deserializeIntegrator"] = lambda x: _deserializeIntegrator

    def _serializeStateAsLists(pos, vel, forces, kineticEnergy, potentialEnergy, time, boxVectors, params, types):
        """_serializeStateAsLists(std::vector< Vec3,std::allocator< Vec3 > > const & pos, std::vector< Vec3,std::allocator< Vec3 > > const & vel, std::vector< Vec3,std::allocator< Vec3 > > const & forces, double kineticEnergy, double potentialEnergy, double time, std::vector< Vec3,std::allocator< Vec3 > > const & boxVectors, mapstringdouble params, int types) -> std::string"""
        return _openmm.XmlSerializer__serializeStateAsLists(pos, vel, forces, kineticEnergy, potentialEnergy, time, boxVectors, params, types)

    if _newclass:
        _serializeStateAsLists = staticmethod(_serializeStateAsLists)
    __swig_getmethods__["_serializeStateAsLists"] = lambda x: _serializeStateAsLists

    def _deserializeStringIntoLists(stateAsString):
        """_deserializeStringIntoLists(std::string const & stateAsString) -> PyObject *"""
        return _openmm.XmlSerializer__deserializeStringIntoLists(stateAsString)

    if _newclass:
        _deserializeStringIntoLists = staticmethod(_deserializeStringIntoLists)
    __swig_getmethods__["_deserializeStringIntoLists"] = lambda x: _deserializeStringIntoLists

    @staticmethod
    def _serializeState(pythonState):
      positions = []
      velocities = []
      forces = []
      kineticEnergy = 0.0
      potentialEnergy = 0.0
      params = {}
      types = 0
      try:
        positions = pythonState.getPositions().value_in_unit(unit.nanometers)
        types |= 1
      except:
        pass
      try:
        velocities = pythonState.getVelocities().value_in_unit(unit.nanometers/unit.picoseconds)
        types |= 2
      except: 
        pass
      try:
        forces = pythonState.getForces().value_in_unit(unit.kilojoules_per_mole/unit.nanometers)
        types |= 4
      except:
        pass
      try:
        kineticEnergy = pythonState.getKineticEnergy().value_in_unit(unit.kilojoules_per_mole)
        potentialEnergy = pythonState.getPotentialEnergy().value_in_unit(unit.kilojoules_per_mole)
        types |= 8
      except:
        pass
      try:
        params = pythonState.getParameters()
        types |= 16
      except:
        pass
      time = pythonState.getTime().value_in_unit(unit.picoseconds)
      boxVectors = pythonState.getPeriodicBoxVectors().value_in_unit(unit.nanometers)
      string = XmlSerializer._serializeStateAsLists(positions, velocities, forces, kineticEnergy, potentialEnergy, time, boxVectors, params, types)
      return string  

    @staticmethod
    def _deserializeState(pythonString):

      (simTime, periodicBoxVectorsList, energy, coordList, velList,
       forceList, paramMap) = XmlSerializer._deserializeStringIntoLists(pythonString)

      state = State(simTime=simTime,
                    energy=energy,
                    coordList=coordList,
                    velList=velList,
                    forceList=forceList,
                    periodicBoxVectorsList=periodicBoxVectorsList,
                    paramMap=paramMap)
      return state

    @staticmethod
    def serialize(object):
      """Serialize an object as XML."""
      if isinstance(object, System):
        return XmlSerializer.serializeSystem(object)
      elif isinstance(object, Force):
        return XmlSerializer._serializeForce(object)
      elif isinstance(object, Integrator):
        return XmlSerializer._serializeIntegrator(object)
      elif isinstance(object, State):
        return XmlSerializer._serializeState(object)
      raise ValueError("Unsupported object type")

    @staticmethod
    def deserialize(inputString):
      """Reconstruct an object that has been serialized as XML."""
      import re
      match = re.search("<([^?]\S*)", inputString)
      if match is None:
        raise ValueError("Invalid input string")
      type = match.groups()[0]
      if type == "System":
        return XmlSerializer.deserializeSystem(inputString)
      if type == "Force":
        return XmlSerializer._deserializeForce(inputString)
      if type == "Integrator":
        return XmlSerializer._deserializeIntegrator(inputString)
      if type == "State":
        return XmlSerializer._deserializeState(inputString)
      raise ValueError("Unsupported object type")

    __swig_destroy__ = _openmm.delete_XmlSerializer
    def __del__(self):
        """__del__(OpenMM::XmlSerializer self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

XmlSerializer_swigregister = _openmm.XmlSerializer_swigregister
XmlSerializer_swigregister(XmlSerializer)

def XmlSerializer_serializeSystem(object):
    """
    XmlSerializer_serializeSystem(System object) -> std::string

    This method exists only for backward compatibility. @deprecated Use serialize() instead.
    """
    return _openmm.XmlSerializer_serializeSystem(object)

def XmlSerializer_deserializeSystem(inputString):
    """
    XmlSerializer_deserializeSystem(char const * inputString) -> System

    This method exists only for backward compatibility. @deprecated Use deserialize() instead.
    """
    return _openmm.XmlSerializer_deserializeSystem(inputString)

def XmlSerializer__serializeForce(object):
    """XmlSerializer__serializeForce(Force object) -> std::string"""
    return _openmm.XmlSerializer__serializeForce(object)

def XmlSerializer__deserializeForce(inputString):
    """XmlSerializer__deserializeForce(char const * inputString) -> Force"""
    return _openmm.XmlSerializer__deserializeForce(inputString)

def XmlSerializer__serializeIntegrator(object):
    """XmlSerializer__serializeIntegrator(Integrator object) -> std::string"""
    return _openmm.XmlSerializer__serializeIntegrator(object)

def XmlSerializer__deserializeIntegrator(inputString):
    """XmlSerializer__deserializeIntegrator(char const * inputString) -> Integrator"""
    return _openmm.XmlSerializer__deserializeIntegrator(inputString)

def XmlSerializer__serializeStateAsLists(pos, vel, forces, kineticEnergy, potentialEnergy, time, boxVectors, params, types):
    """XmlSerializer__serializeStateAsLists(std::vector< Vec3,std::allocator< Vec3 > > const & pos, std::vector< Vec3,std::allocator< Vec3 > > const & vel, std::vector< Vec3,std::allocator< Vec3 > > const & forces, double kineticEnergy, double potentialEnergy, double time, std::vector< Vec3,std::allocator< Vec3 > > const & boxVectors, mapstringdouble params, int types) -> std::string"""
    return _openmm.XmlSerializer__serializeStateAsLists(pos, vel, forces, kineticEnergy, potentialEnergy, time, boxVectors, params, types)

def XmlSerializer__deserializeStringIntoLists(stateAsString):
    """XmlSerializer__deserializeStringIntoLists(std::string const & stateAsString) -> PyObject *"""
    return _openmm.XmlSerializer__deserializeStringIntoLists(stateAsString)

class VariableVerletIntegrator(Integrator):
    """
    This is an error contolled, variable time step Integrator that simulates a System using the leap-frog Verlet algorithm. It compares the result of the Verlet integrator to that of an explicit Euler integrator, takes the difference between the two as a measure of the integration error in each time step, and continuously adjusts the step size to keep the error below a specified tolerance. This both improves the stability of the integrator and allows it to take larger steps on average, while still maintaining comparable accuracy to a fixed step size integrator.

    It is best not to think of the error tolerance as having any absolute meaning. It is just an adjustable parameter that affects the step size and integration accuracy. You should try different values to find the largest one that produces a trajectory sufficiently accurate for your purposes. 0.001 is often a good starting point.

    Unlike a fixed step size Verlet integrator, variable step size Verlet is not symplectic. This means that at a given accuracy level, energy is not as precisely conserved over long time periods. This makes it most appropriate for constant temperate simulations. In constant energy simulations where precise energy conservation over long time periods is important, a fixed step size Verlet integrator may be more appropriate.
    """
    __swig_setmethods__ = {}
    for _s in [Integrator]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VariableVerletIntegrator, name, value)
    __swig_getmethods__ = {}
    for _s in [Integrator]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, VariableVerletIntegrator, name)
    __repr__ = _swig_repr

    def getErrorTolerance(self, *args):
        """
        getErrorTolerance(VariableVerletIntegrator self) -> double

        Get the error tolerance.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.VariableVerletIntegrator_getErrorTolerance(self, *args)


    def setErrorTolerance(self, *args):
        """
        setErrorTolerance(VariableVerletIntegrator self, double tol)

        Set the error tolerance.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.VariableVerletIntegrator_setErrorTolerance(self, *args)


    def step(self, *args):
        """
        step(VariableVerletIntegrator self, int steps)

        Advance a simulation through time by taking a series of time steps.
           Parameters:
            - steps the number of time steps to take
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.VariableVerletIntegrator_step(self, *args)


    def stepTo(self, *args):
        """
        stepTo(VariableVerletIntegrator self, double time)

        Advance a simulation through time by taking a series of steps until a specified time is reached. When this method returns, the simulation time will exactly equal the time which was specified. If you call this method and specify a time that is earlier than the current time, it will return without doing anything.
           Parameters:
            - time the time to which the simulation should be advanced
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.VariableVerletIntegrator_stepTo(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::VariableVerletIntegrator self, double errorTol) -> VariableVerletIntegrator
        __init__(OpenMM::VariableVerletIntegrator self, VariableVerletIntegrator other) -> VariableVerletIntegrator

        Create a VariableVerletIntegrator.
           Parameters:
            - errorTol the error tolerance
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_VariableVerletIntegrator(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_VariableVerletIntegrator
    def __del__(self):
        """__del__(OpenMM::VariableVerletIntegrator self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

VariableVerletIntegrator_swigregister = _openmm.VariableVerletIntegrator_swigregister
VariableVerletIntegrator_swigregister(VariableVerletIntegrator)

class AmoebaPiTorsionForce(Force):
    """
    This class implements the Amoeba pi-torsion interaction.

    To use it, create an AmoebaPiTorsionForce object then call addPiTorsion() once for each torsion. After a torsion has been added, you can modify its force field parameters by calling setPiTorsionParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext().
    """
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AmoebaPiTorsionForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AmoebaPiTorsionForce, name)
    __repr__ = _swig_repr

    def getNumPiTorsions(self, *args):
        """
        getNumPiTorsions(AmoebaPiTorsionForce self) -> int

        Get the number of pi torsion terms in the potential function
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaPiTorsionForce_getNumPiTorsions(self, *args)


    def addPiTorsion(self, *args):
        """
        addPiTorsion(AmoebaPiTorsionForce self, int particle1, int particle2, int particle3, int particle4, int particle5, int particle6, double k) -> int

        Add a torsion term to the force field.
           Parameters:
            - particle1 the index of the first particle connected by the torsion
            - particle2 the index of the second particle connected by the torsion
            - particle3 the index of the third particle connected by the torsion
            - particle4 the index of the fourth particle connected by the torsion
            - particle5 the index of the fifth particle connected by the torsion
            - particle6 the index of the sixth particle connected by the torsion
            - k the force constant for the torsion
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaPiTorsionForce_addPiTorsion(self, *args)


    def getPiTorsionParameters(self, *args):
        """
        getPiTorsionParameters(AmoebaPiTorsionForce self, int index)

        Get the force field parameters for a torsion term.
           Parameters:
            - index the index of the torsion for which to get parameters
            - particle1 the index of the first particle connected by the torsion
            - particle2 the index of the second particle connected by the torsion
            - particle3 the index of the third particle connected by the torsion
            - particle4 the index of the fourth particle connected by the torsion
            - particle5 the index of the fifth particle connected by the torsion
            - particle6 the index of the sixth particle connected by the torsion
            - k the force constant for the torsion
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaPiTorsionForce_getPiTorsionParameters(self, *args)

        val[6]=unit.Quantity(val[6], unit.kilojoule_per_mole)


        return val


    def setPiTorsionParameters(self, *args):
        """
        setPiTorsionParameters(AmoebaPiTorsionForce self, int index, int particle1, int particle2, int particle3, int particle4, int particle5, int particle6, double k)

        Set the force field parameters for a pi torsion term.
           Parameters:
            - index the index of the torsion for which to set parameters
            - particle1 the index of the first particle connected by the torsion
            - particle2 the index of the second particle connected by the torsion
            - particle3 the index of the third particle connected by the torsion
            - particle4 the index of the fourth particle connected by the torsion
            - particle5 the index of the fifth particle connected by the torsion
            - particle6 the index of the sixth particle connected by the torsion
            - k the force constant for the torsion
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaPiTorsionForce_setPiTorsionParameters(self, *args)


    def updateParametersInContext(self, *args):
        """
        updateParametersInContext(AmoebaPiTorsionForce self, Context context)

        Update the per-torsion parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setPiTorsionParameters() to modify this object's parameters, then call updateParametersInContext() to copy them over to the Context.

        The only information this method updates is the values of per-torsion parameters. The set of particles involved in a torsion cannot be changed, nor can new torsions be added.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaPiTorsionForce_updateParametersInContext(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(AmoebaPiTorsionForce self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaPiTorsionForce_usesPeriodicBoundaryConditions(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::AmoebaPiTorsionForce self) -> AmoebaPiTorsionForce
        __init__(OpenMM::AmoebaPiTorsionForce self, AmoebaPiTorsionForce other) -> AmoebaPiTorsionForce

        Create an AmoebaPiTorsionForce.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_AmoebaPiTorsionForce(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_AmoebaPiTorsionForce
    def __del__(self):
        """__del__(OpenMM::AmoebaPiTorsionForce self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

AmoebaPiTorsionForce_swigregister = _openmm.AmoebaPiTorsionForce_swigregister
AmoebaPiTorsionForce_swigregister(AmoebaPiTorsionForce)

class CustomCompoundBondForce(Force):
    """
    This class supports a wide variety of bonded interactions. It defines a "bond" as a single energy term that depends on the positions of a fixed set of particles. The number of particles involved in a bond, and how the energy depends on their positions, is configurable. It may depend on the positions of individual particles, the distances between pairs of particles, the angles formed by sets of three particles, and the dihedral angles formed by sets of four particles.

    We refer to the particles in a bond as p1, p2, p3, etc. For each bond, CustomCompoundBondForce evaluates a user supplied algebraic expression to determine the interaction energy. The expression may depend on the following variables and functions:

    <ul>
    <li>
    x1, y1, z1, x2, y2, z2, etc.: The x, y, and z coordinates of the particle positions. For example, x1 is the x coordinate of particle p1, and y3 is the y coordinate of particle p3. 

    </li>
    <li>
    distance(p1, p2): the distance between particles p1 and p2 (where "p1" and "p2" may be replaced by the names of whichever particles you want to calculate the distance between). 

    </li>
    <li>
    angle(p1, p2, p3): the angle formed by the three specified particles. 

    </li>
    <li>
    dihedral(p1, p2, p3, p4): the dihedral angle formed by the four specified particles. 

    </li>
    </ul>


    The expression also may involve tabulated functions, and may depend on arbitrary global and per-bond parameters.

    To use this class, create a CustomCompoundBondForce object, passing an algebraic expression to the constructor that defines the interaction energy of each bond. Then call addPerBondParameter() to define per-bond parameters and addGlobalParameter() to define global parameters. The values of per-bond parameters are specified as part of the system definition, while values of global parameters may be modified during a simulation by calling Context::setParameter().

    Next, call addBond() to define bonds and specify their parameter values. After a bond has been added, you can modify its parameters by calling setBondParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext().

    As an example, the following code creates a CustomCompoundBondForce that implements a Urey-Bradley potential. This is an interaction between three particles that depends on the angle formed by p1-p2-p3, and on the distance between p1 and p3.

    <tt>CustomCompoundBondForce* force = new CustomCompoundBondForce(3, "0.5*(kangle*(angle(p1,p2,p3)-theta0)^2+kbond*(distance(p1,p3)-r0)^2)");</tt>

    This force depends on four parameters: kangle, kbond, theta0, and r0. The following code defines these as per-bond parameters:

    <tt><pre>
    force->addPerBondParameter("kangle");
    force->addPerBondParameter("kbond");
    force->addPerBondParameter("theta0");
    force->addPerBondParameter("r0");
    </pre></tt>

    Expressions may involve the operators + (add), - (subtract), * (multiply), / (divide), and ^ (power), and the following functions: sqrt, exp, log, sin, cos, sec, csc, tan, cot, asin, acos, atan, sinh, cosh, tanh, erf, erfc, min, max, abs, floor, ceil, step, delta, select. All trigonometric functions are defined in radians, and log is the natural logarithm. step(x) = 0 if x is less than 0, 1 otherwise. delta(x) = 1 if x is 0, 0 otherwise. select(x,y,z) = z if x = 0, y otherwise.

    In addition, you can call addTabulatedFunction() to define a new function based on tabulated values. You specify the function by creating a TabulatedFunction object. That function can then appear in the expression.
    """
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomCompoundBondForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomCompoundBondForce, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _openmm.delete_CustomCompoundBondForce
    def __del__(self):
        """__del__(OpenMM::CustomCompoundBondForce self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass


    def getNumParticlesPerBond(self, *args):
        """
        getNumParticlesPerBond(CustomCompoundBondForce self) -> int

        Get the number of particles used to define each bond.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomCompoundBondForce_getNumParticlesPerBond(self, *args)


    def getNumBonds(self, *args):
        """
        getNumBonds(CustomCompoundBondForce self) -> int

        Get the number of bonds for which force field parameters have been defined.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomCompoundBondForce_getNumBonds(self, *args)


    def getNumPerBondParameters(self, *args):
        """
        getNumPerBondParameters(CustomCompoundBondForce self) -> int

        Get the number of per-bond parameters that the interaction depends on.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomCompoundBondForce_getNumPerBondParameters(self, *args)


    def getNumGlobalParameters(self, *args):
        """
        getNumGlobalParameters(CustomCompoundBondForce self) -> int

        Get the number of global parameters that the interaction depends on.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomCompoundBondForce_getNumGlobalParameters(self, *args)


    def getNumTabulatedFunctions(self, *args):
        """
        getNumTabulatedFunctions(CustomCompoundBondForce self) -> int

        Get the number of tabulated functions that have been defined.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomCompoundBondForce_getNumTabulatedFunctions(self, *args)


    def getNumFunctions(self, *args):
        """
        getNumFunctions(CustomCompoundBondForce self) -> int

        Get the number of tabulated functions that have been defined.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomCompoundBondForce_getNumFunctions(self, *args)


    def getEnergyFunction(self, *args):
        """
        getEnergyFunction(CustomCompoundBondForce self) -> std::string const &

        Get the algebraic expression that gives the interaction energy of each bond
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomCompoundBondForce_getEnergyFunction(self, *args)


    def setEnergyFunction(self, *args):
        """
        setEnergyFunction(CustomCompoundBondForce self, std::string const & energy)

        Set the algebraic expression that gives the interaction energy of each bond
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomCompoundBondForce_setEnergyFunction(self, *args)


    def addPerBondParameter(self, *args):
        """
        addPerBondParameter(CustomCompoundBondForce self, std::string const & name) -> int

        Add a new per-bond parameter that the interaction may depend on.
           Parameters:
            - name the name of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomCompoundBondForce_addPerBondParameter(self, *args)


    def getPerBondParameterName(self, *args):
        """
        getPerBondParameterName(CustomCompoundBondForce self, int index) -> std::string const &

        Get the name of a per-bond parameter.
           Parameters:
            - index the index of the parameter for which to get the name
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomCompoundBondForce_getPerBondParameterName(self, *args)


    def setPerBondParameterName(self, *args):
        """
        setPerBondParameterName(CustomCompoundBondForce self, int index, std::string const & name)

        Set the name of a per-bond parameter.
           Parameters:
            - index the index of the parameter for which to set the name
            - name the name of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomCompoundBondForce_setPerBondParameterName(self, *args)


    def addGlobalParameter(self, *args):
        """
        addGlobalParameter(CustomCompoundBondForce self, std::string const & name, double defaultValue) -> int

        Add a new global parameter that the interaction may depend on.
           Parameters:
            - name the name of the parameter
            - defaultValue the default value of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomCompoundBondForce_addGlobalParameter(self, *args)


    def getGlobalParameterName(self, *args):
        """
        getGlobalParameterName(CustomCompoundBondForce self, int index) -> std::string const &

        Get the name of a global parameter.
           Parameters:
            - index the index of the parameter for which to get the name
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomCompoundBondForce_getGlobalParameterName(self, *args)


    def setGlobalParameterName(self, *args):
        """
        setGlobalParameterName(CustomCompoundBondForce self, int index, std::string const & name)

        Set the name of a global parameter.
           Parameters:
            - index the index of the parameter for which to set the name
            - name the name of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomCompoundBondForce_setGlobalParameterName(self, *args)


    def getGlobalParameterDefaultValue(self, *args):
        """
        getGlobalParameterDefaultValue(CustomCompoundBondForce self, int index) -> double

        Get the default value of a global parameter.
           Parameters:
            - index the index of the parameter for which to get the default value
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomCompoundBondForce_getGlobalParameterDefaultValue(self, *args)


    def setGlobalParameterDefaultValue(self, *args):
        """
        setGlobalParameterDefaultValue(CustomCompoundBondForce self, int index, double defaultValue)

        Set the default value of a global parameter.
           Parameters:
            - index the index of the parameter for which to set the default value
            - name the default value of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomCompoundBondForce_setGlobalParameterDefaultValue(self, *args)


    def addBond(self, *args):
        """
        addBond(CustomCompoundBondForce self, vectori particles, vectord parameters) -> int

        Add a bond to the force
           Parameters:
            - particles the indices of the particles the bond depends on
            - parameters the list of per-bond parameter values for the new bond
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomCompoundBondForce_addBond(self, *args)


    def getBondParameters(self, *args):
        """
        getBondParameters(CustomCompoundBondForce self, int index)

        Get the properties of a bond.
           Parameters:
            - index the index of the bond to get
            - particles the indices of the particles in the bond
            - parameters the list of per-bond parameter values for the bond
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomCompoundBondForce_getBondParameters(self, *args)


    def setBondParameters(self, *args):
        """
        setBondParameters(CustomCompoundBondForce self, int index, vectori particles, vectord parameters)

        Set the properties of a bond.
           Parameters:
            - index the index of the bond group to set
            - particles the indices of the particles in the bond
            - parameters the list of per-bond parameter values for the bond
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomCompoundBondForce_setBondParameters(self, *args)


    def addTabulatedFunction(self, *args):
        """
        addTabulatedFunction(CustomCompoundBondForce self, std::string const & name, TabulatedFunction function) -> int

        Add a tabulated function that may appear in the energy expression.
           Parameters:
            - name the name of the function as it appears in expressions
            - function a TabulatedFunction object defining the function. The TabulatedFunction should have been created on the heap with the "new" operator. The Force takes over ownership of it, and deletes it when the Force itself is deleted.
        """

        if not args[1].thisown:
           s = "the %s object does not own its corresponding OpenMM object" \
              % args[1].__class__.__name__
           raise Exception(s)


        val = _openmm.CustomCompoundBondForce_addTabulatedFunction(self, *args)

        args[1].thisown=0


        return val


    def getTabulatedFunction(self, *args):
        """
        getTabulatedFunction(CustomCompoundBondForce self, int index) -> TabulatedFunction
        getTabulatedFunction(CustomCompoundBondForce self, int index) -> TabulatedFunction

        Get a reference to a tabulated function that may appear in the energy expression.
           Parameters:
            - index the index of the function to get
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomCompoundBondForce_getTabulatedFunction(self, *args)


    def getTabulatedFunctionName(self, *args):
        """
        getTabulatedFunctionName(CustomCompoundBondForce self, int index) -> std::string const &

        Get the name of a tabulated function that may appear in the energy expression.
           Parameters:
            - index the index of the function to get
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomCompoundBondForce_getTabulatedFunctionName(self, *args)


    def addFunction(self, *args):
        """
        addFunction(CustomCompoundBondForce self, std::string const & name, vectord values, double min, double max) -> int

        Add a tabulated function that may appear in the energy expression.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomCompoundBondForce_addFunction(self, *args)


    def getFunctionParameters(self, *args):
        """
        getFunctionParameters(CustomCompoundBondForce self, int index)

        Get the parameters for a tabulated function that may appear in the energy expression.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomCompoundBondForce_getFunctionParameters(self, *args)


    def setFunctionParameters(self, *args):
        """
        setFunctionParameters(CustomCompoundBondForce self, int index, std::string const & name, vectord values, double min, double max)

        Set the parameters for a tabulated function that may appear in the energy expression.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomCompoundBondForce_setFunctionParameters(self, *args)


    def updateParametersInContext(self, *args):
        """
        updateParametersInContext(CustomCompoundBondForce self, Context context)

        Update the per-bond parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setBondParameters() to modify this object's parameters, then call updateParametersInContext() to copy them over to the Context.

        This method has several limitations. The only information it updates is the values of per-bond parameters. All other aspects of the Force (such as the energy function) are unaffected and can only be changed by reinitializing the Context. The set of particles involved in a bond cannot be changed, nor can new bonds be added.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomCompoundBondForce_updateParametersInContext(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(CustomCompoundBondForce self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomCompoundBondForce_usesPeriodicBoundaryConditions(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::CustomCompoundBondForce self, int numParticles, std::string const & energy) -> CustomCompoundBondForce
        __init__(OpenMM::CustomCompoundBondForce self, CustomCompoundBondForce other) -> CustomCompoundBondForce

        Create a CustomCompoundBondForce.
           Parameters:
            - numParticles the number of particles used to define each bond
            - energy an algebraic expression giving the interaction energy of each bond as a function of particle positions, inter-particle distances, angles, and dihedrals, and any global and per-bond parameters
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_CustomCompoundBondForce(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
CustomCompoundBondForce_swigregister = _openmm.CustomCompoundBondForce_swigregister
CustomCompoundBondForce_swigregister(CustomCompoundBondForce)

class Continuous3DFunction(TabulatedFunction):
    """This is a TabulatedFunction that computes a continuous three dimensional function."""
    __swig_setmethods__ = {}
    for _s in [TabulatedFunction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Continuous3DFunction, name, value)
    __swig_getmethods__ = {}
    for _s in [TabulatedFunction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Continuous3DFunction, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OpenMM::Continuous3DFunction self, int xsize, int ysize, int zsize, vectord values, double xmin, double xmax, double ymin, double ymax, double zmin, double zmax) -> Continuous3DFunction

        This is a TabulatedFunction that computes a continuous three dimensional function.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_Continuous3DFunction(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def getFunctionParameters(self, *args):
        """getFunctionParameters(Continuous3DFunction self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Continuous3DFunction_getFunctionParameters(self, *args)


    def setFunctionParameters(self, *args):
        """setFunctionParameters(Continuous3DFunction self, int xsize, int ysize, int zsize, vectord values, double xmin, double xmax, double ymin, double ymax, double zmin, double zmax)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Continuous3DFunction_setFunctionParameters(self, *args)


    def Copy(self, *args):
        """Copy(Continuous3DFunction self) -> Continuous3DFunction"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Continuous3DFunction_Copy(self, *args)

    __swig_destroy__ = _openmm.delete_Continuous3DFunction
    def __del__(self):
        """__del__(OpenMM::Continuous3DFunction self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

Continuous3DFunction_swigregister = _openmm.Continuous3DFunction_swigregister
Continuous3DFunction_swigregister(Continuous3DFunction)

class Discrete3DFunction(TabulatedFunction):
    """This is a TabulatedFunction that computes a discrete three dimensional function f(x,y,z). To evaluate it, x, y, and z are each rounded to the nearest integer and the table element with those indices is returned. If any index is outside the range [0, size), the result is undefined."""
    __swig_setmethods__ = {}
    for _s in [TabulatedFunction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Discrete3DFunction, name, value)
    __swig_getmethods__ = {}
    for _s in [TabulatedFunction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Discrete3DFunction, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OpenMM::Discrete3DFunction self, int xsize, int ysize, int zsize, vectord values) -> Discrete3DFunction

        This is a TabulatedFunction that computes a discrete three dimensional function f(x,y,z). To evaluate it, x, y, and z are each rounded to the nearest integer and the table element with those indices is returned. If any index is outside the range [0, size), the result is undefined.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_Discrete3DFunction(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def getFunctionParameters(self, *args):
        """getFunctionParameters(Discrete3DFunction self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Discrete3DFunction_getFunctionParameters(self, *args)


    def setFunctionParameters(self, *args):
        """setFunctionParameters(Discrete3DFunction self, int xsize, int ysize, int zsize, vectord values)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Discrete3DFunction_setFunctionParameters(self, *args)


    def Copy(self, *args):
        """Copy(Discrete3DFunction self) -> Discrete3DFunction"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Discrete3DFunction_Copy(self, *args)

    __swig_destroy__ = _openmm.delete_Discrete3DFunction
    def __del__(self):
        """__del__(OpenMM::Discrete3DFunction self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

Discrete3DFunction_swigregister = _openmm.Discrete3DFunction_swigregister
Discrete3DFunction_swigregister(Discrete3DFunction)

class CustomExternalForce(Force):
    """
    This class implements an "external" force on particles. The force may be applied to any subset of the particles in the System. The force on each particle is specified by an arbitrary algebraic expression, which may depend on the current position of the particle as well as on arbitrary global and per-particle parameters.

    To use this class, create a CustomExternalForce object, passing an algebraic expression to the constructor that defines the potential energy of each affected particle. The expression may depend on the particle's x, y, and z coordinates, as well as on any parameters you choose. Then call addPerParticleParameter() to define per-particle parameters, and addGlobalParameter() to define global parameters. The values of per-particle parameters are specified as part of the system definition, while values of global parameters may be modified during a simulation by calling Context::setParameter(). Finally, call addParticle() once for each particle that should be affected by the force. After a particle has been added, you can modify its parameters by calling setParticleParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext().

    As an example, the following code creates a CustomExternalForce that attracts each particle to a target position (x0, y0, z0) via a harmonic potential:

    <tt>CustomExternalForce* force = new CustomExternalForce("k*((x-x0)^2+(y-y0)^2+(z-z0)^2)");</tt>

    This force depends on four parameters: the spring constant k and equilibrium coordinates x0, y0, and z0. The following code defines these parameters:

    <tt><pre>
    force->addGlobalParameter("k", 100.0);
    force->addPerParticleParameter("x0");
    force->addPerParticleParameter("y0");
    force->addPerParticleParameter("z0");
    </pre></tt>

    Expressions may involve the operators + (add), - (subtract), * (multiply), / (divide), and ^ (power), and the following functions: sqrt, exp, log, sin, cos, sec, csc, tan, cot, asin, acos, atan, sinh, cosh, tanh, erf, erfc, min, max, abs, floor, ceil, step, delta, select. All trigonometric functions are defined in radians, and log is the natural logarithm. step(x) = 0 if x is less than 0, 1 otherwise. delta(x) = 1 if x is 0, 0 otherwise. select(x,y,z) = z if x = 0, y otherwise.
    """
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomExternalForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomExternalForce, name)
    __repr__ = _swig_repr

    def getNumParticles(self, *args):
        """
        getNumParticles(CustomExternalForce self) -> int

        Get the number of particles for which force field parameters have been defined.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomExternalForce_getNumParticles(self, *args)


    def getNumPerParticleParameters(self, *args):
        """
        getNumPerParticleParameters(CustomExternalForce self) -> int

        Get the number of per-particle parameters that the force depends on
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomExternalForce_getNumPerParticleParameters(self, *args)


    def getNumGlobalParameters(self, *args):
        """
        getNumGlobalParameters(CustomExternalForce self) -> int

        Get the number of global parameters that the force depends on.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomExternalForce_getNumGlobalParameters(self, *args)


    def getEnergyFunction(self, *args):
        """
        getEnergyFunction(CustomExternalForce self) -> std::string const &

        Get the algebraic expression that gives the potential energy of each particle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomExternalForce_getEnergyFunction(self, *args)


    def setEnergyFunction(self, *args):
        """
        setEnergyFunction(CustomExternalForce self, std::string const & energy)

        Set the algebraic expression that gives the potential energy of each particle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomExternalForce_setEnergyFunction(self, *args)


    def addPerParticleParameter(self, *args):
        """
        addPerParticleParameter(CustomExternalForce self, std::string const & name) -> int

        Add a new per-particle parameter that the force may depend on.
           Parameters:
            - name the name of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomExternalForce_addPerParticleParameter(self, *args)


    def getPerParticleParameterName(self, *args):
        """
        getPerParticleParameterName(CustomExternalForce self, int index) -> std::string const &

        Get the name of a per-particle parameter.
           Parameters:
            - index the index of the parameter for which to get the name
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomExternalForce_getPerParticleParameterName(self, *args)


    def setPerParticleParameterName(self, *args):
        """
        setPerParticleParameterName(CustomExternalForce self, int index, std::string const & name)

        Set the name of a per-particle parameter.
           Parameters:
            - index the index of the parameter for which to set the name
            - name the name of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomExternalForce_setPerParticleParameterName(self, *args)


    def addGlobalParameter(self, *args):
        """
        addGlobalParameter(CustomExternalForce self, std::string const & name, double defaultValue) -> int

        Add a new global parameter that the force may depend on.
           Parameters:
            - name the name of the parameter
            - defaultValue the default value of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomExternalForce_addGlobalParameter(self, *args)


    def getGlobalParameterName(self, *args):
        """
        getGlobalParameterName(CustomExternalForce self, int index) -> std::string const &

        Get the name of a global parameter.
           Parameters:
            - index the index of the parameter for which to get the name
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomExternalForce_getGlobalParameterName(self, *args)


    def setGlobalParameterName(self, *args):
        """
        setGlobalParameterName(CustomExternalForce self, int index, std::string const & name)

        Set the name of a global parameter.
           Parameters:
            - index the index of the parameter for which to set the name
            - name the name of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomExternalForce_setGlobalParameterName(self, *args)


    def getGlobalParameterDefaultValue(self, *args):
        """
        getGlobalParameterDefaultValue(CustomExternalForce self, int index) -> double

        Get the default value of a global parameter.
           Parameters:
            - index the index of the parameter for which to get the default value
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomExternalForce_getGlobalParameterDefaultValue(self, *args)


    def setGlobalParameterDefaultValue(self, *args):
        """
        setGlobalParameterDefaultValue(CustomExternalForce self, int index, double defaultValue)

        Set the default value of a global parameter.
           Parameters:
            - index the index of the parameter for which to set the default value
            - name the default value of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomExternalForce_setGlobalParameterDefaultValue(self, *args)


    def addParticle(self, *args):
        """
        addParticle(CustomExternalForce self, int particle, vectord parameters) -> int

        Add a particle term to the force field.
           Parameters:
            - particle the index of the particle this term is applied to
            - parameters the list of parameters for the new force term
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomExternalForce_addParticle(self, *args)


    def getParticleParameters(self, *args):
        """
        getParticleParameters(CustomExternalForce self, int index)

        Get the force field parameters for a force field term.
           Parameters:
            - index the index of the particle term for which to get parameters
            - particle the index of the particle this term is applied to
            - parameters the list of parameters for the force field term
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomExternalForce_getParticleParameters(self, *args)


    def setParticleParameters(self, *args):
        """
        setParticleParameters(CustomExternalForce self, int index, int particle, vectord parameters)

        Set the force field parameters for a force field term.
           Parameters:
            - index the index of the particle term for which to set parameters
            - particle the index of the particle this term is applied to
            - parameters the list of parameters for the force field term
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomExternalForce_setParticleParameters(self, *args)


    def updateParametersInContext(self, *args):
        """
        updateParametersInContext(CustomExternalForce self, Context context)

        Update the per-particle parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setParticleParameters() to modify this object's parameters, then call updateParametersInContext() to copy them over to the Context.

        This method has several limitations. The only information it updates is the values of per-particle parameters. All other aspects of the Force (such as the energy function) are unaffected and can only be changed by reinitializing the Context. Also, this method cannot be used to add new particles, only to change the parameters of existing ones.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomExternalForce_updateParametersInContext(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(CustomExternalForce self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomExternalForce_usesPeriodicBoundaryConditions(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::CustomExternalForce self, std::string const & energy) -> CustomExternalForce
        __init__(OpenMM::CustomExternalForce self, CustomExternalForce other) -> CustomExternalForce

        Create a CustomExternalForce.
           Parameters:
            - energy an algebraic expression giving the potential energy of each particle as a function of its x, y, and z coordinates
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_CustomExternalForce(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_CustomExternalForce
    def __del__(self):
        """__del__(OpenMM::CustomExternalForce self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

CustomExternalForce_swigregister = _openmm.CustomExternalForce_swigregister
CustomExternalForce_swigregister(CustomExternalForce)

class DrudeForce(Force):
    """
    This class implements forces that are specific to Drude oscillators. There are two distinct forces it applies: an anisotropic harmonic force connecting each Drude particle to its parent particle; and a screened Coulomb interaction between specific pairs of dipoles. The latter is typically used between closely bonded particles whose Coulomb interaction would otherwise be fully excluded.

    To use this class, create a DrudeForce object, then call addParticle() once for each Drude particle in the System to define its parameters. After a particle has been added, you can modify its force field parameters by calling setParticleParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext(). Likewise, call addScreenedPair() for each pair of dipoles (each dipole consisting of a Drude particle and its parent) that should be computed.
    """
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DrudeForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DrudeForce, name)
    __repr__ = _swig_repr

    def getNumParticles(self, *args):
        """
        getNumParticles(DrudeForce self) -> int

        Get the number of particles for which force field parameters have been defined.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.DrudeForce_getNumParticles(self, *args)


    def getNumScreenedPairs(self, *args):
        """
        getNumScreenedPairs(DrudeForce self) -> int

        Get the number of special interactions that should be calculated differently from other interactions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.DrudeForce_getNumScreenedPairs(self, *args)


    def addParticle(self, *args):
        """
        addParticle(DrudeForce self, int particle, int particle1, int particle2, int particle3, int particle4, double charge, double polarizability, double aniso12, double aniso34) -> int

        Add a Drude particle to which forces should be applied.
           Parameters:
            - particle the index within the System of the Drude particle
            - particle1 the index within the System of the particle to which the Drude particle is attached
            - particle2 the index within the System of the second particle used for defining anisotropic polarizability. This may be set to -1, in which case aniso12 will be ignored.
            - particle3 the index within the System of the third particle used for defining anisotropic polarizability. This may be set to -1, in which case aniso34 will be ignored.
            - particle4 the index within the System of the fourth particle used for defining anisotropic polarizability. This may be set to -1, in which case aniso34 will be ignored.
            - charge The charge on the Drude particle
            - polarizability The isotropic polarizability
            - aniso12 The scale factor for the polarizability along the direction defined by particle1 and particle2
            - aniso34 The scale factor for the polarizability along the direction defined by particle3 and particle4
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.DrudeForce_addParticle(self, *args)


    def getParticleParameters(self, *args):
        """
        getParticleParameters(DrudeForce self, int index)

        Get the parameters for a Drude particle.
           Parameters:
            - index the index of the Drude particle for which to get parameters
            - particle the index within the System of the Drude particle
            - particle1 the index within the System of the particle to which the Drude particle is attached
            - particle2 the index within the System of the second particle used for defining anisotropic polarizability. This may be set to -1, in which case aniso12 will be ignored.
            - particle3 the index within the System of the third particle used for defining anisotropic polarizability. This may be set to -1, in which case aniso34 will be ignored.
            - particle4 the index within the System of the fourth particle used for defining anisotropic polarizability. This may be set to -1, in which case aniso34 will be ignored.
            - charge The charge on the Drude particle
            - polarizability The isotropic polarizability
            - aniso12 The scale factor for the polarizability along the direction defined by particle1 and particle2
            - aniso34 The scale factor for the polarizability along the direction defined by particle3 and particle4
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.DrudeForce_getParticleParameters(self, *args)


    def setParticleParameters(self, *args):
        """
        setParticleParameters(DrudeForce self, int index, int particle, int particle1, int particle2, int particle3, int particle4, double charge, double polarizability, double aniso12, double aniso34)

        Set the parameters for a Drude particle.
           Parameters:
            - index the index of the Drude particle for which to set parameters
            - particle the index within the System of the Drude particle
            - particle1 the index within the System of the particle to which the Drude particle is attached
            - particle2 the index within the System of the second particle used for defining anisotropic polarizability. This may be set to -1, in which case aniso12 will be ignored.
            - particle3 the index within the System of the third particle used for defining anisotropic polarizability. This may be set to -1, in which case aniso34 will be ignored.
            - particle4 the index within the System of the fourth particle used for defining anisotropic polarizability. This may be set to -1, in which case aniso34 will be ignored.
            - charge The charge on the Drude particle
            - polarizability The isotropic polarizability
            - aniso12 The scale factor for the polarizability along the direction defined by particle1 and particle2
            - aniso34 The scale factor for the polarizability along the direction defined by particle3 and particle4
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.DrudeForce_setParticleParameters(self, *args)


    def addScreenedPair(self, *args):
        """
        addScreenedPair(DrudeForce self, int particle1, int particle2, double thole) -> int

        Add an interaction to the list of screened pairs.
           Parameters:
            - particle1 the index within this Force of the first particle involved in the interaction
            - particle2 the index within this Force of the second particle involved in the interaction
            - thole the Thole screening factor
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.DrudeForce_addScreenedPair(self, *args)


    def getScreenedPairParameters(self, *args):
        """
        getScreenedPairParameters(DrudeForce self, int index)

        Get the force field parameters for screened pair.
           Parameters:
            - index the index of the pair for which to get parameters
            - particle1 the index within this Force of the first particle involved in the interaction
            - particle2 the index within this Force of the second particle involved in the interaction
            - thole the Thole screening factor
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.DrudeForce_getScreenedPairParameters(self, *args)


    def setScreenedPairParameters(self, *args):
        """
        setScreenedPairParameters(DrudeForce self, int index, int particle1, int particle2, double thole)

        Set the force field parameters for screened pair.
           Parameters:
            - index the index of the pair for which to get parameters
            - particle1 the index within this Force of the first particle involved in the interaction
            - particle2 the index within this Force of the second particle involved in the interaction
            - thole the Thole screening factor
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.DrudeForce_setScreenedPairParameters(self, *args)


    def updateParametersInContext(self, *args):
        """
        updateParametersInContext(DrudeForce self, Context context)

        Update the particle and screened pair parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setParticleParameters() and setScreenedPairParameters() to modify this object's parameters, then call updateParametersInContext() to copy them over to the Context.

        This method has several limitations. It can be used to modify the numeric parameters associated with a particle or screened pair (polarizability, thole, etc.), but not the identities of the particles they involve. It also cannot be used to add new particles or screenedPairs, only to change the parameters of existing ones.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.DrudeForce_updateParametersInContext(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(DrudeForce self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.DrudeForce_usesPeriodicBoundaryConditions(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::DrudeForce self) -> DrudeForce
        __init__(OpenMM::DrudeForce self, DrudeForce other) -> DrudeForce

        Create a DrudeForce.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_DrudeForce(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_DrudeForce
    def __del__(self):
        """__del__(OpenMM::DrudeForce self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

DrudeForce_swigregister = _openmm.DrudeForce_swigregister
DrudeForce_swigregister(DrudeForce)

class CustomManyParticleForce(Force):
    """
    This class supports a wide variety of nonbonded N-particle interactions, where N is user specified. The interaction energy is determined by an arbitrary, user specified algebraic expression that is evaluated for every possible set of N particles in the system. It may depend on the positions of the individual particles, the distances between pairs of particles, the angles formed by sets of three particles, and the dihedral angles formed by sets of four particles.

    Be aware that the cost of evaluating an N-particle interaction increases very rapidly with N. Values larger than N=3 are rarely used.

    We refer to a set of particles for which the energy is being evaluated as p1, p2, p3, etc. The energy expression may depend on the following variables and functions:

    <ul>
    <li>
    x1, y1, z1, x2, y2, z2, etc.: The x, y, and z coordinates of the particle positions. For example, x1 is the x coordinate of particle p1, and y3 is the y coordinate of particle p3. 

    </li>
    <li>
    distance(p1, p2): the distance between particles p1 and p2 (where "p1" and "p2" may be replaced by the names of whichever particles you want to calculate the distance between). 

    </li>
    <li>
    angle(p1, p2, p3): the angle formed by the three specified particles. 

    </li>
    <li>
    dihedral(p1, p2, p3, p4): the dihedral angle formed by the four specified particles. 

    </li>
    <li>
    arbitrary global and per-particle parameters that you define. 

    </li>
    </ul>


    To use this class, create a CustomManyParticleForce object, passing an algebraic expression to the constructor that defines the interaction energy of each set of particles. Then call addPerParticleParameter() to define per-particle parameters, and addGlobalParameter() to define global parameters. The values of per-particle parameters are specified as part of the system definition, while values of global parameters may be modified during a simulation by calling Context::setParameter().

    Next, call addParticle() once for each particle in the System to set the values of its per-particle parameters. The number of particles for which you set parameters must be exactly equal to the number of particles in the System, or else an exception will be thrown when you try to create a Context. After a particle has been added, you can modify its parameters by calling setParticleParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext().

    Multi-particle interactions can be very expensive to evaluate, so they are usually used with a cutoff distance. The exact interpretation of the cutoff depends on the permutation mode, as discussed below.

    CustomManyParticleForce also lets you specify "exclusions", particular pairs of particles whose interactions should be omitted from force and energy calculations. This is most often used for particles that are bonded to each other. If you specify a pair of particles as an exclusion, <i>all</i> sets that include those two particles will be omitted.

    As an example, the following code creates a CustomManyParticleForce that implements an Axilrod-Teller potential. This is an interaction between three particles that depends on all three distances and angles formed by the particles.

    <tt><pre>CustomManyParticleForce* force = new CustomManyParticleForce(3,
        "C*(1+3*cos(theta1)*cos(theta2)*cos(theta3))/(r12*r13*r23)^3;"
        "theta1=angle(p1,p2,p3); theta2=angle(p2,p3,p1); theta3=angle(p3,p1,p2);"
        "r12=distance(p1,p2); r13=distance(p1,p3); r23=distance(p2,p3)");
    force->setPermutationMode(CustomManyParticleForce::SinglePermutation);
    </pre></tt>

    This force depends on one parameter, C. The following code defines it as a global parameter:

    <tt><pre>
    force->addGlobalParameter("C", 1.0);
    </pre></tt>

    Notice that the expression is symmetric with respect to the particles. It only depends on the products cos(theta1)*cos(theta2)*cos(theta3) and r12*r13*r23, both of which are unchanged if the labels p1, p2, and p3 are permuted. This is required because we specified SinglePermutation as the permutation mode. (This is the default, so we did not really need to set it, but doing so makes the example clearer.) In this mode, the expression is only evaluated once for each set of particles. No guarantee is made about which particle will be identified as p1, p2, etc. Therefore, the energy <i>must</i> be symmetric with respect to exchange of particles. Otherwise, the results would be undefined because permuting the labels would change the energy.

    Not all many-particle interactions work this way. Another common pattern is for the expression to describe an interaction between one central particle and other nearby particles. An example of this is the 3-particle piece of the Stillinger-Weber potential:

    <tt><pre>CustomManyParticleForce* force = new CustomManyParticleForce(3,
        "L*eps*(cos(theta1)+1/3)^2*exp(sigma*gamma/(r12-a*sigma))*exp(sigma*gamma/(r13-a*sigma));"
        "r12 = distance(p1,p2); r13 = distance(p1,p3); theta1 = angle(p3,p1,p2)");
    force->setPermutationMode(CustomManyParticleForce::UniqueCentralParticle);
    </pre></tt>

    When the permutation mode is set to UniqueCentralParticle, particle p1 is treated as the central particle. For a set of N particles, the expression is evaluated N times, once with each particle as p1. The expression can therefore treat p1 differently from the other particles. Notice that it is still symmetric with respect to p2 and p3, however. There is no guarantee about how those labels will be assigned to particles.

    Distance cutoffs are applied in different ways depending on the permutation mode. In SinglePermutation mode, every particle in the set must be within the cutoff distance of every other particle. If <i>any</i> two particles are further apart than the cutoff distance, the interaction is skipped. In UniqueCentralParticle mode, each particle must be within the cutoff distance of the central particle, but not necessarily of all the other particles. The cutoff may therefore exclude a subset of the permutations of a set of particles.

    Another common situation is that some particles are fundamentally different from others, causing the expression to be inherently non-symmetric. An example would be a water model that involves three particles, two of which <i>must</i> be hydrogen and one of which <i>must</i> be oxygen. Cases like this can be implemented using particle types.

    A particle type is an integer that you specify when you call addParticle(). (If you omit the argument, it defaults to 0.) For the water model, you could specify 0 for all oxygen atoms and 1 for all hydrogen atoms. You can then call setTypeFilter() to specify the list of allowed types for each of the N particles involved in an interaction:

    <tt><pre>
    set<int> oxygenTypes, hydrogenTypes;
    oxygenTypes.insert(0);
    hydrogenTypes.insert(1);
    force->setTypeFilter(0, oxygenTypes);
    force->setTypeFilter(1, hydrogenTypes);
    force->setTypeFilter(2, hydrogenTypes);
    </pre></tt>

    This specifies that of the three particles in an interaction, p1 must be oxygen while p2 and p3 must be hydrogen. The energy expression will only be evaluated for triplets of particles that satisfy those requirements. It will still only be evaluated once for each triplet, so it must still be symmetric with respect to p2 and p3.

    Expressions may involve the operators + (add), - (subtract), * (multiply), / (divide), and ^ (power), and the following functions: sqrt, exp, log, sin, cos, sec, csc, tan, cot, asin, acos, atan, sinh, cosh, tanh, erf, erfc, min, max, abs, floor, ceil, step, delta, select. All trigonometric functions are defined in radians, and log is the natural logarithm. step(x) = 0 if x is less than 0, 1 otherwise. delta(x) = 1 if x is 0, 0 otherwise. select(x,y,z) = z if x = 0, y otherwise. The names of per-particle parameters have the suffix "1", "2", etc. appended to them to indicate the values for the multiple interacting particles. For example, if you define a per-particle parameter called "charge", then the variable "charge2" is the charge of particle p2. As seen above, the expression may also involve intermediate quantities that are defined following the main expression, using ";" as a separator.

    In addition, you can call addTabulatedFunction() to define a new function based on tabulated values. You specify the function by creating a TabulatedFunction object. That function can then appear in the expression.
    """
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomManyParticleForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomManyParticleForce, name)
    __repr__ = _swig_repr
    NoCutoff = _openmm.CustomManyParticleForce_NoCutoff
    CutoffNonPeriodic = _openmm.CustomManyParticleForce_CutoffNonPeriodic
    CutoffPeriodic = _openmm.CustomManyParticleForce_CutoffPeriodic
    SinglePermutation = _openmm.CustomManyParticleForce_SinglePermutation
    UniqueCentralParticle = _openmm.CustomManyParticleForce_UniqueCentralParticle
    __swig_destroy__ = _openmm.delete_CustomManyParticleForce
    def __del__(self):
        """__del__(OpenMM::CustomManyParticleForce self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass


    def getNumParticlesPerSet(self, *args):
        """
        getNumParticlesPerSet(CustomManyParticleForce self) -> int

        Get the number of particles in each set for which the energy is evaluated
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomManyParticleForce_getNumParticlesPerSet(self, *args)


    def getNumParticles(self, *args):
        """
        getNumParticles(CustomManyParticleForce self) -> int

        Get the number of particles for which force field parameters have been defined.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomManyParticleForce_getNumParticles(self, *args)


    def getNumExclusions(self, *args):
        """
        getNumExclusions(CustomManyParticleForce self) -> int

        Get the number of particle pairs whose interactions should be excluded.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomManyParticleForce_getNumExclusions(self, *args)


    def getNumPerParticleParameters(self, *args):
        """
        getNumPerParticleParameters(CustomManyParticleForce self) -> int

        Get the number of per-particle parameters that the interaction depends on.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomManyParticleForce_getNumPerParticleParameters(self, *args)


    def getNumGlobalParameters(self, *args):
        """
        getNumGlobalParameters(CustomManyParticleForce self) -> int

        Get the number of global parameters that the interaction depends on.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomManyParticleForce_getNumGlobalParameters(self, *args)


    def getNumTabulatedFunctions(self, *args):
        """
        getNumTabulatedFunctions(CustomManyParticleForce self) -> int

        Get the number of tabulated functions that have been defined.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomManyParticleForce_getNumTabulatedFunctions(self, *args)


    def getEnergyFunction(self, *args):
        """
        getEnergyFunction(CustomManyParticleForce self) -> std::string const &

        Get the algebraic expression that gives the interaction energy of each bond
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomManyParticleForce_getEnergyFunction(self, *args)


    def setEnergyFunction(self, *args):
        """
        setEnergyFunction(CustomManyParticleForce self, std::string const & energy)

        Set the algebraic expression that gives the interaction energy of each bond
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomManyParticleForce_setEnergyFunction(self, *args)


    def getNonbondedMethod(self, *args):
        """
        getNonbondedMethod(CustomManyParticleForce self) -> OpenMM::CustomManyParticleForce::NonbondedMethod

        Get the method used for handling long range nonbonded interactions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomManyParticleForce_getNonbondedMethod(self, *args)


    def setNonbondedMethod(self, *args):
        """
        setNonbondedMethod(CustomManyParticleForce self, OpenMM::CustomManyParticleForce::NonbondedMethod method)

        Set the method used for handling long range nonbonded interactions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomManyParticleForce_setNonbondedMethod(self, *args)


    def getPermutationMode(self, *args):
        """
        getPermutationMode(CustomManyParticleForce self) -> OpenMM::CustomManyParticleForce::PermutationMode

        Get the mode that selects which permutations of a set of particles to evaluate the interaction for.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomManyParticleForce_getPermutationMode(self, *args)


    def setPermutationMode(self, *args):
        """
        setPermutationMode(CustomManyParticleForce self, OpenMM::CustomManyParticleForce::PermutationMode mode)

        Set the mode that selects which permutations of a set of particles to evaluate the interaction for.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomManyParticleForce_setPermutationMode(self, *args)


    def getCutoffDistance(self, *args):
        """
        getCutoffDistance(CustomManyParticleForce self) -> double

        Get the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.CustomManyParticleForce_getCutoffDistance(self, *args)

        val=unit.Quantity(val, unit.nanometers)


        return val


    def setCutoffDistance(self, *args):
        """
        setCutoffDistance(CustomManyParticleForce self, double distance)

        Set the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
           Parameters:
            - distance the cutoff distance, measured in nm
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomManyParticleForce_setCutoffDistance(self, *args)


    def addPerParticleParameter(self, *args):
        """
        addPerParticleParameter(CustomManyParticleForce self, std::string const & name) -> int

        Add a new per-particle parameter that the interaction may depend on.
           Parameters:
            - name the name of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomManyParticleForce_addPerParticleParameter(self, *args)


    def getPerParticleParameterName(self, *args):
        """
        getPerParticleParameterName(CustomManyParticleForce self, int index) -> std::string const &

        Get the name of a per-particle parameter.
           Parameters:
            - index the index of the parameter for which to get the name
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomManyParticleForce_getPerParticleParameterName(self, *args)


    def setPerParticleParameterName(self, *args):
        """
        setPerParticleParameterName(CustomManyParticleForce self, int index, std::string const & name)

        Set the name of a per-particle parameter.
           Parameters:
            - index the index of the parameter for which to set the name
            - name the name of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomManyParticleForce_setPerParticleParameterName(self, *args)


    def addGlobalParameter(self, *args):
        """
        addGlobalParameter(CustomManyParticleForce self, std::string const & name, double defaultValue) -> int

        Add a new global parameter that the interaction may depend on.
           Parameters:
            - name the name of the parameter
            - defaultValue the default value of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomManyParticleForce_addGlobalParameter(self, *args)


    def getGlobalParameterName(self, *args):
        """
        getGlobalParameterName(CustomManyParticleForce self, int index) -> std::string const &

        Get the name of a global parameter.
           Parameters:
            - index the index of the parameter for which to get the name
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomManyParticleForce_getGlobalParameterName(self, *args)


    def setGlobalParameterName(self, *args):
        """
        setGlobalParameterName(CustomManyParticleForce self, int index, std::string const & name)

        Set the name of a global parameter.
           Parameters:
            - index the index of the parameter for which to set the name
            - name the name of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomManyParticleForce_setGlobalParameterName(self, *args)


    def getGlobalParameterDefaultValue(self, *args):
        """
        getGlobalParameterDefaultValue(CustomManyParticleForce self, int index) -> double

        Get the default value of a global parameter.
           Parameters:
            - index the index of the parameter for which to get the default value
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomManyParticleForce_getGlobalParameterDefaultValue(self, *args)


    def setGlobalParameterDefaultValue(self, *args):
        """
        setGlobalParameterDefaultValue(CustomManyParticleForce self, int index, double defaultValue)

        Set the default value of a global parameter.
           Parameters:
            - index the index of the parameter for which to set the default value
            - name the default value of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomManyParticleForce_setGlobalParameterDefaultValue(self, *args)


    def addParticle(self, *args):
        """
        addParticle(CustomManyParticleForce self, vectord parameters, int type=0) -> int

        Add the nonbonded force parameters for a particle. This should be called once for each particle in the System. When it is called for the i'th time, it specifies the parameters for the i'th particle.
           Parameters:
            - parameters the list of parameters for the new particle
            - type the type of the new particle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomManyParticleForce_addParticle(self, *args)


    def getParticleParameters(self, *args):
        """
        getParticleParameters(CustomManyParticleForce self, int index)

        Get the nonbonded force parameters for a particle.
           Parameters:
            - index the index of the particle for which to get parameters
            - parameters the list of parameters for the specified particle
            - type the type of the specified particle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomManyParticleForce_getParticleParameters(self, *args)


    def setParticleParameters(self, *args):
        """
        setParticleParameters(CustomManyParticleForce self, int index, vectord parameters, int type)

        Set the nonbonded force parameters for a particle.
           Parameters:
            - index the index of the particle for which to set parameters
            - parameters the list of parameters for the specified particle
            - type the type of the specified particle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomManyParticleForce_setParticleParameters(self, *args)


    def addExclusion(self, *args):
        """
        addExclusion(CustomManyParticleForce self, int particle1, int particle2) -> int

        Add a particle pair to the list of interactions that should be excluded.

        In many cases, you can use createExclusionsFromBonds() rather than adding each exclusion explicitly.
           Parameters:
            - particle1 the index of the first particle in the pair
            - particle2 the index of the second particle in the pair
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomManyParticleForce_addExclusion(self, *args)


    def getExclusionParticles(self, *args):
        """
        getExclusionParticles(CustomManyParticleForce self, int index)

        Get the particles in a pair whose interaction should be excluded.
           Parameters:
            - index the index of the exclusion for which to get particle indices
            - particle1 the index of the first particle in the pair
            - particle2 the index of the second particle in the pair
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomManyParticleForce_getExclusionParticles(self, *args)


    def setExclusionParticles(self, *args):
        """
        setExclusionParticles(CustomManyParticleForce self, int index, int particle1, int particle2)

        Set the particles in a pair whose interaction should be excluded.
           Parameters:
            - index the index of the exclusion for which to set particle indices
            - particle1 the index of the first particle in the pair
            - particle2 the index of the second particle in the pair
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomManyParticleForce_setExclusionParticles(self, *args)


    def createExclusionsFromBonds(self, *args):
        """
        createExclusionsFromBonds(CustomManyParticleForce self, vectorpairii bonds, int bondCutoff)

        Identify exclusions based on the molecular topology. Particles which are separated by up to a specified number of bonds are added as exclusions.
           Parameters:
            - bonds the set of bonds based on which to construct exclusions. Each element specifies the indices of two particles that are bonded to each other.
            - bondCutoff pairs of particles that are separated by this many bonds or fewer are added to the list of exclusions
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomManyParticleForce_createExclusionsFromBonds(self, *args)


    def getTypeFilter(self, *args):
        """
        getTypeFilter(CustomManyParticleForce self, int index)

        Get the allowed particle types for one of the particles involved in the interaction. If this an empty set (the default), no filter is applied and all interactions are evaluated regardless of the type of the specified particle.
           Parameters:
            - index the index of the particle within the interaction (between 0 and getNumParticlesPerSet())
            - types the allowed types for the specified particle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomManyParticleForce_getTypeFilter(self, *args)


    def setTypeFilter(self, *args):
        """
        setTypeFilter(CustomManyParticleForce self, int index, seti types)

        Set the allowed particle types for one of the particles involved in the interaction. If this an empty set (the default), no filter is applied and all interactions are evaluated regardless of the type of the specified particle.
           Parameters:
            - index the index of the particle within the interaction (between 0 and getNumParticlesPerSet())
            - types the allowed types for the specified particle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomManyParticleForce_setTypeFilter(self, *args)


    def addTabulatedFunction(self, *args):
        """
        addTabulatedFunction(CustomManyParticleForce self, std::string const & name, TabulatedFunction function) -> int

        Add a tabulated function that may appear in the energy expression.
           Parameters:
            - name the name of the function as it appears in expressions
            - function a TabulatedFunction object defining the function. The TabulatedFunction should have been created on the heap with the "new" operator. The Force takes over ownership of it, and deletes it when the Force itself is deleted.
        """

        if not args[1].thisown:
           s = "the %s object does not own its corresponding OpenMM object" \
              % args[1].__class__.__name__
           raise Exception(s)


        val = _openmm.CustomManyParticleForce_addTabulatedFunction(self, *args)

        args[1].thisown=0


        return val


    def getTabulatedFunction(self, *args):
        """
        getTabulatedFunction(CustomManyParticleForce self, int index) -> TabulatedFunction
        getTabulatedFunction(CustomManyParticleForce self, int index) -> TabulatedFunction

        Get a reference to a tabulated function that may appear in the energy expression.
           Parameters:
            - index the index of the function to get
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomManyParticleForce_getTabulatedFunction(self, *args)


    def getTabulatedFunctionName(self, *args):
        """
        getTabulatedFunctionName(CustomManyParticleForce self, int index) -> std::string const &

        Get the name of a tabulated function that may appear in the energy expression.
           Parameters:
            - index the index of the function to get
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomManyParticleForce_getTabulatedFunctionName(self, *args)


    def updateParametersInContext(self, *args):
        """
        updateParametersInContext(CustomManyParticleForce self, Context context)

        Update the per-particle parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setParticleParameters() to modify this object's parameters, then call updateParametersInContext() to copy them over to the Context.

        This method has several limitations. The only information it updates is the values of per-particle parameters. All other aspects of the Force (the energy function, nonbonded method, cutoff distance, etc.) are unaffected and can only be changed by reinitializing the Context. Also, this method cannot be used to add new particles, only to change the parameters of existing ones.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomManyParticleForce_updateParametersInContext(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(CustomManyParticleForce self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomManyParticleForce_usesPeriodicBoundaryConditions(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::CustomManyParticleForce self, int particlesPerSet, std::string const & energy) -> CustomManyParticleForce
        __init__(OpenMM::CustomManyParticleForce self, CustomManyParticleForce other) -> CustomManyParticleForce

        Create a CustomManyParticleForce.
           Parameters:
            - particlesPerSet the number of particles in each set for which the energy is evaluated
            - energy an algebraic expression giving the interaction energy of each triplet as a function of particle positions, inter-particle distances, angles, and any global and per-particle parameters
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_CustomManyParticleForce(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
CustomManyParticleForce_swigregister = _openmm.CustomManyParticleForce_swigregister
CustomManyParticleForce_swigregister(CustomManyParticleForce)

class GBVIForce(Force):
    """
    This class implements an implicit solvation force using the GB/VI model. 

    To use this class, create a GBVIForce object, then call addParticle() once for each particle in the System to define its parameters. The number of particles for which you define GB/VI parameters must be exactly equal to the number of particles in the System, or else an exception will be thrown when you try to create a Context. After a particle has been added, you can modify its force field parameters by calling setParticleParameters().
    """
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GBVIForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GBVIForce, name)
    __repr__ = _swig_repr
    NoCutoff = _openmm.GBVIForce_NoCutoff
    CutoffNonPeriodic = _openmm.GBVIForce_CutoffNonPeriodic
    CutoffPeriodic = _openmm.GBVIForce_CutoffPeriodic
    NoScaling = _openmm.GBVIForce_NoScaling
    QuinticSpline = _openmm.GBVIForce_QuinticSpline

    def getNumParticles(self, *args):
        """
        getNumParticles(GBVIForce self) -> int

        Get the number of particles in the system.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVIForce_getNumParticles(self, *args)


    def addParticle(self, *args):
        """
        addParticle(GBVIForce self, double charge, double radius, double gamma) -> int

        Add the GB/VI parameters for a particle. This should be called once for each particle in the System. When it is called for the i'th time, it specifies the parameters for the i'th particle.
           Parameters:
            - charge the charge of the particle, measured in units of the proton charge
            - radius the GB/VI radius of the particle, measured in nm
            - gamma the gamma parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVIForce_addParticle(self, *args)


    def getParticleParameters(self, *args):
        """
        getParticleParameters(GBVIForce self, int index)

        Get the force field parameters for a particle.
           Parameters:
            - index the index of the particle for which to get parameters
            - charge the charge of the particle, measured in units of the proton charge
            - radius the GBSA radius of the particle, measured in nm
            - gamma the gamma parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.GBVIForce_getParticleParameters(self, *args)

        val[0]=unit.Quantity(val[0], unit.elementary_charge)
        val[1]=unit.Quantity(val[1], unit.nanometer)
        val[2]=unit.Quantity(val[2], unit.kilojoule_per_mole)


        return val


    def setParticleParameters(self, *args):
        """
        setParticleParameters(GBVIForce self, int index, double charge, double radius, double gamma)

        Set the force field parameters for a particle.
           Parameters:
            - index the index of the particle for which to set parameters
            - charge the charge of the particle, measured in units of the proton charge
            - radius the GB/VI radius of the particle, measured in nm
            - gamma the gamma parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVIForce_setParticleParameters(self, *args)


    def addBond(self, *args):
        """
        addBond(GBVIForce self, int particle1, int particle2, double distance) -> int

        Add a bond
           Parameters:
            - particle1 the index of the first particle
            - particle2 the index of the second particle
            - distance the distance between the two particles, measured in nm
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVIForce_addBond(self, *args)


    def getBondParameters(self, *args):
        """
        getBondParameters(GBVIForce self, int index)

        Get the parameters defining a bond
           Parameters:
            - index the index of the bond for which to get parameters
            - particle1 the index of the first particle involved in the bond
            - particle2 the index of the second particle involved in the bond
            - distance the distance between the two particles, measured in nm
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.GBVIForce_getBondParameters(self, *args)

        val[2]=unit.Quantity(val[2], unit.nanometer)


        return val


    def setBondParameters(self, *args):
        """
        setBondParameters(GBVIForce self, int index, int particle1, int particle2, double bondLength)

        Set 1-2 bonds
           Parameters:
            - index index of the bond for which to set parameters
            - particle1 index of first atom in bond
            - particle2 index of second atom in bond
            - bondLength bond length, measured in nm
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVIForce_setBondParameters(self, *args)


    def getNumBonds(self, *args):
        """
        getNumBonds(GBVIForce self) -> int

        Get number of bonds
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVIForce_getNumBonds(self, *args)


    def getSolventDielectric(self, *args):
        """
        getSolventDielectric(GBVIForce self) -> double

        Get the dielectric constant for the solvent.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVIForce_getSolventDielectric(self, *args)


    def setSolventDielectric(self, *args):
        """
        setSolventDielectric(GBVIForce self, double dielectric)

        Set the dielectric constant for the solvent.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVIForce_setSolventDielectric(self, *args)


    def getSoluteDielectric(self, *args):
        """
        getSoluteDielectric(GBVIForce self) -> double

        Get the dielectric constant for the solute.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVIForce_getSoluteDielectric(self, *args)


    def setSoluteDielectric(self, *args):
        """
        setSoluteDielectric(GBVIForce self, double dielectric)

        Set the dielectric constant for the solute.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVIForce_setSoluteDielectric(self, *args)


    def getNonbondedMethod(self, *args):
        """
        getNonbondedMethod(GBVIForce self) -> OpenMM::GBVIForce::NonbondedMethod

        Get the method used for handling long range nonbonded interactions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVIForce_getNonbondedMethod(self, *args)


    def setNonbondedMethod(self, *args):
        """
        setNonbondedMethod(GBVIForce self, OpenMM::GBVIForce::NonbondedMethod method)

        Set the method used for handling long range nonbonded interactions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVIForce_setNonbondedMethod(self, *args)


    def getCutoffDistance(self, *args):
        """
        getCutoffDistance(GBVIForce self) -> double

        Get the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.GBVIForce_getCutoffDistance(self, *args)

        val=unit.Quantity(val, unit.nanometers)


        return val


    def setCutoffDistance(self, *args):
        """
        setCutoffDistance(GBVIForce self, double distance)

        Set the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
           Parameters:
            - distance the cutoff distance, measured in nm
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVIForce_setCutoffDistance(self, *args)


    def getBornRadiusScalingMethod(self, *args):
        """
        getBornRadiusScalingMethod(GBVIForce self) -> OpenMM::GBVIForce::BornRadiusScalingMethod

        Get Born radius scaling method
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVIForce_getBornRadiusScalingMethod(self, *args)


    def setBornRadiusScalingMethod(self, *args):
        """
        setBornRadiusScalingMethod(GBVIForce self, OpenMM::GBVIForce::BornRadiusScalingMethod method)

        Set Born radius scaling method
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVIForce_setBornRadiusScalingMethod(self, *args)


    def getQuinticLowerLimitFactor(self, *args):
        """
        getQuinticLowerLimitFactor(GBVIForce self) -> double

        Get the lower limit factor used in the quintic spline scaling method (typically 0.5-0.8)
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVIForce_getQuinticLowerLimitFactor(self, *args)


    def setQuinticLowerLimitFactor(self, *args):
        """
        setQuinticLowerLimitFactor(GBVIForce self, double quinticLowerLimitFactor)

        Set the lower limit factor used in the quintic spline scaling method (typically 0.5-0.8)
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVIForce_setQuinticLowerLimitFactor(self, *args)


    def getQuinticUpperBornRadiusLimit(self, *args):
        """
        getQuinticUpperBornRadiusLimit(GBVIForce self) -> double

        Get the upper limit used in the quintic spline scaling method, measured in nm (~5.0)
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.GBVIForce_getQuinticUpperBornRadiusLimit(self, *args)

        val=unit.Quantity(val, unit.nanometer)


        return val


    def setQuinticUpperBornRadiusLimit(self, *args):
        """
        setQuinticUpperBornRadiusLimit(GBVIForce self, double quinticUpperBornRadiusLimit)

        Set the upper limit used in the quintic spline scaling method, measured in nm (~5.0)
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVIForce_setQuinticUpperBornRadiusLimit(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(GBVIForce self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBVIForce_usesPeriodicBoundaryConditions(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::GBVIForce self) -> GBVIForce
        __init__(OpenMM::GBVIForce self, GBVIForce other) -> GBVIForce

        This class implements an implicit solvation force using the GB/VI model. 

        To use this class, create a GBVIForce object, then call addParticle() once for each particle in the System to define its parameters. The number of particles for which you define GB/VI parameters must be exactly equal to the number of particles in the System, or else an exception will be thrown when you try to create a Context. After a particle has been added, you can modify its force field parameters by calling setParticleParameters().
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_GBVIForce(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_GBVIForce
    def __del__(self):
        """__del__(OpenMM::GBVIForce self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

GBVIForce_swigregister = _openmm.GBVIForce_swigregister
GBVIForce_swigregister(GBVIForce)

class TwoParticleAverageSite(VirtualSite):
    """This is a VirtualSite that computes the particle location as a weighted average of two other particle's locations. Assuming the weights add up to 1, this means the virtual site is on the line passing through the two particles."""
    __swig_setmethods__ = {}
    for _s in [VirtualSite]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TwoParticleAverageSite, name, value)
    __swig_getmethods__ = {}
    for _s in [VirtualSite]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TwoParticleAverageSite, name)
    __repr__ = _swig_repr

    def getWeight(self, *args):
        """
        getWeight(TwoParticleAverageSite self, int particle) -> double

        Get the weight factor used for a particle this virtual site depends on.
           Parameters:
            - particle the particle to get (between 0 and getNumParticles())
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.TwoParticleAverageSite_getWeight(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::TwoParticleAverageSite self, int particle1, int particle2, double weight1, double weight2) -> TwoParticleAverageSite
        __init__(OpenMM::TwoParticleAverageSite self, TwoParticleAverageSite other) -> TwoParticleAverageSite

        Create a new TwoParticleAverageSite virtual site. Normally weight1 and weight2 should add up to 1, although this is not strictly required.
           Parameters:
            - particle1 the index of the first particle
            - particle2 the index of the second particle
            - weight1 the weight factor (between 0 and 1) for the first particle
            - weight2 the weight factor (between 0 and 1) for the second particle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_TwoParticleAverageSite(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_TwoParticleAverageSite
    def __del__(self):
        """__del__(OpenMM::TwoParticleAverageSite self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

TwoParticleAverageSite_swigregister = _openmm.TwoParticleAverageSite_swigregister
TwoParticleAverageSite_swigregister(TwoParticleAverageSite)

class GBSAOBCForce(Force):
    """
    This class implements an implicit solvation force using the GBSA-OBC model.

    To use this class, create a GBSAOBCForce object, then call addParticle() once for each particle in the System to define its parameters. The number of particles for which you define GBSA parameters must be exactly equal to the number of particles in the System, or else an exception will be thrown when you try to create a Context. After a particle has been added, you can modify its force field parameters by calling setParticleParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext().

    When using this Force, the System should also include a NonbondedForce, and both objects must specify identical charges for all particles. Otherwise, the results will not be correct. Furthermore, if the nonbonded method is set to CutoffNonPeriodic or CutoffPeriodic, you should call setReactionFieldDielectric(1.0) on the NonbondedForce to turn off the reaction field approximation, which does not produce correct results when combined with GBSA.
    """
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GBSAOBCForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GBSAOBCForce, name)
    __repr__ = _swig_repr
    NoCutoff = _openmm.GBSAOBCForce_NoCutoff
    CutoffNonPeriodic = _openmm.GBSAOBCForce_CutoffNonPeriodic
    CutoffPeriodic = _openmm.GBSAOBCForce_CutoffPeriodic

    def getNumParticles(self, *args):
        """
        getNumParticles(GBSAOBCForce self) -> int

        Get the number of particles in the system.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBSAOBCForce_getNumParticles(self, *args)


    def addParticle(self, *args):
        """
        addParticle(GBSAOBCForce self, double charge, double radius, double scalingFactor) -> int

        Add the GBSA parameters for a particle. This should be called once for each particle in the System. When it is called for the i'th time, it specifies the parameters for the i'th particle.
           Parameters:
            - charge the charge of the particle, measured in units of the proton charge
            - radius the GBSA radius of the particle, measured in nm
            - scalingFactor the OBC scaling factor for the particle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBSAOBCForce_addParticle(self, *args)


    def getParticleParameters(self, *args):
        """
        getParticleParameters(GBSAOBCForce self, int index)

        Get the force field parameters for a particle.
           Parameters:
            - index the index of the particle for which to get parameters
            - charge the charge of the particle, measured in units of the proton charge
            - radius the GBSA radius of the particle, measured in nm
            - scalingFactor the OBC scaling factor for the particle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.GBSAOBCForce_getParticleParameters(self, *args)

        val[0]=unit.Quantity(val[0], unit.elementary_charge)
        val[1]=unit.Quantity(val[1], unit.nanometer)


        return val


    def setParticleParameters(self, *args):
        """
        setParticleParameters(GBSAOBCForce self, int index, double charge, double radius, double scalingFactor)

        Set the force field parameters for a particle.
           Parameters:
            - index the index of the particle for which to set parameters
            - charge the charge of the particle, measured in units of the proton charge
            - radius the GBSA radius of the particle, measured in nm
            - scalingFactor the OBC scaling factor for the particle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBSAOBCForce_setParticleParameters(self, *args)


    def getSolventDielectric(self, *args):
        """
        getSolventDielectric(GBSAOBCForce self) -> double

        Get the dielectric constant for the solvent.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBSAOBCForce_getSolventDielectric(self, *args)


    def setSolventDielectric(self, *args):
        """
        setSolventDielectric(GBSAOBCForce self, double dielectric)

        Set the dielectric constant for the solvent.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBSAOBCForce_setSolventDielectric(self, *args)


    def getSoluteDielectric(self, *args):
        """
        getSoluteDielectric(GBSAOBCForce self) -> double

        Get the dielectric constant for the solute.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBSAOBCForce_getSoluteDielectric(self, *args)


    def setSoluteDielectric(self, *args):
        """
        setSoluteDielectric(GBSAOBCForce self, double dielectric)

        Set the dielectric constant for the solute.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBSAOBCForce_setSoluteDielectric(self, *args)


    def getSurfaceAreaEnergy(self, *args):
        """
        getSurfaceAreaEnergy(GBSAOBCForce self) -> double

        Get the energy scale for the surface energy term, measured in kJ/mol/nm^2.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.GBSAOBCForce_getSurfaceAreaEnergy(self, *args)

        val=unit.Quantity(val, unit.kilojoule_per_mole/unit.nanometer/unit.nanometer)


        return val


    def setSurfaceAreaEnergy(self, *args):
        """
        setSurfaceAreaEnergy(GBSAOBCForce self, double energy)

        Set the energy scale for the surface energy term, measured in kJ/mol/nm^2.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBSAOBCForce_setSurfaceAreaEnergy(self, *args)


    def getNonbondedMethod(self, *args):
        """
        getNonbondedMethod(GBSAOBCForce self) -> OpenMM::GBSAOBCForce::NonbondedMethod

        Get the method used for handling long range nonbonded interactions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBSAOBCForce_getNonbondedMethod(self, *args)


    def setNonbondedMethod(self, *args):
        """
        setNonbondedMethod(GBSAOBCForce self, OpenMM::GBSAOBCForce::NonbondedMethod method)

        Set the method used for handling long range nonbonded interactions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBSAOBCForce_setNonbondedMethod(self, *args)


    def getCutoffDistance(self, *args):
        """
        getCutoffDistance(GBSAOBCForce self) -> double

        Get the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.GBSAOBCForce_getCutoffDistance(self, *args)

        val=unit.Quantity(val, unit.nanometers)


        return val


    def setCutoffDistance(self, *args):
        """
        setCutoffDistance(GBSAOBCForce self, double distance)

        Set the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
           Parameters:
            - distance the cutoff distance, measured in nm
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBSAOBCForce_setCutoffDistance(self, *args)


    def updateParametersInContext(self, *args):
        """
        updateParametersInContext(GBSAOBCForce self, Context context)

        Update the particle parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setParticleParameters() to modify this object's parameters, then call updateParametersInContext() to copy them over to the Context.

        The only information this method updates is the values of per-particle parameters. All other aspects of the Force (the nonbonded method, the cutoff distance, etc.) are unaffected and can only be changed by reinitializing the Context. Furthermore, this method cannot be used to add new particles, only to change the parameters of existing ones.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBSAOBCForce_updateParametersInContext(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(GBSAOBCForce self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.GBSAOBCForce_usesPeriodicBoundaryConditions(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::GBSAOBCForce self) -> GBSAOBCForce
        __init__(OpenMM::GBSAOBCForce self, GBSAOBCForce other) -> GBSAOBCForce

        Create a GBSAOBCForce.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_GBSAOBCForce(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_GBSAOBCForce
    def __del__(self):
        """__del__(OpenMM::GBSAOBCForce self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

GBSAOBCForce_swigregister = _openmm.GBSAOBCForce_swigregister
GBSAOBCForce_swigregister(GBSAOBCForce)

class NonbondedForce(Force):
    """
    This class implements nonbonded interactions between particles, including a Coulomb force to represent electrostatics and a Lennard-Jones force to represent van der Waals interactions. It optionally supports periodic boundary conditions and cutoffs for long range interactions. Lennard-Jones interactions are calculated with the Lorentz-Berthelot combining rule: it uses the arithmetic mean of the sigmas and the geometric mean of the epsilons for the two interacting particles.

    To use this class, create a NonbondedForce object, then call addParticle() once for each particle in the System to define its parameters. The number of particles for which you define nonbonded parameters must be exactly equal to the number of particles in the System, or else an exception will be thrown when you try to create a Context. After a particle has been added, you can modify its force field parameters by calling setParticleParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext().

    NonbondedForce also lets you specify "exceptions", particular pairs of particles whose interactions should be computed based on different parameters than those defined for the individual particles. This can be used to completely exclude certain interactions from the force calculation, or to alter how they interact with each other.

    Many molecular force fields omit Coulomb and Lennard-Jones interactions between particles separated by one or two bonds, while using modified parameters for those separated by three bonds (known as "1-4 interactions"). This class provides a convenience method for this case called createExceptionsFromBonds(). You pass to it a list of bonds and the scale factors to use for 1-4 interactions. It identifies all pairs of particles which are separated by 1, 2, or 3 bonds, then automatically creates exceptions for them.

    When using a cutoff, by default Lennard-Jones interactions are sharply truncated at the cutoff distance. Optionally you can instead use a switching function to make the interaction smoothly go to zero over a finite distance range. To enable this, call setUseSwitchingFunction(). You must also call setSwitchingDistance() to specify the distance at which the interaction should begin to decrease. The switching distance must be less than the cutoff distance.

    Another optional feature of this class (enabled by default) is to add a contribution to the energy which approximates the effect of all Lennard-Jones interactions beyond the cutoff in a periodic system. When running a simulation at constant pressure, this can improve the quality of the result. Call setUseDispersionCorrection() to set whether this should be used.
    """
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NonbondedForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NonbondedForce, name)
    __repr__ = _swig_repr
    NoCutoff = _openmm.NonbondedForce_NoCutoff
    CutoffNonPeriodic = _openmm.NonbondedForce_CutoffNonPeriodic
    CutoffPeriodic = _openmm.NonbondedForce_CutoffPeriodic
    Ewald = _openmm.NonbondedForce_Ewald
    PME = _openmm.NonbondedForce_PME

    def getNumParticles(self, *args):
        """
        getNumParticles(NonbondedForce self) -> int

        Get the number of particles for which force field parameters have been defined.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_getNumParticles(self, *args)


    def getNumExceptions(self, *args):
        """
        getNumExceptions(NonbondedForce self) -> int

        Get the number of special interactions that should be calculated differently from other interactions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_getNumExceptions(self, *args)


    def getNonbondedMethod(self, *args):
        """
        getNonbondedMethod(NonbondedForce self) -> OpenMM::NonbondedForce::NonbondedMethod

        Get the method used for handling long range nonbonded interactions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_getNonbondedMethod(self, *args)


    def setNonbondedMethod(self, *args):
        """
        setNonbondedMethod(NonbondedForce self, OpenMM::NonbondedForce::NonbondedMethod method)

        Set the method used for handling long range nonbonded interactions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_setNonbondedMethod(self, *args)


    def getCutoffDistance(self, *args):
        """
        getCutoffDistance(NonbondedForce self) -> double

        Get the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.NonbondedForce_getCutoffDistance(self, *args)

        val=unit.Quantity(val, unit.nanometers)


        return val


    def setCutoffDistance(self, *args):
        """
        setCutoffDistance(NonbondedForce self, double distance)

        Set the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
           Parameters:
            - distance the cutoff distance, measured in nm
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_setCutoffDistance(self, *args)


    def getUseSwitchingFunction(self, *args):
        """
        getUseSwitchingFunction(NonbondedForce self) -> bool

        Get whether a switching function is applied to the Lennard-Jones interaction. If the nonbonded method is set to NoCutoff, this option is ignored.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_getUseSwitchingFunction(self, *args)


    def setUseSwitchingFunction(self, *args):
        """
        setUseSwitchingFunction(NonbondedForce self, bool use)

        Set whether a switching function is applied to the Lennard-Jones interaction. If the nonbonded method is set to NoCutoff, this option is ignored.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_setUseSwitchingFunction(self, *args)


    def getSwitchingDistance(self, *args):
        """
        getSwitchingDistance(NonbondedForce self) -> double

        Get the distance at which the switching function begins to reduce the Lennard-Jones interaction. This must be less than the cutoff distance.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.NonbondedForce_getSwitchingDistance(self, *args)

        val=unit.Quantity(val, unit.nanometers)


        return val


    def setSwitchingDistance(self, *args):
        """
        setSwitchingDistance(NonbondedForce self, double distance)

        Set the distance at which the switching function begins to reduce the Lennard-Jones interaction. This must be less than the cutoff distance.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_setSwitchingDistance(self, *args)


    def getReactionFieldDielectric(self, *args):
        """
        getReactionFieldDielectric(NonbondedForce self) -> double

        Get the dielectric constant to use for the solvent in the reaction field approximation.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_getReactionFieldDielectric(self, *args)


    def setReactionFieldDielectric(self, *args):
        """
        setReactionFieldDielectric(NonbondedForce self, double dielectric)

        Set the dielectric constant to use for the solvent in the reaction field approximation.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_setReactionFieldDielectric(self, *args)


    def getEwaldErrorTolerance(self, *args):
        """
        getEwaldErrorTolerance(NonbondedForce self) -> double

        Get the error tolerance for Ewald summation. This corresponds to the fractional error in the forces which is acceptable. This value is used to select the reciprocal space cutoff and separation parameter so that the average error level will be less than the tolerance. There is not a rigorous guarantee that all forces on all atoms will be less than the tolerance, however.

        For PME calculations, if setPMEParameters() is used to set alpha to something other than 0, this value is ignored.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_getEwaldErrorTolerance(self, *args)


    def setEwaldErrorTolerance(self, *args):
        """
        setEwaldErrorTolerance(NonbondedForce self, double tol)

        Set the error tolerance for Ewald summation. This corresponds to the fractional error in the forces which is acceptable. This value is used to select the reciprocal space cutoff and separation parameter so that the average error level will be less than the tolerance. There is not a rigorous guarantee that all forces on all atoms will be less than the tolerance, however.

        For PME calculations, if setPMEParameters() is used to set alpha to something other than 0, this value is ignored.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_setEwaldErrorTolerance(self, *args)


    def getPMEParameters(self, *args):
        """
        getPMEParameters(NonbondedForce self)

        Get the parameters to use for PME calculations. If alpha is 0 (the default), these parameters are ignored and instead their values are chosen based on the Ewald error tolerance.
           Parameters:
            - alpha the separation parameter
            - nx the number of grid points along the X axis
            - ny the number of grid points along the Y axis
            - nz the number of grid points along the Z axis
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.NonbondedForce_getPMEParameters(self, *args)

        val[0]=unit.Quantity(val[0], 1/unit.nanometer)


        return val


    def setPMEParameters(self, *args):
        """
        setPMEParameters(NonbondedForce self, double alpha, int nx, int ny, int nz)

        Set the parameters to use for PME calculations. If alpha is 0 (the default), these parameters are ignored and instead their values are chosen based on the Ewald error tolerance.
           Parameters:
            - alpha the separation parameter
            - nx the number of grid points along the X axis
            - ny the number of grid points along the Y axis
            - nz the number of grid points along the Z axis
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_setPMEParameters(self, *args)


    def addParticle(self, *args):
        """
        addParticle(NonbondedForce self, double charge, double sigma, double epsilon) -> int

        Add the nonbonded force parameters for a particle. This should be called once for each particle in the System. When it is called for the i'th time, it specifies the parameters for the i'th particle. For calculating the Lennard-Jones interaction between two particles, the arithmetic mean of the sigmas and the geometric mean of the epsilons for the two interacting particles is used (the Lorentz-Berthelot combining rule).
           Parameters:
            - charge the charge of the particle, measured in units of the proton charge
            - sigma the sigma parameter of the Lennard-Jones potential (corresponding to the van der Waals radius of the particle), measured in nm
            - epsilon the epsilon parameter of the Lennard-Jones potential (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_addParticle(self, *args)


    def getParticleParameters(self, *args):
        """
        getParticleParameters(NonbondedForce self, int index)

        Get the nonbonded force parameters for a particle.
           Parameters:
            - index the index of the particle for which to get parameters
            - charge the charge of the particle, measured in units of the proton charge
            - sigma the sigma parameter of the Lennard-Jones potential (corresponding to the van der Waals radius of the particle), measured in nm
            - epsilon the epsilon parameter of the Lennard-Jones potential (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.NonbondedForce_getParticleParameters(self, *args)

        val[0]=unit.Quantity(val[0], unit.elementary_charge)
        val[1]=unit.Quantity(val[1], unit.nanometer)
        val[2]=unit.Quantity(val[2], unit.kilojoule_per_mole)


        return val


    def setParticleParameters(self, *args):
        """
        setParticleParameters(NonbondedForce self, int index, double charge, double sigma, double epsilon)

        Set the nonbonded force parameters for a particle. When calculating the Lennard-Jones interaction between two particles, it uses the arithmetic mean of the sigmas and the geometric mean of the epsilons for the two interacting particles (the Lorentz-Berthelot combining rule).
           Parameters:
            - index the index of the particle for which to set parameters
            - charge the charge of the particle, measured in units of the proton charge
            - sigma the sigma parameter of the Lennard-Jones potential (corresponding to the van der Waals radius of the particle), measured in nm
            - epsilon the epsilon parameter of the Lennard-Jones potential (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_setParticleParameters(self, *args)


    def addException(self, *args):
        """
        addException(NonbondedForce self, int particle1, int particle2, double chargeProd, double sigma, double epsilon, bool replace=False) -> int

        Add an interaction to the list of exceptions that should be calculated differently from other interactions. If chargeProd and epsilon are both equal to 0, this will cause the interaction to be completely omitted from force and energy calculations.

        In many cases, you can use createExceptionsFromBonds() rather than adding each exception explicitly.
           Parameters:
            - particle1 the index of the first particle involved in the interaction
            - particle2 the index of the second particle involved in the interaction
            - chargeProd the scaled product of the atomic charges (i.e. the strength of the Coulomb interaction), measured in units of the proton charge squared
            - sigma the sigma parameter of the Lennard-Jones potential (corresponding to the van der Waals radius of the particle), measured in nm
            - epsilon the epsilon parameter of the Lennard-Jones potential (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol
            - replace determines the behavior if there is already an exception for the same two particles. If true, the existing one is replaced. If false, an exception is thrown.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_addException(self, *args)


    def getExceptionParameters(self, *args):
        """
        getExceptionParameters(NonbondedForce self, int index)

        Get the force field parameters for an interaction that should be calculated differently from others.
           Parameters:
            - index the index of the interaction for which to get parameters
            - particle1 the index of the first particle involved in the interaction
            - particle2 the index of the second particle involved in the interaction
            - chargeProd the scaled product of the atomic charges (i.e. the strength of the Coulomb interaction), measured in units of the proton charge squared
            - sigma the sigma parameter of the Lennard-Jones potential (corresponding to the van der Waals radius of the particle), measured in nm
            - epsilon the epsilon parameter of the Lennard-Jones potential (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.NonbondedForce_getExceptionParameters(self, *args)

        val[2]=unit.Quantity(val[2], unit.elementary_charge*unit.elementary_charge)
        val[3]=unit.Quantity(val[3], unit.nanometer)
        val[4]=unit.Quantity(val[4], unit.kilojoule_per_mole)


        return val


    def setExceptionParameters(self, *args):
        """
        setExceptionParameters(NonbondedForce self, int index, int particle1, int particle2, double chargeProd, double sigma, double epsilon)

        Set the force field parameters for an interaction that should be calculated differently from others. If chargeProd and epsilon are both equal to 0, this will cause the interaction to be completely omitted from force and energy calculations.
           Parameters:
            - index the index of the interaction for which to get parameters
            - particle1 the index of the first particle involved in the interaction
            - particle2 the index of the second particle involved in the interaction
            - chargeProd the scaled product of the atomic charges (i.e. the strength of the Coulomb interaction), measured in units of the proton charge squared
            - sigma the sigma parameter of the Lennard-Jones potential (corresponding to the van der Waals radius of the particle), measured in nm
            - epsilon the epsilon parameter of the Lennard-Jones potential (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_setExceptionParameters(self, *args)


    def createExceptionsFromBonds(self, *args):
        """
        createExceptionsFromBonds(NonbondedForce self, vectorpairii bonds, double coulomb14Scale, double lj14Scale)

        Identify exceptions based on the molecular topology. Particles which are separated by one or two bonds are set to not interact at all, while pairs of particles separated by three bonds (known as "1-4 interactions") have their Coulomb and Lennard-Jones interactions reduced by a fixed factor.
           Parameters:
            - bonds the set of bonds based on which to construct exceptions. Each element specifies the indices of two particles that are bonded to each other.
            - coulomb14Scale pairs of particles separated by three bonds will have the strength of their Coulomb interaction multiplied by this factor
            - lj14Scale pairs of particles separated by three bonds will have the strength of their Lennard-Jones interaction multiplied by this factor
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_createExceptionsFromBonds(self, *args)


    def getUseDispersionCorrection(self, *args):
        """
        getUseDispersionCorrection(NonbondedForce self) -> bool

        Get whether to add a contribution to the energy that approximately represents the effect of Lennard-Jones interactions beyond the cutoff distance. The energy depends on the volume of the periodic box, and is only applicable when periodic boundary conditions are used. When running simulations at constant pressure, adding this contribution can improve the quality of results.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_getUseDispersionCorrection(self, *args)


    def setUseDispersionCorrection(self, *args):
        """
        setUseDispersionCorrection(NonbondedForce self, bool useCorrection)

        Set whether to add a contribution to the energy that approximately represents the effect of Lennard-Jones interactions beyond the cutoff distance. The energy depends on the volume of the periodic box, and is only applicable when periodic boundary conditions are used. When running simulations at constant pressure, adding this contribution can improve the quality of results.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_setUseDispersionCorrection(self, *args)


    def getReciprocalSpaceForceGroup(self, *args):
        """
        getReciprocalSpaceForceGroup(NonbondedForce self) -> int

        Get the force group that reciprocal space interactions for Ewald or PME are included in. This allows multiple time step integrators to evaluate direct and reciprocal space interactions at different intervals: getForceGroup() specifies the group for direct space, and getReciprocalSpaceForceGroup() specifies the group for reciprocal space. If this is -1 (the default value), the same force group is used for reciprocal space as for direct space.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_getReciprocalSpaceForceGroup(self, *args)


    def setReciprocalSpaceForceGroup(self, *args):
        """
        setReciprocalSpaceForceGroup(NonbondedForce self, int group)

        Set the force group that reciprocal space interactions for Ewald or PME are included in. This allows multiple time step integrators to evaluate direct and reciprocal space interactions at different intervals: setForceGroup() specifies the group for direct space, and setReciprocalSpaceForceGroup() specifies the group for reciprocal space. If this is -1 (the default value), the same force group is used for reciprocal space as for direct space.
           Parameters:
            - group the group index. Legal values are between 0 and 31 (inclusive), or -1 to use the same force group that is specified for direct space.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_setReciprocalSpaceForceGroup(self, *args)


    def updateParametersInContext(self, *args):
        """
        updateParametersInContext(NonbondedForce self, Context context)

        Update the particle and exception parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setParticleParameters() and setExceptionParameters() to modify this object's parameters, then call updateParametersInContext() to copy them over to the Context.

        This method has several limitations. The only information it updates is the parameters of particles and exceptions. All other aspects of the Force (the nonbonded method, the cutoff distance, etc.) are unaffected and can only be changed by reinitializing the Context. Furthermore, only the chargeProd, sigma, and epsilon values of an exception can be changed; the pair of particles involved in the exception cannot change. Finally, this method cannot be used to add new particles or exceptions, only to change the parameters of existing ones.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_updateParametersInContext(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(NonbondedForce self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.NonbondedForce_usesPeriodicBoundaryConditions(self, *args)


    def addParticle_usingRVdw(self, charge, rVDW, epsilon):
        """Add particle using elemetrary charge.  Rvdw and epsilon,
           which is consistent with AMBER parameter file usage.
           Note that the sum of the radii of the two interacting atoms is
           the minimum energy point in the Lennard Jones potential and
           is often called rMin.  The conversion from sigma follows:
           rVDW = 2^1/6 * sigma/2
        """
        return self.addParticle(charge, rVDW/RVDW_PER_SIGMA, epsilon)

    def addException_usingRMin(self, particle1, particle2,
                               chargeProd, rMin, epsilon):
        """Add interaction exception using the product of the two atoms'
           elementary charges, rMin and epsilon, which is standard for AMBER
           force fields.  Note that rMin is the minimum energy point in the
           Lennard Jones potential.  The conversion from sigma is:
           rMin = 2^1/6 * sigma.
        """
        return self.addException(particle1, particle2,
                                 chargeProd, rMin/RMIN_PER_SIGMA, epsilon)


    def __init__(self, *args):
        """
        __init__(OpenMM::NonbondedForce self) -> NonbondedForce
        __init__(OpenMM::NonbondedForce self, NonbondedForce other) -> NonbondedForce

        Create a NonbondedForce.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_NonbondedForce(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_NonbondedForce
    def __del__(self):
        """__del__(OpenMM::NonbondedForce self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

NonbondedForce_swigregister = _openmm.NonbondedForce_swigregister
NonbondedForce_swigregister(NonbondedForce)

class AmoebaGeneralizedKirkwoodForce(Force):
    """
    This class implements an implicit solvation force using the generalized Kirkwood/Grycuk model. 

    To use this class, create an AmoebaGeneralizedKirkwoodForce object, then call addParticle() once for each particle in the System to define its parameters. The number of particles for which you define parameters must be equal to the number of particles in the System, or else an exception will be thrown when you try to create a Context. After a particle has been added, you can modify its force field parameters by calling setParticleParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext().
    """
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AmoebaGeneralizedKirkwoodForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AmoebaGeneralizedKirkwoodForce, name)
    __repr__ = _swig_repr

    def getNumParticles(self, *args):
        """
        getNumParticles(AmoebaGeneralizedKirkwoodForce self) -> int

        Get the number of particles in the system.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaGeneralizedKirkwoodForce_getNumParticles(self, *args)


    def addParticle(self, *args):
        """
        addParticle(AmoebaGeneralizedKirkwoodForce self, double charge, double radius, double scalingFactor) -> int

        Add the parameters for a particle. This should be called once for each particle in the System. When it is called for the i'th time, it specifies the parameters for the i'th particle.
           Parameters:
            - charge the charge of the particle, measured in units of the proton charge
            - radius the atomic radius of the particle, measured in nm
            - scalingFactor the scaling factor for the particle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaGeneralizedKirkwoodForce_addParticle(self, *args)


    def getParticleParameters(self, *args):
        """
        getParticleParameters(AmoebaGeneralizedKirkwoodForce self, int index)

        Get the force field parameters for a particle.
           Parameters:
            - index the index of the particle for which to get parameters
            - charge the charge of the particle, measured in units of the proton charge
            - radius the atomic radius of the particle, measured in nm
            - scalingFactor the scaling factor for the particle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaGeneralizedKirkwoodForce_getParticleParameters(self, *args)

        val[0]=unit.Quantity(val[0], unit.elementary_charge)
        val[1]=unit.Quantity(val[1], unit.nanometer)


        return val


    def setParticleParameters(self, *args):
        """
        setParticleParameters(AmoebaGeneralizedKirkwoodForce self, int index, double charge, double radius, double scalingFactor)

        Set the force field parameters for a particle.
           Parameters:
            - index the index of the particle for which to set parameters
            - charge the charge of the particle, measured in units of the proton charge
            - radius the atomic radius of the particle, measured in nm
            - scalingFactor the scaling factor for the particle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaGeneralizedKirkwoodForce_setParticleParameters(self, *args)


    def getSolventDielectric(self, *args):
        """
        getSolventDielectric(AmoebaGeneralizedKirkwoodForce self) -> double

        Get the dielectric constant for the solvent.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaGeneralizedKirkwoodForce_getSolventDielectric(self, *args)


    def setSolventDielectric(self, *args):
        """
        setSolventDielectric(AmoebaGeneralizedKirkwoodForce self, double dielectric)

        Set the dielectric constant for the solvent.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaGeneralizedKirkwoodForce_setSolventDielectric(self, *args)


    def getSoluteDielectric(self, *args):
        """
        getSoluteDielectric(AmoebaGeneralizedKirkwoodForce self) -> double

        Get the dielectric constant for the solute.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaGeneralizedKirkwoodForce_getSoluteDielectric(self, *args)


    def setSoluteDielectric(self, *args):
        """
        setSoluteDielectric(AmoebaGeneralizedKirkwoodForce self, double dielectric)

        Set the dielectric constant for the solute.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaGeneralizedKirkwoodForce_setSoluteDielectric(self, *args)


    def getIncludeCavityTerm(self, *args):
        """
        getIncludeCavityTerm(AmoebaGeneralizedKirkwoodForce self) -> int

        Get the flag signaling whether the cavity term should be included
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaGeneralizedKirkwoodForce_getIncludeCavityTerm(self, *args)


    def setIncludeCavityTerm(self, *args):
        """
        setIncludeCavityTerm(AmoebaGeneralizedKirkwoodForce self, int includeCavityTerm)

        Set the flag signaling whether the cavity term should be included
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaGeneralizedKirkwoodForce_setIncludeCavityTerm(self, *args)


    def getProbeRadius(self, *args):
        """
        getProbeRadius(AmoebaGeneralizedKirkwoodForce self) -> double

        Get the probe radius (nm) used in SASA contribution
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaGeneralizedKirkwoodForce_getProbeRadius(self, *args)

        val=unit.Quantity(val, unit.nanometer)


        return val


    def setProbeRadius(self, *args):
        """
        setProbeRadius(AmoebaGeneralizedKirkwoodForce self, double probeRadius)

        Set the probe radius (nm) used in SASA contribution
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaGeneralizedKirkwoodForce_setProbeRadius(self, *args)


    def getSurfaceAreaFactor(self, *args):
        """
        getSurfaceAreaFactor(AmoebaGeneralizedKirkwoodForce self) -> double

        Get the surface area factor kJ/(nm*nm) used in SASA contribution
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaGeneralizedKirkwoodForce_getSurfaceAreaFactor(self, *args)

        val=unit.Quantity(val, (unit.nanometer*unit.nanometer)/unit.kilojoule_per_mole)


        return val


    def setSurfaceAreaFactor(self, *args):
        """
        setSurfaceAreaFactor(AmoebaGeneralizedKirkwoodForce self, double surfaceAreaFactor)

        Set the surface area factor kJ/(nm*nm) used in SASA contribution
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaGeneralizedKirkwoodForce_setSurfaceAreaFactor(self, *args)


    def updateParametersInContext(self, *args):
        """
        updateParametersInContext(AmoebaGeneralizedKirkwoodForce self, Context context)

        Update the per-particle parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setParticleParameters() to modify this object's parameters, then call updateParametersInContext() to copy them over to the Context.

        The only information this method updates is the values of per-particle parameters. All other aspects of the Force (the probe radius, the surface area factor, etc.) are unaffected and can only be changed by reinitializing the Context.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaGeneralizedKirkwoodForce_updateParametersInContext(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(AmoebaGeneralizedKirkwoodForce self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaGeneralizedKirkwoodForce_usesPeriodicBoundaryConditions(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::AmoebaGeneralizedKirkwoodForce self) -> AmoebaGeneralizedKirkwoodForce
        __init__(OpenMM::AmoebaGeneralizedKirkwoodForce self, AmoebaGeneralizedKirkwoodForce other) -> AmoebaGeneralizedKirkwoodForce

        This class implements an implicit solvation force using the generalized Kirkwood/Grycuk model. 

        To use this class, create an AmoebaGeneralizedKirkwoodForce object, then call addParticle() once for each particle in the System to define its parameters. The number of particles for which you define parameters must be equal to the number of particles in the System, or else an exception will be thrown when you try to create a Context. After a particle has been added, you can modify its force field parameters by calling setParticleParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext().
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_AmoebaGeneralizedKirkwoodForce(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_AmoebaGeneralizedKirkwoodForce
    def __del__(self):
        """__del__(OpenMM::AmoebaGeneralizedKirkwoodForce self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

AmoebaGeneralizedKirkwoodForce_swigregister = _openmm.AmoebaGeneralizedKirkwoodForce_swigregister
AmoebaGeneralizedKirkwoodForce_swigregister(AmoebaGeneralizedKirkwoodForce)

class Discrete1DFunction(TabulatedFunction):
    """This is a TabulatedFunction that computes a discrete one dimensional function f(x). To evaluate it, x is rounded to the nearest integer and the table element with that index is returned. If the index is outside the range [0, size), the result is undefined."""
    __swig_setmethods__ = {}
    for _s in [TabulatedFunction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Discrete1DFunction, name, value)
    __swig_getmethods__ = {}
    for _s in [TabulatedFunction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Discrete1DFunction, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OpenMM::Discrete1DFunction self, vectord values) -> Discrete1DFunction

        This is a TabulatedFunction that computes a discrete one dimensional function f(x). To evaluate it, x is rounded to the nearest integer and the table element with that index is returned. If the index is outside the range [0, size), the result is undefined.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_Discrete1DFunction(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def getFunctionParameters(self, *args):
        """getFunctionParameters(Discrete1DFunction self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Discrete1DFunction_getFunctionParameters(self, *args)


    def setFunctionParameters(self, *args):
        """setFunctionParameters(Discrete1DFunction self, vectord values)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Discrete1DFunction_setFunctionParameters(self, *args)


    def Copy(self, *args):
        """Copy(Discrete1DFunction self) -> Discrete1DFunction"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Discrete1DFunction_Copy(self, *args)

    __swig_destroy__ = _openmm.delete_Discrete1DFunction
    def __del__(self):
        """__del__(OpenMM::Discrete1DFunction self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

Discrete1DFunction_swigregister = _openmm.Discrete1DFunction_swigregister
Discrete1DFunction_swigregister(Discrete1DFunction)

class Continuous1DFunction(TabulatedFunction):
    """This is a TabulatedFunction that computes a continuous one dimensional function."""
    __swig_setmethods__ = {}
    for _s in [TabulatedFunction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Continuous1DFunction, name, value)
    __swig_getmethods__ = {}
    for _s in [TabulatedFunction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Continuous1DFunction, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OpenMM::Continuous1DFunction self, vectord values, double min, double max) -> Continuous1DFunction

        This is a TabulatedFunction that computes a continuous one dimensional function.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_Continuous1DFunction(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def getFunctionParameters(self, *args):
        """getFunctionParameters(Continuous1DFunction self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Continuous1DFunction_getFunctionParameters(self, *args)


    def setFunctionParameters(self, *args):
        """setFunctionParameters(Continuous1DFunction self, vectord values, double min, double max)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Continuous1DFunction_setFunctionParameters(self, *args)


    def Copy(self, *args):
        """Copy(Continuous1DFunction self) -> Continuous1DFunction"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Continuous1DFunction_Copy(self, *args)

    __swig_destroy__ = _openmm.delete_Continuous1DFunction
    def __del__(self):
        """__del__(OpenMM::Continuous1DFunction self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

Continuous1DFunction_swigregister = _openmm.Continuous1DFunction_swigregister
Continuous1DFunction_swigregister(Continuous1DFunction)

class BrownianIntegrator(Integrator):
    """This is an Integrator which simulates a System using Brownian dynamics."""
    __swig_setmethods__ = {}
    for _s in [Integrator]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BrownianIntegrator, name, value)
    __swig_getmethods__ = {}
    for _s in [Integrator]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BrownianIntegrator, name)
    __repr__ = _swig_repr

    def getTemperature(self, *args):
        """
        getTemperature(BrownianIntegrator self) -> double

        Get the temperature of the heat bath (in Kelvin).
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.BrownianIntegrator_getTemperature(self, *args)

        val=unit.Quantity(val, unit.kelvin)


        return val


    def setTemperature(self, *args):
        """
        setTemperature(BrownianIntegrator self, double temp)

        Set the temperature of the heat bath (in Kelvin).
           Parameters:
            - temp the temperature of the heat bath, measured in Kelvin.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.BrownianIntegrator_setTemperature(self, *args)


    def getFriction(self, *args):
        """
        getFriction(BrownianIntegrator self) -> double

        Get the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps).
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.BrownianIntegrator_getFriction(self, *args)

        val=unit.Quantity(val, 1/unit.picosecond)


        return val


    def setFriction(self, *args):
        """
        setFriction(BrownianIntegrator self, double coeff)

        Set the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps).
           Parameters:
            - coeff the friction coefficient, measured in 1/ps
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.BrownianIntegrator_setFriction(self, *args)


    def getRandomNumberSeed(self, *args):
        """
        getRandomNumberSeed(BrownianIntegrator self) -> int

        Get the random number seed. See setRandomNumberSeed() for details.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.BrownianIntegrator_getRandomNumberSeed(self, *args)


    def setRandomNumberSeed(self, *args):
        """
        setRandomNumberSeed(BrownianIntegrator self, int seed)

        Set the random number seed. The precise meaning of this parameter is undefined, and is left up to each Platform to interpret in an appropriate way. It is guaranteed that if two simulations are run with different random number seeds, the sequence of random forces will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically.

        If seed is set to 0 (which is the default value assigned), a unique seed is chosen when a Context is created from this Force. This is done to ensure that each Context receives unique random seeds without you needing to set them explicitly.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.BrownianIntegrator_setRandomNumberSeed(self, *args)


    def step(self, *args):
        """
        step(BrownianIntegrator self, int steps)

        Advance a simulation through time by taking a series of time steps.
           Parameters:
            - steps the number of time steps to take
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.BrownianIntegrator_step(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::BrownianIntegrator self, double temperature, double frictionCoeff, double stepSize) -> BrownianIntegrator
        __init__(OpenMM::BrownianIntegrator self, BrownianIntegrator other) -> BrownianIntegrator

        Create a BrownianIntegrator.
           Parameters:
            - temperature the temperature of the heat bath (in Kelvin)
            - frictionCoeff the friction coefficient which couples the system to the heat bath, measured in 1/ps
            - stepSize the step size with which to integrate the system (in picoseconds)
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_BrownianIntegrator(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_BrownianIntegrator
    def __del__(self):
        """__del__(OpenMM::BrownianIntegrator self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

BrownianIntegrator_swigregister = _openmm.BrownianIntegrator_swigregister
BrownianIntegrator_swigregister(BrownianIntegrator)

class OpenMMException(_object):
    """This class is used for all exceptions thrown by OpenMM."""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OpenMMException, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OpenMMException, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _openmm.delete_OpenMMException
    def __del__(self):
        """__del__(OpenMM::OpenMMException self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass


    def what(self, *args):
        """what(OpenMMException self) -> char const *"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.OpenMMException_what(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::OpenMMException self, std::string const & message) -> OpenMMException
        __init__(OpenMM::OpenMMException self, OpenMMException other) -> OpenMMException

        This class is used for all exceptions thrown by OpenMM.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_OpenMMException(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
OpenMMException_swigregister = _openmm.OpenMMException_swigregister
OpenMMException_swigregister(OpenMMException)

class LocalCoordinatesSite(VirtualSite):
    """
    This is a VirtualSite that uses the locations of three other particles to compute a local coordinate system, then places the virtual site at a fixed location in that coordinate system. The origin of the coordinate system and the directions of its x and y axes are each specified as a weighted sum of the locations of the three particles:

    origin = w<sub>1</sub>r<sub>1</sub> + w<sub>2</sub>r<sub>2</sub> + w<sub>3</sub>r<sub>3</sub>

    xdir = w<sub>1</sub>r<sub>1</sub> + w<sub>2</sub>r<sub>2</sub> + w<sub>3</sub>r<sub>3</sub>

    ydir = w<sub>1</sub>r<sub>1</sub> + w<sub>2</sub>r<sub>2</sub> + w<sub>3</sub>r<sub>3</sub>

    For the origin, the three weights must add to one. For example if (w<sub>1</sub>, w<sub>2</sub>, w<sub>3</sub>) = (1.0, 0.0, 0.0), the origin of the local coordinate system is at the location of particle 1. For xdir and ydir, the weights must add to zero. For excample, if (w<sub>1</sub>, w<sub>2</sub>, w<sub>3</sub>) = (-1.0, 0.5, 0.5), the x axis points from particle 1 toward the midpoint between particles 2 and 3.

    The z direction is computed as zdir = xdir x ydir. To ensure the axes are all orthogonal, ydir is then recomputed as ydir = zdir x xdir. All three axis vectors are then normalized, and the virtual site location is set to

    origin + x*xdir + y*ydir + z*zdir
    """
    __swig_setmethods__ = {}
    for _s in [VirtualSite]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LocalCoordinatesSite, name, value)
    __swig_getmethods__ = {}
    for _s in [VirtualSite]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LocalCoordinatesSite, name)
    __repr__ = _swig_repr

    def getOriginWeights(self, *args):
        """
        getOriginWeights(LocalCoordinatesSite self) -> Vec3 const &

        Get the weight factors for the three particles when computing the origin location.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.LocalCoordinatesSite_getOriginWeights(self, *args)


    def getXWeights(self, *args):
        """
        getXWeights(LocalCoordinatesSite self) -> Vec3 const &

        Get the weight factors for the three particles when computing xdir.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.LocalCoordinatesSite_getXWeights(self, *args)


    def getYWeights(self, *args):
        """
        getYWeights(LocalCoordinatesSite self) -> Vec3 const &

        Get the weight factors for the three particles when computing ydir.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.LocalCoordinatesSite_getYWeights(self, *args)


    def getLocalPosition(self, *args):
        """
        getLocalPosition(LocalCoordinatesSite self) -> Vec3 const &

        Get the position of the virtual site in the local coordinate system.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.LocalCoordinatesSite_getLocalPosition(self, *args)

        val=unit.Quantity(val, unit.nanometer)


        return val


    def __init__(self, *args):
        """
        __init__(OpenMM::LocalCoordinatesSite self, int particle1, int particle2, int particle3, Vec3 const & originWeights, Vec3 const & xWeights, Vec3 const & yWeights, Vec3 const & localPosition) -> LocalCoordinatesSite
        __init__(OpenMM::LocalCoordinatesSite self, LocalCoordinatesSite other) -> LocalCoordinatesSite

        Create a new LocalCoordinatesSite virtual site.
           Parameters:
            - particle1 the index of the first particle
            - particle2 the index of the second particle
            - particle3 the index of the third particle
            - originWeights the weight factors for the three particles when computing the origin location
            - xWeights the weight factors for the three particles when computing xdir
            - yWeights the weight factors for the three particles when computing ydir
            - localPosition the position of the virtual site in the local coordinate system
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_LocalCoordinatesSite(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_LocalCoordinatesSite
    def __del__(self):
        """__del__(OpenMM::LocalCoordinatesSite self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

LocalCoordinatesSite_swigregister = _openmm.LocalCoordinatesSite_swigregister
LocalCoordinatesSite_swigregister(LocalCoordinatesSite)

class RBTorsionForce(Force):
    """This class implements an interaction between groups of four particles that varies with the torsion angle between them according to the Ryckaert-Bellemans potential. To use it, create an RBTorsionForce object then call addTorsion() once for each torsion. After a torsion has been added, you can modify its force field parameters by calling setTorsionParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext()."""
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RBTorsionForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RBTorsionForce, name)
    __repr__ = _swig_repr

    def getNumTorsions(self, *args):
        """
        getNumTorsions(RBTorsionForce self) -> int

        Get the number of Ryckaert-Bellemans torsion terms in the potential function
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.RBTorsionForce_getNumTorsions(self, *args)


    def addTorsion(self, *args):
        """
        addTorsion(RBTorsionForce self, int particle1, int particle2, int particle3, int particle4, double c0, double c1, double c2, double c3, double c4, double c5) -> int

        Add a Ryckaert-Bellemans torsion term to the force field.
           Parameters:
            - particle1 the index of the first particle forming the torsion
            - particle2 the index of the second particle forming the torsion
            - particle3 the index of the third particle forming the torsion
            - particle4 the index of the fourth particle forming the torsion
            - c0 the coefficient of the constant term, measured in kJ/mol
            - c1 the coefficient of the 1st order term, measured in kJ/mol
            - c2 the coefficient of the 2nd order term, measured in kJ/mol
            - c3 the coefficient of the 3rd order term, measured in kJ/mol
            - c4 the coefficient of the 4th order term, measured in kJ/mol
            - c5 the coefficient of the 5th order term, measured in kJ/mol
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.RBTorsionForce_addTorsion(self, *args)


    def getTorsionParameters(self, *args):
        """
        getTorsionParameters(RBTorsionForce self, int index)

        Get the force field parameters for a Ryckaert-Bellemans torsion term.
           Parameters:
            - index the index of the torsion for which to get parameters
            - particle1 the index of the first particle forming the torsion
            - particle2 the index of the second particle forming the torsion
            - particle3 the index of the third particle forming the torsion
            - particle4 the index of the fourth particle forming the torsion
            - c0 the coefficient of the constant term, measured in kJ/mol
            - c1 the coefficient of the 1st order term, measured in kJ/mol
            - c2 the coefficient of the 2nd order term, measured in kJ/mol
            - c3 the coefficient of the 3rd order term, measured in kJ/mol
            - c4 the coefficient of the 4th order term, measured in kJ/mol
            - c5 the coefficient of the 5th order term, measured in kJ/mol
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.RBTorsionForce_getTorsionParameters(self, *args)

        val[4]=unit.Quantity(val[4], unit.kilojoules_per_mole)
        val[5]=unit.Quantity(val[5], unit.kilojoules_per_mole)
        val[6]=unit.Quantity(val[6], unit.kilojoules_per_mole)
        val[7]=unit.Quantity(val[7], unit.kilojoules_per_mole)
        val[8]=unit.Quantity(val[8], unit.kilojoules_per_mole)
        val[9]=unit.Quantity(val[9], unit.kilojoules_per_mole)


        return val


    def setTorsionParameters(self, *args):
        """
        setTorsionParameters(RBTorsionForce self, int index, int particle1, int particle2, int particle3, int particle4, double c0, double c1, double c2, double c3, double c4, double c5)

        Set the force field parameters for a Ryckaert-Bellemans torsion term.
           Parameters:
            - index the index of the torsion for which to set parameters
            - particle1 the index of the first particle forming the torsion
            - particle2 the index of the second particle forming the torsion
            - particle3 the index of the third particle forming the torsion
            - particle4 the index of the fourth particle forming the torsion
            - c0 the coefficient of the constant term, measured in kJ/mol
            - c1 the coefficient of the 1st order term, measured in kJ/mol
            - c2 the coefficient of the 2nd order term, measured in kJ/mol
            - c3 the coefficient of the 3rd order term, measured in kJ/mol
            - c4 the coefficient of the 4th order term, measured in kJ/mol
            - c5 the coefficient of the 5th order term, measured in kJ/mol
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.RBTorsionForce_setTorsionParameters(self, *args)


    def updateParametersInContext(self, *args):
        """
        updateParametersInContext(RBTorsionForce self, Context context)

        Update the per-torsion parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setTorsionParameters() to modify this object's parameters, then call updateParametersInContext() to copy them over to the Context.

        The only information this method updates is the values of per-torsion parameters. The set of particles involved in a torsion cannot be changed, nor can new torsions be added.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.RBTorsionForce_updateParametersInContext(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(RBTorsionForce self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.RBTorsionForce_usesPeriodicBoundaryConditions(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::RBTorsionForce self) -> RBTorsionForce
        __init__(OpenMM::RBTorsionForce self, RBTorsionForce other) -> RBTorsionForce

        Create a RBTorsionForce.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_RBTorsionForce(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_RBTorsionForce
    def __del__(self):
        """__del__(OpenMM::RBTorsionForce self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

RBTorsionForce_swigregister = _openmm.RBTorsionForce_swigregister
RBTorsionForce_swigregister(RBTorsionForce)

class RPMDMonteCarloBarostat(Force):
    """This class is very similar to MonteCarloBarostat, but it is specifically designed for use with RPMDIntegrator. For each trial move, it scales all copies of the system by the same amount, then accepts or rejects the move based on the change to the total energy of the ring polymer (as returned by the integrator's getTotalEnergy() method)."""
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RPMDMonteCarloBarostat, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RPMDMonteCarloBarostat, name)
    __repr__ = _swig_repr

    def Pressure(*args):
        """
        Pressure() -> std::string const &

        This is the name of the parameter which stores the current pressure acting on the system (in bar).
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.RPMDMonteCarloBarostat_Pressure(*args)

    if _newclass:
        Pressure = staticmethod(Pressure)
    __swig_getmethods__["Pressure"] = lambda x: Pressure

    def getDefaultPressure(self, *args):
        """
        getDefaultPressure(RPMDMonteCarloBarostat self) -> double

        Get the default pressure acting on the system (in bar).
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.RPMDMonteCarloBarostat_getDefaultPressure(self, *args)

        val=unit.Quantity(val, unit.bar)


        return val


    def setDefaultPressure(self, *args):
        """
        setDefaultPressure(RPMDMonteCarloBarostat self, double pressure)

        Set the default pressure acting on the system. This will affect any new Contexts you create, but not ones that already exist.
           Parameters:
            - pressure the default pressure acting on the system, measured in bar.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.RPMDMonteCarloBarostat_setDefaultPressure(self, *args)


    def getFrequency(self, *args):
        """
        getFrequency(RPMDMonteCarloBarostat self) -> int

        Get the frequency (in time steps) at which Monte Carlo pressure changes should be attempted. If this is set to 0, the barostat is disabled.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.RPMDMonteCarloBarostat_getFrequency(self, *args)


    def setFrequency(self, *args):
        """
        setFrequency(RPMDMonteCarloBarostat self, int freq)

        Set the frequency (in time steps) at which Monte Carlo pressure changes should be attempted. If this is set to 0, the barostat is disabled.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.RPMDMonteCarloBarostat_setFrequency(self, *args)


    def getRandomNumberSeed(self, *args):
        """
        getRandomNumberSeed(RPMDMonteCarloBarostat self) -> int

        Get the random number seed. See setRandomNumberSeed() for details.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.RPMDMonteCarloBarostat_getRandomNumberSeed(self, *args)


    def setRandomNumberSeed(self, *args):
        """
        setRandomNumberSeed(RPMDMonteCarloBarostat self, int seed)

        Set the random number seed. It is guaranteed that if two simulations are run with different random number seeds, the sequence of Monte Carlo steps will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically.

        If seed is set to 0 (which is the default value assigned), a unique seed is chosen when a Context is created from this Force. This is done to ensure that each Context receives unique random seeds without you needing to set them explicitly.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.RPMDMonteCarloBarostat_setRandomNumberSeed(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(RPMDMonteCarloBarostat self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.RPMDMonteCarloBarostat_usesPeriodicBoundaryConditions(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::RPMDMonteCarloBarostat self, double defaultPressure, int frequency=25) -> RPMDMonteCarloBarostat
        __init__(OpenMM::RPMDMonteCarloBarostat self, RPMDMonteCarloBarostat other) -> RPMDMonteCarloBarostat

        Create a MonteCarloBarostat.
           Parameters:
            - defaultPressure the default pressure acting on the system (in bar)
            - frequency the frequency at which Monte Carlo pressure changes should be attempted (in time steps)
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_RPMDMonteCarloBarostat(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_RPMDMonteCarloBarostat
    def __del__(self):
        """__del__(OpenMM::RPMDMonteCarloBarostat self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

RPMDMonteCarloBarostat_swigregister = _openmm.RPMDMonteCarloBarostat_swigregister
RPMDMonteCarloBarostat_swigregister(RPMDMonteCarloBarostat)

def RPMDMonteCarloBarostat_Pressure(*args):
    """
    RPMDMonteCarloBarostat_Pressure() -> std::string const &

    This is the name of the parameter which stores the current pressure acting on the system (in bar).
    """

    try: args=stripUnits(args)
    except UnboundLocalError: pass


    return _openmm.RPMDMonteCarloBarostat_Pressure(*args)

class SerializationNode(_object):
    """
    A SerializationNode stores information about an object during serialization or deserialization.

    When an object is serialized, its SerializationProxy is first called to copy information about the object into a SerializationNode. That information can then be written to the output stream in the desired format.

    When an object is deserialized, the input stream is read and the information is stored into a SerializationNode. The appropriate SerializationProxy is then called to reconstruct the object.

    SerializationNodes are arranged in a tree. There will often be a one-to-one correspondence between objects and SerializationNodes, but that need not always be true. A proxy is free to create whatever child nodes it wants and store information in them using whatever organization is most convenient.

    Each SerializationNode can store an arbitrary set of "properties", represented as key-value pairs. The key is always a string, while the value may be a string, an int, or a double. If a value is specified using one data type and then accessed as a different data type, the node will attempt to convert the value in an appropriate way. For example, it is always reasonable to call getStringProperty() to access a property as a string. Similarly, you can use setStringProperty() to specify a property and then access it using getIntProperty(). This will produce the expected result if the original value was, in fact, the string representation of an int, but if the original string was non-numeric, the result is undefined.
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SerializationNode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SerializationNode, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getName(self, *args):
        """
        getName(SerializationNode self) -> std::string const &

        Get the name of this SerializationNode.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationNode_getName(self, *args)


    def setName(self, *args):
        """
        setName(SerializationNode self, std::string const & name)

        Set the name of this SerializationNode.
           Parameters:
            - name the new name of the SerializationNode
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationNode_setName(self, *args)


    def getChildren(self, *args):
        """
        getChildren(SerializationNode self) -> std::vector< OpenMM::SerializationNode,std::allocator< OpenMM::SerializationNode > > const
        getChildren(SerializationNode self) -> std::vector< OpenMM::SerializationNode,std::allocator< OpenMM::SerializationNode > > &

        Get a reference to this node's child nodes.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationNode_getChildren(self, *args)


    def getChildNode(self, *args):
        """
        getChildNode(SerializationNode self, std::string const & name) -> SerializationNode
        getChildNode(SerializationNode self, std::string const & name) -> SerializationNode

        Get a reference to the child node with a particular name. If there is no child with the specified name, this throws an exception.
           Parameters:
            - the name of the child node to get
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationNode_getChildNode(self, *args)


    def getProperties(self, *args):
        """
        getProperties(SerializationNode self) -> mapstringstring

        Get a map containing all of this node's properties.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationNode_getProperties(self, *args)


    def hasProperty(self, *args):
        """
        hasProperty(SerializationNode self, std::string const & name) -> bool

        Determine whether this node has a property with a particular node.
           Parameters:
            - the name of the property to check for
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationNode_hasProperty(self, *args)


    def getStringProperty(self, *args):
        """
        getStringProperty(SerializationNode self, std::string const & name) -> std::string const
        getStringProperty(SerializationNode self, std::string const & name, std::string const & defaultValue) -> std::string const &

        Get the property with a particular name, specified as a string. If there is no property with the specified name, a default value is returned instead.
           Parameters:
            - name the name of the property to get
            - defaultValue the value to return if the specified property does not exist
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationNode_getStringProperty(self, *args)


    def setStringProperty(self, *args):
        """
        setStringProperty(SerializationNode self, std::string const & name, std::string const & value) -> SerializationNode

        Set the value of a property, specified as a string.
           Parameters:
            - name the name of the property to set
            - value the value to set for the property
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationNode_setStringProperty(self, *args)


    def getIntProperty(self, *args):
        """
        getIntProperty(SerializationNode self, std::string const & name) -> int
        getIntProperty(SerializationNode self, std::string const & name, int defaultValue) -> int

        Get the property with a particular name, specified as an int. If there is no property with the specified name, a default value is returned instead.
           Parameters:
            - name the name of the property to get
            - defaultValue the value to return if the specified property does not exist
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationNode_getIntProperty(self, *args)


    def setIntProperty(self, *args):
        """
        setIntProperty(SerializationNode self, std::string const & name, int value) -> SerializationNode

        Set the value of a property, specified as an int.
           Parameters:
            - name the name of the property to set
            - value the value to set for the property
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationNode_setIntProperty(self, *args)


    def getBoolProperty(self, *args):
        """
        getBoolProperty(SerializationNode self, std::string const & name) -> bool
        getBoolProperty(SerializationNode self, std::string const & name, bool defaultValue) -> bool

        Get the property with a particular name, specified as a bool. If there is no property with the specified name, a default value is returned instead.
           Parameters:
            - name the name of the property to get
            - defaultValue the value to return if the specified property does not exist
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationNode_getBoolProperty(self, *args)


    def setBoolProperty(self, *args):
        """
        setBoolProperty(SerializationNode self, std::string const & name, bool value) -> SerializationNode

        Set the value of a property, specified as a bool.
           Parameters:
            - name the name of the property to set
            - value the value to set for the property
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationNode_setBoolProperty(self, *args)


    def getDoubleProperty(self, *args):
        """
        getDoubleProperty(SerializationNode self, std::string const & name) -> double
        getDoubleProperty(SerializationNode self, std::string const & name, double defaultValue) -> double

        Get the property with a particular name, specified as a double. If there is no property with the specified name, a default value is returned instead.
           Parameters:
            - name the name of the property to get
            - defaultValue the value to return if the specified property does not exist
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationNode_getDoubleProperty(self, *args)


    def setDoubleProperty(self, *args):
        """
        setDoubleProperty(SerializationNode self, std::string const & name, double value) -> SerializationNode

        Set the value of a property, specified as a double.
           Parameters:
            - name the name of the property to set
            - value the value to set for the property
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationNode_setDoubleProperty(self, *args)


    def createChildNode(self, *args):
        """
        createChildNode(SerializationNode self, std::string const & name) -> SerializationNode

        Create a new child node by serializing an object. A SerializationProxy is automatically selected based on the object's type, then invoked to populate the newly created node.

        Note that, while this method is templatized based on the type of object being serialized, the typeid() operator is used to select the proxy. This means the template argument may be a base class, and the correct proxies will still be selected for objects of different subclasses.
           Parameters:
            - name the name of the new node to create
            - object a pointer to the object to serialize
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationNode_createChildNode(self, *args)

    __swig_destroy__ = _openmm.delete_SerializationNode
    def __del__(self):
        """__del__(OpenMM::SerializationNode self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

SerializationNode_swigregister = _openmm.SerializationNode_swigregister
SerializationNode_swigregister(SerializationNode)

class MonteCarloAnisotropicBarostat(Force):
    """
    This class uses a Monte Carlo algorithm to adjust the size of the periodic box, simulating the effect of constant pressure.

    This class is similar to MonteCarloBarostat, but each Monte Carlo move is applied to only one axis of the periodic box (unlike MonteCarloBarostat, which scales the entire box isotropically). This means that the box may change shape as well as size over the course of the simulation. It also allows you to specify a different pressure for each axis of the box, or to keep the box size fixed along certain axes while still allowing it to change along others.

    This class assumes the simulation is also being run at constant temperature, and requires you to specify the system temperature (since it affects the acceptance probability for Monte Carlo moves). It does not actually perform temperature regulation, however. You must use another mechanism along with it to maintain the temperature, such as LangevinIntegrator or AndersenThermostat.
    """
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MonteCarloAnisotropicBarostat, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MonteCarloAnisotropicBarostat, name)
    __repr__ = _swig_repr

    def PressureX(*args):
        """
        PressureX() -> std::string const &

        This is the name of the parameter which stores the current pressure acting on the X-axis (in bar).
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloAnisotropicBarostat_PressureX(*args)

    if _newclass:
        PressureX = staticmethod(PressureX)
    __swig_getmethods__["PressureX"] = lambda x: PressureX

    def PressureY(*args):
        """
        PressureY() -> std::string const &

        This is the name of the parameter which stores the current pressure acting on the Y-axis (in bar).
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloAnisotropicBarostat_PressureY(*args)

    if _newclass:
        PressureY = staticmethod(PressureY)
    __swig_getmethods__["PressureY"] = lambda x: PressureY

    def PressureZ(*args):
        """
        PressureZ() -> std::string const &

        This is the name of the parameter which stores the current pressure acting on the Z-axis (in bar).
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloAnisotropicBarostat_PressureZ(*args)

    if _newclass:
        PressureZ = staticmethod(PressureZ)
    __swig_getmethods__["PressureZ"] = lambda x: PressureZ

    def getDefaultPressure(self, *args):
        """
        getDefaultPressure(MonteCarloAnisotropicBarostat self) -> Vec3 const &

        Get the default pressure (in bar).
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.MonteCarloAnisotropicBarostat_getDefaultPressure(self, *args)

        val=unit.Quantity(val, unit.bar)


        return val


    def setDefaultPressure(self, *args):
        """
        setDefaultPressure(MonteCarloAnisotropicBarostat self, Vec3 const & pressure)

        Set the default pressure acting on the system. This will affect any new Contexts you create, but not ones that already exist.
           Parameters:
            - pressure the default pressure acting on the system, measured in bar.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloAnisotropicBarostat_setDefaultPressure(self, *args)


    def getScaleX(self, *args):
        """
        getScaleX(MonteCarloAnisotropicBarostat self) -> bool

        Get whether to allow the X dimension of the periodic box to change size.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloAnisotropicBarostat_getScaleX(self, *args)


    def getScaleY(self, *args):
        """
        getScaleY(MonteCarloAnisotropicBarostat self) -> bool

        Get whether to allow the Y dimension of the periodic box to change size.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloAnisotropicBarostat_getScaleY(self, *args)


    def getScaleZ(self, *args):
        """
        getScaleZ(MonteCarloAnisotropicBarostat self) -> bool

        Get whether to allow the Z dimension of the periodic box to change size.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloAnisotropicBarostat_getScaleZ(self, *args)


    def getFrequency(self, *args):
        """
        getFrequency(MonteCarloAnisotropicBarostat self) -> int

        Get the frequency (in time steps) at which Monte Carlo pressure changes should be attempted. If this is set to 0, the barostat is disabled.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloAnisotropicBarostat_getFrequency(self, *args)


    def setFrequency(self, *args):
        """
        setFrequency(MonteCarloAnisotropicBarostat self, int freq)

        Set the frequency (in time steps) at which Monte Carlo pressure changes should be attempted. If this is set to 0, the barostat is disabled.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloAnisotropicBarostat_setFrequency(self, *args)


    def getTemperature(self, *args):
        """
        getTemperature(MonteCarloAnisotropicBarostat self) -> double

        Get the temperature at which the system is being maintained, measured in Kelvin.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.MonteCarloAnisotropicBarostat_getTemperature(self, *args)

        val=unit.Quantity(val, unit.kelvin)


        return val


    def setTemperature(self, *args):
        """
        setTemperature(MonteCarloAnisotropicBarostat self, double temp)

        Set the temperature at which the system is being maintained.
           Parameters:
            - temp the system temperature, measured in Kelvin.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloAnisotropicBarostat_setTemperature(self, *args)


    def getRandomNumberSeed(self, *args):
        """
        getRandomNumberSeed(MonteCarloAnisotropicBarostat self) -> int

        Get the random number seed. See setRandomNumberSeed() for details.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloAnisotropicBarostat_getRandomNumberSeed(self, *args)


    def setRandomNumberSeed(self, *args):
        """
        setRandomNumberSeed(MonteCarloAnisotropicBarostat self, int seed)

        Set the random number seed. It is guaranteed that if two simulations are run with different random number seeds, the sequence of Monte Carlo steps will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically.

        If seed is set to 0 (which is the default value assigned), a unique seed is chosen when a Context is created from this Force. This is done to ensure that each Context receives unique random seeds without you needing to set them explicitly.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloAnisotropicBarostat_setRandomNumberSeed(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(MonteCarloAnisotropicBarostat self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.MonteCarloAnisotropicBarostat_usesPeriodicBoundaryConditions(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::MonteCarloAnisotropicBarostat self, Vec3 const & defaultPressure, double temperature, bool scaleX=True, bool scaleY=True, bool scaleZ=True, int frequency=25) -> MonteCarloAnisotropicBarostat
        __init__(OpenMM::MonteCarloAnisotropicBarostat self, MonteCarloAnisotropicBarostat other) -> MonteCarloAnisotropicBarostat

        Create a MonteCarloAnisotropicBarostat.
           Parameters:
            - defaultPressure The default pressure acting on each axis (in bar)
            - temperature the temperature at which the system is being maintained (in Kelvin)
            - scaleX whether to allow the X dimension of the periodic box to change size
            - scaleY whether to allow the Y dimension of the periodic box to change size
            - scaleZ whether to allow the Z dimension of the periodic box to change size
            - frequency the frequency at which Monte Carlo pressure changes should be attempted (in time steps)
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_MonteCarloAnisotropicBarostat(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_MonteCarloAnisotropicBarostat
    def __del__(self):
        """__del__(OpenMM::MonteCarloAnisotropicBarostat self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

MonteCarloAnisotropicBarostat_swigregister = _openmm.MonteCarloAnisotropicBarostat_swigregister
MonteCarloAnisotropicBarostat_swigregister(MonteCarloAnisotropicBarostat)

def MonteCarloAnisotropicBarostat_PressureX(*args):
    """
    MonteCarloAnisotropicBarostat_PressureX() -> std::string const &

    This is the name of the parameter which stores the current pressure acting on the X-axis (in bar).
    """

    try: args=stripUnits(args)
    except UnboundLocalError: pass


    return _openmm.MonteCarloAnisotropicBarostat_PressureX(*args)

def MonteCarloAnisotropicBarostat_PressureY(*args):
    """
    MonteCarloAnisotropicBarostat_PressureY() -> std::string const &

    This is the name of the parameter which stores the current pressure acting on the Y-axis (in bar).
    """

    try: args=stripUnits(args)
    except UnboundLocalError: pass


    return _openmm.MonteCarloAnisotropicBarostat_PressureY(*args)

def MonteCarloAnisotropicBarostat_PressureZ(*args):
    """
    MonteCarloAnisotropicBarostat_PressureZ() -> std::string const &

    This is the name of the parameter which stores the current pressure acting on the Z-axis (in bar).
    """

    try: args=stripUnits(args)
    except UnboundLocalError: pass


    return _openmm.MonteCarloAnisotropicBarostat_PressureZ(*args)

class AmoebaOutOfPlaneBendForce(Force):
    """
    This class implements the Amoeba out-of-plane bend interaction.

    To use it, create an OutOfPlaneBendForce object then call addOutOfPlaneBend() once for each outOfPlaneBend. After an out-of-plane bend has been added, you can modify its force field parameters by calling setOutOfPlaneBendParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext().
    """
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AmoebaOutOfPlaneBendForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AmoebaOutOfPlaneBendForce, name)
    __repr__ = _swig_repr

    def getNumOutOfPlaneBends(self, *args):
        """
        getNumOutOfPlaneBends(AmoebaOutOfPlaneBendForce self) -> int

        Get the number of out-of-plane bend terms in the potential function
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaOutOfPlaneBendForce_getNumOutOfPlaneBends(self, *args)


    def setAmoebaGlobalOutOfPlaneBendCubic(self, *args):
        """
        setAmoebaGlobalOutOfPlaneBendCubic(AmoebaOutOfPlaneBendForce self, double cubicK)

        Set the global cubic term
           Parameters:
            - cubicK the cubic force constant for the angle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaOutOfPlaneBendForce_setAmoebaGlobalOutOfPlaneBendCubic(self, *args)


    def getAmoebaGlobalOutOfPlaneBendCubic(self, *args):
        """
        getAmoebaGlobalOutOfPlaneBendCubic(AmoebaOutOfPlaneBendForce self) -> double

        Get the global cubic term
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaOutOfPlaneBendForce_getAmoebaGlobalOutOfPlaneBendCubic(self, *args)


    def setAmoebaGlobalOutOfPlaneBendQuartic(self, *args):
        """
        setAmoebaGlobalOutOfPlaneBendQuartic(AmoebaOutOfPlaneBendForce self, double quarticK)

        Set the global cubic term
           Parameters:
            - quarticK the quartic force constant for the angle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaOutOfPlaneBendForce_setAmoebaGlobalOutOfPlaneBendQuartic(self, *args)


    def getAmoebaGlobalOutOfPlaneBendQuartic(self, *args):
        """
        getAmoebaGlobalOutOfPlaneBendQuartic(AmoebaOutOfPlaneBendForce self) -> double

        Get the global quartic term
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaOutOfPlaneBendForce_getAmoebaGlobalOutOfPlaneBendQuartic(self, *args)


    def setAmoebaGlobalOutOfPlaneBendPentic(self, *args):
        """
        setAmoebaGlobalOutOfPlaneBendPentic(AmoebaOutOfPlaneBendForce self, double penticK)

        Set the global pentic term
           Parameters:
            - penticK the pentic force constant for the angle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaOutOfPlaneBendForce_setAmoebaGlobalOutOfPlaneBendPentic(self, *args)


    def getAmoebaGlobalOutOfPlaneBendPentic(self, *args):
        """
        getAmoebaGlobalOutOfPlaneBendPentic(AmoebaOutOfPlaneBendForce self) -> double

        Get the global pentic term
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaOutOfPlaneBendForce_getAmoebaGlobalOutOfPlaneBendPentic(self, *args)


    def setAmoebaGlobalOutOfPlaneBendSextic(self, *args):
        """
        setAmoebaGlobalOutOfPlaneBendSextic(AmoebaOutOfPlaneBendForce self, double sexticK)

        Set the global sextic term
           Parameters:
            - sexticK the sextic force constant for the angle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaOutOfPlaneBendForce_setAmoebaGlobalOutOfPlaneBendSextic(self, *args)


    def getAmoebaGlobalOutOfPlaneBendSextic(self, *args):
        """
        getAmoebaGlobalOutOfPlaneBendSextic(AmoebaOutOfPlaneBendForce self) -> double

        Get the global sextic term
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaOutOfPlaneBendForce_getAmoebaGlobalOutOfPlaneBendSextic(self, *args)


    def addOutOfPlaneBend(self, *args):
        """
        addOutOfPlaneBend(AmoebaOutOfPlaneBendForce self, int particle1, int particle2, int particle3, int particle4, double k) -> int

        Add an out-of-plane bend term to the force field.
           Parameters:
            - particle1 the index of the first particle connected by the outOfPlaneBend
            - particle2 the index of the second particle connected by the outOfPlaneBend
            - particle3 the index of the third particle connected by the outOfPlaneBend
            - particle4 the index of the fourth particle connected by the outOfPlaneBend
            - k the force constant for the out-of-plane bend
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaOutOfPlaneBendForce_addOutOfPlaneBend(self, *args)


    def getOutOfPlaneBendParameters(self, *args):
        """
        getOutOfPlaneBendParameters(AmoebaOutOfPlaneBendForce self, int index)

        Get the force field parameters for an out-of-plane bend term.
           Parameters:
            - index the index of the outOfPlaneBend for which to get parameters
            - particle1 the index of the first particle connected by the outOfPlaneBend
            - particle2 the index of the second particle connected by the outOfPlaneBend
            - particle3 the index of the third particle connected by the outOfPlaneBend
            - particle4 the index of the fourth particle connected by the outOfPlaneBend
            - k the force constant for the out-of-plane bend
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaOutOfPlaneBendForce_getOutOfPlaneBendParameters(self, *args)

        val[4]=unit.Quantity(val[4], unit.kilojoule_per_mole)


        return val


    def setOutOfPlaneBendParameters(self, *args):
        """
        setOutOfPlaneBendParameters(AmoebaOutOfPlaneBendForce self, int index, int particle1, int particle2, int particle3, int particle4, double k)

        Set the force field parameters for an out-of-plane bend term.
           Parameters:
            - index the index of the outOfPlaneBend for which to set parameters
            - particle1 the index of the first particle connected by the outOfPlaneBend
            - particle2 the index of the second particle connected by the outOfPlaneBend
            - particle3 the index of the third particle connected by the outOfPlaneBend
            - particle4 the index of the fourth particle connected by the outOfPlaneBend
            - k the force constant for the out-of-plane bend
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaOutOfPlaneBendForce_setOutOfPlaneBendParameters(self, *args)


    def updateParametersInContext(self, *args):
        """
        updateParametersInContext(AmoebaOutOfPlaneBendForce self, Context context)

        Update the per-bend term parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setOutOfPlaneBendParameters() to modify this object's parameters, then call updateParametersInContext() to copy them over to the Context.

        The only information this method updates is the values of per-bend term parameters. The set of particles involved in a term cannot be changed, nor can new terms be added.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaOutOfPlaneBendForce_updateParametersInContext(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(AmoebaOutOfPlaneBendForce self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaOutOfPlaneBendForce_usesPeriodicBoundaryConditions(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::AmoebaOutOfPlaneBendForce self) -> AmoebaOutOfPlaneBendForce
        __init__(OpenMM::AmoebaOutOfPlaneBendForce self, AmoebaOutOfPlaneBendForce other) -> AmoebaOutOfPlaneBendForce

        Create an AmoebaOutOfPlaneBendForce.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_AmoebaOutOfPlaneBendForce(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_AmoebaOutOfPlaneBendForce
    def __del__(self):
        """__del__(OpenMM::AmoebaOutOfPlaneBendForce self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

AmoebaOutOfPlaneBendForce_swigregister = _openmm.AmoebaOutOfPlaneBendForce_swigregister
AmoebaOutOfPlaneBendForce_swigregister(AmoebaOutOfPlaneBendForce)

class CustomHbondForce(Force):
    """
    This class supports a wide variety of energy functions used to represent hydrogen bonding. It computes interactions between "donor" particle groups and "acceptor" particle groups, where each group may include up to three particles. Typically a donor group consists of a hydrogen atom and the atoms it is bonded to, and an acceptor group consists of a negatively charged atom and the atoms it is bonded to.

    We refer to the particles in a donor group as d1, d2 and d3, and the particles in an acceptor group as a1, a2, and a3. For each donor and each acceptor, CustomHbondForce evaluates a user supplied algebraic expression to determine the interaction energy. The expression may depend on arbitrary distances, angles, and dihedral angles defined by any of the six particles involved. The function distance(p1, p2) is the distance between the particles p1 and p2 (where "p1" and "p2" should be replaced by the names of the actual particles to calculate the distance between), angle(p1, p2, p3) is the angle formed by the three specified particles, and dihedral(p1, p2, p3, p4) is the dihedral angle formed by the four specified particles.

    The expression also may involve tabulated functions, and may depend on arbitrary global, per-donor, and per-acceptor parameters. It also optionally supports periodic boundary conditions and cutoffs for long range interactions.

    To use this class, create a CustomHbondForce object, passing an algebraic expression to the constructor that defines the interaction energy between each donor and acceptor. Then call addPerDonorParameter() to define per-donor parameters, addPerAcceptorParameter() to define per-acceptor parameters, and addGlobalParameter() to define global parameters. The values of per-donor and per-acceptor parameters are specified as part of the system definition, while values of global parameters may be modified during a simulation by calling Context::setParameter().

    Next, call addDonor() and addAcceptor() to define donors and acceptors and specify their parameter values. After a donor or acceptor has been added, you can modify its parameters by calling setDonorParameters() or setAcceptorParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext().

    CustomHbondForce also lets you specify "exclusions", particular combinations of donors and acceptors whose interactions should be omitted from force and energy calculations. This is most often used for particles that are bonded to each other.

    As an example, the following code creates a CustomHbondForce that implements a simple harmonic potential to keep the distance between a1 and d1, and the angle formed by a1-d1-d2, near ideal values:

    <tt>CustomHbondForce* force = new CustomHbondForce("k*(distance(a1,d1)-r0)^2*(angle(a1,d1,d2)-theta0)^2");</tt>

    This force depends on three parameters: k, r0, and theta0. The following code defines these as per-donor parameters:

    <tt><pre>
    force->addPerDonorParameter("k");
    force->addPerDonorParameter("r0");
    force->addPerDonorParameter("theta0");
    </pre></tt>

    Expressions may involve the operators + (add), - (subtract), * (multiply), / (divide), and ^ (power), and the following functions: sqrt, exp, log, sin, cos, sec, csc, tan, cot, asin, acos, atan, sinh, cosh, tanh, erf, erfc, min, max, abs, floor, ceil, step, delta, select. All trigonometric functions are defined in radians, and log is the natural logarithm. step(x) = 0 if x is less than 0, 1 otherwise. delta(x) = 1 if x is 0, 0 otherwise. select(x,y,z) = z if x = 0, y otherwise.

    In addition, you can call addTabulatedFunction() to define a new function based on tabulated values. You specify the function by creating a TabulatedFunction object. That function can then appear in the expression.
    """
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomHbondForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomHbondForce, name)
    __repr__ = _swig_repr
    NoCutoff = _openmm.CustomHbondForce_NoCutoff
    CutoffNonPeriodic = _openmm.CustomHbondForce_CutoffNonPeriodic
    CutoffPeriodic = _openmm.CustomHbondForce_CutoffPeriodic
    __swig_destroy__ = _openmm.delete_CustomHbondForce
    def __del__(self):
        """__del__(OpenMM::CustomHbondForce self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass


    def getNumDonors(self, *args):
        """
        getNumDonors(CustomHbondForce self) -> int

        Get the number of donors for which force field parameters have been defined.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getNumDonors(self, *args)


    def getNumAcceptors(self, *args):
        """
        getNumAcceptors(CustomHbondForce self) -> int

        Get the number of acceptors for which force field parameters have been defined.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getNumAcceptors(self, *args)


    def getNumExclusions(self, *args):
        """
        getNumExclusions(CustomHbondForce self) -> int

        Get the number of donor-acceptor pairs whose interactions should be excluded.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getNumExclusions(self, *args)


    def getNumPerDonorParameters(self, *args):
        """
        getNumPerDonorParameters(CustomHbondForce self) -> int

        Get the number of per-donor parameters that the interaction depends on.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getNumPerDonorParameters(self, *args)


    def getNumPerAcceptorParameters(self, *args):
        """
        getNumPerAcceptorParameters(CustomHbondForce self) -> int

        Get the number of per-acceptor parameters that the interaction depends on.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getNumPerAcceptorParameters(self, *args)


    def getNumGlobalParameters(self, *args):
        """
        getNumGlobalParameters(CustomHbondForce self) -> int

        Get the number of global parameters that the interaction depends on.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getNumGlobalParameters(self, *args)


    def getNumTabulatedFunctions(self, *args):
        """
        getNumTabulatedFunctions(CustomHbondForce self) -> int

        Get the number of tabulated functions that have been defined.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getNumTabulatedFunctions(self, *args)


    def getNumFunctions(self, *args):
        """
        getNumFunctions(CustomHbondForce self) -> int

        Get the number of tabulated functions that have been defined.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getNumFunctions(self, *args)


    def getEnergyFunction(self, *args):
        """
        getEnergyFunction(CustomHbondForce self) -> std::string const &

        Get the algebraic expression that gives the interaction energy between a donor and an acceptor
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getEnergyFunction(self, *args)


    def setEnergyFunction(self, *args):
        """
        setEnergyFunction(CustomHbondForce self, std::string const & energy)

        Set the algebraic expression that gives the interaction energy between a donor and an acceptor
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_setEnergyFunction(self, *args)


    def getNonbondedMethod(self, *args):
        """
        getNonbondedMethod(CustomHbondForce self) -> OpenMM::CustomHbondForce::NonbondedMethod

        Get the method used for handling long range nonbonded interactions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getNonbondedMethod(self, *args)


    def setNonbondedMethod(self, *args):
        """
        setNonbondedMethod(CustomHbondForce self, OpenMM::CustomHbondForce::NonbondedMethod method)

        Set the method used for handling long range nonbonded interactions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_setNonbondedMethod(self, *args)


    def getCutoffDistance(self, *args):
        """
        getCutoffDistance(CustomHbondForce self) -> double

        Get the cutoff distance (in nm) being used. All interactions for which the distance between d1 and a1 is greater than the cutoff will be ignored. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.CustomHbondForce_getCutoffDistance(self, *args)

        val=unit.Quantity(val, unit.nanometers)


        return val


    def setCutoffDistance(self, *args):
        """
        setCutoffDistance(CustomHbondForce self, double distance)

        Set the cutoff distance (in nm) being used. All interactions for which the distance between d1 and a1 is greater than the cutoff will be ignored. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
           Parameters:
            - distance the cutoff distance, measured in nm
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_setCutoffDistance(self, *args)


    def addPerDonorParameter(self, *args):
        """
        addPerDonorParameter(CustomHbondForce self, std::string const & name) -> int

        Add a new per-donor parameter that the interaction may depend on.
           Parameters:
            - name the name of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_addPerDonorParameter(self, *args)


    def getPerDonorParameterName(self, *args):
        """
        getPerDonorParameterName(CustomHbondForce self, int index) -> std::string const &

        Get the name of a per-donor parameter.
           Parameters:
            - index the index of the parameter for which to get the name
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getPerDonorParameterName(self, *args)


    def setPerDonorParameterName(self, *args):
        """
        setPerDonorParameterName(CustomHbondForce self, int index, std::string const & name)

        Set the name of a per-donor parameter.
           Parameters:
            - index the index of the parameter for which to set the name
            - name the name of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_setPerDonorParameterName(self, *args)


    def addPerAcceptorParameter(self, *args):
        """
        addPerAcceptorParameter(CustomHbondForce self, std::string const & name) -> int

        Add a new per-acceptor parameter that the interaction may depend on.
           Parameters:
            - name the name of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_addPerAcceptorParameter(self, *args)


    def getPerAcceptorParameterName(self, *args):
        """
        getPerAcceptorParameterName(CustomHbondForce self, int index) -> std::string const &

        Get the name of a per-acceptor parameter.
           Parameters:
            - index the index of the parameter for which to get the name
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getPerAcceptorParameterName(self, *args)


    def setPerAcceptorParameterName(self, *args):
        """
        setPerAcceptorParameterName(CustomHbondForce self, int index, std::string const & name)

        Set the name of a per-acceptor parameter.
           Parameters:
            - index the index of the parameter for which to set the name
            - name the name of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_setPerAcceptorParameterName(self, *args)


    def addGlobalParameter(self, *args):
        """
        addGlobalParameter(CustomHbondForce self, std::string const & name, double defaultValue) -> int

        Add a new global parameter that the interaction may depend on.
           Parameters:
            - name the name of the parameter
            - defaultValue the default value of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_addGlobalParameter(self, *args)


    def getGlobalParameterName(self, *args):
        """
        getGlobalParameterName(CustomHbondForce self, int index) -> std::string const &

        Get the name of a global parameter.
           Parameters:
            - index the index of the parameter for which to get the name
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getGlobalParameterName(self, *args)


    def setGlobalParameterName(self, *args):
        """
        setGlobalParameterName(CustomHbondForce self, int index, std::string const & name)

        Set the name of a global parameter.
           Parameters:
            - index the index of the parameter for which to set the name
            - name the name of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_setGlobalParameterName(self, *args)


    def getGlobalParameterDefaultValue(self, *args):
        """
        getGlobalParameterDefaultValue(CustomHbondForce self, int index) -> double

        Get the default value of a global parameter.
           Parameters:
            - index the index of the parameter for which to get the default value
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getGlobalParameterDefaultValue(self, *args)


    def setGlobalParameterDefaultValue(self, *args):
        """
        setGlobalParameterDefaultValue(CustomHbondForce self, int index, double defaultValue)

        Set the default value of a global parameter.
           Parameters:
            - index the index of the parameter for which to set the default value
            - name the default value of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_setGlobalParameterDefaultValue(self, *args)


    def addDonor(self, *args):
        """
        addDonor(CustomHbondForce self, int d1, int d2, int d3, vectord parameters) -> int

        Add a donor group to the force
           Parameters:
            - d1 the index of the first particle for this donor group
            - d2 the index of the second particle for this donor group. If the group only includes one particle, this must be -1.
            - d3 the index of the third particle for this donor group. If the group includes less than three particles, this must be -1.
            - parameters the list of per-donor parameter values for the new donor
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_addDonor(self, *args)


    def getDonorParameters(self, *args):
        """
        getDonorParameters(CustomHbondForce self, int index)

        Get the properties of a donor group.
           Parameters:
            - index the index of the donor group to get
            - d1 the index of the first particle for this donor group
            - d2 the index of the second particle for this donor group. If the group only includes one particle, this will be -1.
            - d3 the index of the third particle for this donor group. If the group includes less than three particles, this will be -1.
            - parameters the list of per-donor parameter values for the donor
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getDonorParameters(self, *args)


    def setDonorParameters(self, *args):
        """
        setDonorParameters(CustomHbondForce self, int index, int d1, int d2, int d3, vectord parameters)

        Set the properties of a donor group.
           Parameters:
            - index the index of the donor group to set
            - d1 the index of the first particle for this donor group
            - d2 the index of the second particle for this donor group. If the group only includes one particle, this must be -1.
            - d3 the index of the third particle for this donor group. If the group includes less than three particles, this must be -1.
            - parameters the list of per-donor parameter values for the donor
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_setDonorParameters(self, *args)


    def addAcceptor(self, *args):
        """
        addAcceptor(CustomHbondForce self, int a1, int a2, int a3, vectord parameters) -> int

        Add an acceptor group to the force
           Parameters:
            - a1 the index of the first particle for this acceptor group
            - a2 the index of the second particle for this acceptor group. If the group only includes one particle, this must be -1.
            - a3 the index of the third particle for this acceptor group. If the group includes less than three particles, this must be -1.
            - parameters the list of per-acceptor parameter values for the new acceptor
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_addAcceptor(self, *args)


    def getAcceptorParameters(self, *args):
        """
        getAcceptorParameters(CustomHbondForce self, int index)

        Get the properties of an acceptor group.
           Parameters:
            - index the index of the acceptor group to get
            - a1 the index of the first particle for this acceptor group
            - a2 the index of the second particle for this acceptor group. If the group only includes one particle, this will be -1.
            - a3 the index of the third particle for this acceptor group. If the group includes less than three particles, this will be -1.
            - parameters the list of per-acceptor parameter values for the acceptor
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getAcceptorParameters(self, *args)


    def setAcceptorParameters(self, *args):
        """
        setAcceptorParameters(CustomHbondForce self, int index, int a1, int a2, int a3, vectord parameters)

        Set the properties of an acceptor group.
           Parameters:
            - index the index of the acceptor group to set
            - a1 the index of the first particle for this acceptor group
            - a2 the index of the second particle for this acceptor group. If the group only includes one particle, this must be -1.
            - a3 the index of the third particle for this acceptor group. If the group includes less than three particles, this must be -1.
            - parameters the list of per-acceptor parameter values for the acceptor
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_setAcceptorParameters(self, *args)


    def addExclusion(self, *args):
        """
        addExclusion(CustomHbondForce self, int donor, int acceptor) -> int

        Add a donor-acceptor pair to the list of interactions that should be excluded.
           Parameters:
            - donor the index of the donor to exclude
            - acceptor the index of the acceptor to exclude
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_addExclusion(self, *args)


    def getExclusionParticles(self, *args):
        """
        getExclusionParticles(CustomHbondForce self, int index)

        Get the donor and acceptor in a pair whose interaction should be excluded.
           Parameters:
            - index the index of the exclusion for which to get donor and acceptor indices
            - particle1 the index of the donor
            - particle2 the index of the acceptor
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getExclusionParticles(self, *args)


    def setExclusionParticles(self, *args):
        """
        setExclusionParticles(CustomHbondForce self, int index, int donor, int acceptor)

        Get the donor and acceptor in a pair whose interaction should be excluded.
           Parameters:
            - index the index of the exclusion for which to get donor and acceptor indices
            - particle1 the index of the donor
            - particle2 the index of the acceptor
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_setExclusionParticles(self, *args)


    def addTabulatedFunction(self, *args):
        """
        addTabulatedFunction(CustomHbondForce self, std::string const & name, TabulatedFunction function) -> int

        Add a tabulated function that may appear in the energy expression.
           Parameters:
            - name the name of the function as it appears in expressions
            - function a TabulatedFunction object defining the function. The TabulatedFunction should have been created on the heap with the "new" operator. The Force takes over ownership of it, and deletes it when the Force itself is deleted.
        """

        if not args[1].thisown:
           s = "the %s object does not own its corresponding OpenMM object" \
              % args[1].__class__.__name__
           raise Exception(s)


        val = _openmm.CustomHbondForce_addTabulatedFunction(self, *args)

        args[1].thisown=0


        return val


    def getTabulatedFunction(self, *args):
        """
        getTabulatedFunction(CustomHbondForce self, int index) -> TabulatedFunction
        getTabulatedFunction(CustomHbondForce self, int index) -> TabulatedFunction

        Get a reference to a tabulated function that may appear in the energy expression.
           Parameters:
            - index the index of the function to get
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getTabulatedFunction(self, *args)


    def getTabulatedFunctionName(self, *args):
        """
        getTabulatedFunctionName(CustomHbondForce self, int index) -> std::string const &

        Get the name of a tabulated function that may appear in the energy expression.
           Parameters:
            - index the index of the function to get
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getTabulatedFunctionName(self, *args)


    def addFunction(self, *args):
        """
        addFunction(CustomHbondForce self, std::string const & name, vectord values, double min, double max) -> int

        Add a tabulated function that may appear in the energy expression.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_addFunction(self, *args)


    def getFunctionParameters(self, *args):
        """
        getFunctionParameters(CustomHbondForce self, int index)

        Get the parameters for a tabulated function that may appear in the energy expression.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_getFunctionParameters(self, *args)


    def setFunctionParameters(self, *args):
        """
        setFunctionParameters(CustomHbondForce self, int index, std::string const & name, vectord values, double min, double max)

        Set the parameters for a tabulated function that may appear in the energy expression.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_setFunctionParameters(self, *args)


    def updateParametersInContext(self, *args):
        """
        updateParametersInContext(CustomHbondForce self, Context context)

        Update the per-donor and per-acceptor parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setDonorParameters() and setAcceptorParameters() to modify this object's parameters, then call updateParametersInContext() to copy them over to the Context.

        This method has several limitations. The only information it updates is the values of per-donor and per-acceptor parameters. All other aspects of the Force (the energy function, nonbonded method, cutoff distance, etc.) are unaffected and can only be changed by reinitializing the Context. The set of particles involved in a donor or acceptor cannot be changed, nor can new donors or acceptors be added.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_updateParametersInContext(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(CustomHbondForce self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomHbondForce_usesPeriodicBoundaryConditions(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::CustomHbondForce self, std::string const & energy) -> CustomHbondForce
        __init__(OpenMM::CustomHbondForce self, CustomHbondForce other) -> CustomHbondForce

        Create a CustomHbondForce.
           Parameters:
            - energy an algebraic expression giving the interaction energy between a donor and an acceptor as a function of inter-particle distances, angles, and dihedrals, as well as any global, per-donor, and per-acceptor parameters
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_CustomHbondForce(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
CustomHbondForce_swigregister = _openmm.CustomHbondForce_swigregister
CustomHbondForce_swigregister(CustomHbondForce)

class CMMotionRemover(Force):
    """This class prevents the center of mass of a System from drifting. At each time step, it calculates the center of mass momentum, then adjusts the individual particle velocities to make it zero."""
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CMMotionRemover, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CMMotionRemover, name)
    __repr__ = _swig_repr

    def getFrequency(self, *args):
        """
        getFrequency(CMMotionRemover self) -> int

        Get the frequency (in time steps) at which center of mass motion should be removed
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CMMotionRemover_getFrequency(self, *args)


    def setFrequency(self, *args):
        """
        setFrequency(CMMotionRemover self, int freq)

        Set the frequency (in time steps) at which center of mass motion should be removed
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CMMotionRemover_setFrequency(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(CMMotionRemover self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CMMotionRemover_usesPeriodicBoundaryConditions(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::CMMotionRemover self, int frequency=1) -> CMMotionRemover
        __init__(OpenMM::CMMotionRemover self, CMMotionRemover other) -> CMMotionRemover

        Create a CMMotionRemover.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_CMMotionRemover(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_CMMotionRemover
    def __del__(self):
        """__del__(OpenMM::CMMotionRemover self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

CMMotionRemover_swigregister = _openmm.CMMotionRemover_swigregister
CMMotionRemover_swigregister(CMMotionRemover)

class CustomIntegrator(Integrator):
    """
    This is an Integrator that can be used to implemented arbitrary, user defined integration algorithms. It is flexible enough to support a wide range of methods including both deterministic and stochastic integrators, Metropolized integrators, and integrators that must integrate additional quantities along with the particle positions and momenta.

    To create an integration algorithm, you first define a set of variables the integrator will compute. Variables come in two types: <i>global</i> variables have a single value, while <i>per-DOF</i> variables have a value for every degree of freedom (x, y, or z coordinate of a particle). You can define as many variables as you want of each type. The value of any variable can be computed by the integration algorithm, or set directly by calling a method on the CustomIntegrator. All variables are persistent between integration steps; once a value is set, it keeps that value until it is changed by the user or recomputed in a later integration step.

    Next, you define the algorithm as a series of computations. To execute a time step, the integrator performs the list of computations in order. Each computation updates the value of one global or per-DOF value. There are several types of computations that can be done:

    <ul>
    <li>
    Global: You provide a mathematical expression involving only global variables. It is evaluated and stored into a global variable. 

    </li>
    <li>
    Per-DOF: You provide a mathematical expression involving both global and per-DOF variables. It is evaluated once for every degree of freedom, and the values are stored into a per-DOF variable. 

    </li>
    <li>
    Sum: You provide a mathematical expression involving both global and per-DOF variables. It is evaluated once for every degree of freedom. All of those values are then added together, and the sum is stored into a global variable. 

    </li>
    <li>
    Constrain Positions: The particle positions are updated so that all distance constraints are satisfied. 

    </li>
    <li>
    Constrain Velocities: The particle velocities are updated so the net velocity along any constrained distance is 0. 

    </li>
    </ul>


    Like all integrators, CustomIntegrator ignores any particle whose mass is 0. It is skipped when doing per-DOF computations, and is not included when computing sums over degrees of freedom.

    In addition to the variables you define by calling addGlobalVariable() and addPerDofVariable(), the integrator provides the following pre-defined variables:

    <ul>
    <li>
    dt: (global) This is the step size being used by the integrator. 

    </li>
    <li>
    energy: (global, read-only) This is the current potential energy of the system. 

    </li>
    <li>
    energy0, energy1, energy2, ...: (global, read-only) This is similar to energy, but includes only the contribution from forces in one force group. A single computation step may only depend on a single energy variable (energy, energy0, energy1, etc.). 

    </li>
    <li>
    x: (per-DOF) This is the current value of the degree of freedom (the x, y, or z coordinate of a particle). 

    </li>
    <li>
    v: (per-DOF) This is the current velocity associated with the degree of freedom (the x, y, or z component of a particle's velocity). 

    </li>
    <li>
    f: (per-DOF, read-only) This is the current force acting on the degree of freedom (the x, y, or z component of the force on a particle). 

    </li>
    <li>
    f0, f1, f2, ...: (per-DOF, read-only) This is similar to f, but includes only the contribution from forces in one force group. A single computation step may only depend on a single force variable (f, f0, f1, etc.). 

    </li>
    <li>
    m: (per-DOF, read-only) This is the mass of the particle the degree of freedom is associated with. 

    </li>
    <li>
    uniform: (either global or per-DOF, read-only) This is a uniformly distributed random number between 0 and 1. Every time an expression is evaluated, a different value will be used. When used in a per-DOF expression, a different value will be used for every degree of freedom. Note, however, that if this variable appears multiple times in a single expression, the <i>same</i> value is used everywhere it appears in that expression. 

    </li>
    <li>
    gaussian: (either global or per-DOF, read-only) This is a Gaussian distributed random number with mean 0 and variance 1. Every time an expression is evaluated, a different value will be used. When used in a per-DOF expression, a different value will be used for every degree of freedom. Note, however, that if this variable appears multiple times in a single expression, the <i>same</i> value is used everywhere it appears in that expression. 

    </li>
    <li>
    A global variable is created for every adjustable parameter defined in the integrator's Context. 

    </li>
    </ul>


    The following example uses a CustomIntegrator to implement a velocity Verlet integrator:

    <tt><pre>
    CustomIntegrator integrator(0.001);
    integrator.addComputePerDof("v", "v+0.5*dt*f/m");
    integrator.addComputePerDof("x", "x+dt*v");
    integrator.addComputePerDof("v", "v+0.5*dt*f/m");
    </pre></tt>

    The first step updates the velocities based on the current forces. The second step updates the positions based on the new velocities, and the third step updates the velocities again. Although the first and third steps look identical, the forces used in them are different. You do not need to tell the integrator that; it will recognize that the positions have changed and know to recompute the forces automatically.

    The above example has two problems. First, it does not respect distance constraints. To make the integrator work with constraints, you need to add extra steps to tell it when and how to apply them. Second, it never gives Forces an opportunity to update the context state. This should be done every time step so that, for example, an AndersenThermostat can randomize velocities or a MonteCarloBarostat can scale particle positions. You need to add a step to tell the integrator when to do this. The following example corrects both these problems, using the RATTLE algorithm to apply constraints:

    <tt><pre>
    CustomIntegrator integrator(0.001);
    integrator.addPerDofVariable("x1", 0);
    integrator.addUpdateContextState();
    integrator.addComputePerDof("v", "v+0.5*dt*f/m");
    integrator.addComputePerDof("x", "x+dt*v");
    integrator.addComputePerDof("x1", "x");
    integrator.addConstrainPositions();
    integrator.addComputePerDof("v", "v+0.5*dt*f/m+(x-x1)/dt");
    integrator.addConstrainVelocities();
    </pre></tt>

    CustomIntegrator can be used to implement multiple time step integrators. The following example shows an r-RESPA integrator. It assumes the quickly changing forces are in force group 0 and the slowly changing ones are in force group 1. It evaluates the "fast" forces four times as often as the "slow" forces.

    <tt><pre>
    CustomIntegrator integrator(0.004);
    integrator.addComputePerDof("v", "v+0.5*dt*f1/m");
    for (int i = 0; i < 4; i++) {
        integrator.addComputePerDof("v", "v+0.5*(dt/4)*f0/m");
        integrator.addComputePerDof("x", "x+(dt/4)*v");
        integrator.addComputePerDof("v", "v+0.5*(dt/4)*f0/m");
    }
    integrator.addComputePerDof("v", "v+0.5*dt*f1/m");
    </pre></tt>

    An Integrator has one other job in addition to evolving the equations of motion: it defines how to compute the kinetic energy of the system. Depending on the integration method used, simply summing mv/2 over all degrees of freedom may not give the correct answer. For example, in a leapfrog integrator the velocities are "delayed" by half a time step, so the above formula would give the kinetic energy half a time step ago, not at the current time.

    Call setKineticEnergyExpression() to set an expression for the kinetic energy. It is computed for every degree of freedom (excluding ones whose mass is 0) and the result is summed. The default expression is "m*v*v/2", which is correct for many integrators.

    As example, the following line defines the correct way to compute kinetic energy when using a leapfrog algorithm:

    <tt><pre>
    integrator.setKineticEnergyExpression("m*v1*v1/2; v1=v+0.5*dt*f/m");
    </pre></tt>

    The kinetic energy expression may depend on the following pre-defined variables: x, v, f, m, dt. It also may depend on user-defined global and per-DOF variables, and on the values of adjustable parameters defined in the integrator's Context. It may <i>not</i> depend on any other variable, such as the potential energy, the force from a single force group, or a random number.

    Expressions may involve the operators + (add), - (subtract), * (multiply), / (divide), and ^ (power), and the following functions: sqrt, exp, log, sin, cos, sec, csc, tan, cot, asin, acos, atan, sinh, cosh, tanh, erf, erfc, min, max, abs, floor, ceil, step, delta, select. All trigonometric functions are defined in radians, and log is the natural logarithm. step(x) = 0 if x is less than 0, 1 otherwise. delta(x) = 1 if x is 0, 0 otherwise. select(x,y,z) = z if x = 0, y otherwise. An expression may also involve intermediate quantities that are defined following the main expression, using ";" as a separator.
    """
    __swig_setmethods__ = {}
    for _s in [Integrator]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomIntegrator, name, value)
    __swig_getmethods__ = {}
    for _s in [Integrator]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomIntegrator, name)
    __repr__ = _swig_repr
    ComputeGlobal = _openmm.CustomIntegrator_ComputeGlobal
    ComputePerDof = _openmm.CustomIntegrator_ComputePerDof
    ComputeSum = _openmm.CustomIntegrator_ComputeSum
    ConstrainPositions = _openmm.CustomIntegrator_ConstrainPositions
    ConstrainVelocities = _openmm.CustomIntegrator_ConstrainVelocities
    UpdateContextState = _openmm.CustomIntegrator_UpdateContextState

    def getNumGlobalVariables(self, *args):
        """
        getNumGlobalVariables(CustomIntegrator self) -> int

        Get the number of global variables that have been defined.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomIntegrator_getNumGlobalVariables(self, *args)


    def getNumPerDofVariables(self, *args):
        """
        getNumPerDofVariables(CustomIntegrator self) -> int

        Get the number of per-DOF variables that have been defined.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomIntegrator_getNumPerDofVariables(self, *args)


    def getNumComputations(self, *args):
        """
        getNumComputations(CustomIntegrator self) -> int

        Get the number of computation steps that have been added.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomIntegrator_getNumComputations(self, *args)


    def addGlobalVariable(self, *args):
        """
        addGlobalVariable(CustomIntegrator self, std::string const & name, double initialValue) -> int

        Define a new global variable.
           Parameters:
            - name the name of the variable
            - initialValue the variable will initially be set to this value
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomIntegrator_addGlobalVariable(self, *args)


    def getGlobalVariableName(self, *args):
        """
        getGlobalVariableName(CustomIntegrator self, int index) -> std::string const &

        Get the name of a global variable.
           Parameters:
            - index the index of the variable to get
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomIntegrator_getGlobalVariableName(self, *args)


    def addPerDofVariable(self, *args):
        """
        addPerDofVariable(CustomIntegrator self, std::string const & name, double initialValue) -> int

        Define a new per-DOF variable.
           Parameters:
            - name the name of the variable
            - initialValue the variable will initially be set to this value for all degrees of freedom
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomIntegrator_addPerDofVariable(self, *args)


    def getPerDofVariableName(self, *args):
        """
        getPerDofVariableName(CustomIntegrator self, int index) -> std::string const &

        Get the name of a per-DOF variable.
           Parameters:
            - index the index of the variable to get
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomIntegrator_getPerDofVariableName(self, *args)


    def getGlobalVariable(self, *args):
        """
        getGlobalVariable(CustomIntegrator self, int index) -> double

        Get the current value of a global variable.
           Parameters:
            - index the index of the variable to get
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomIntegrator_getGlobalVariable(self, *args)


    def getGlobalVariableByName(self, *args):
        """
        getGlobalVariableByName(CustomIntegrator self, std::string const & name) -> double

        Get the current value of a global variable, specified by name.
           Parameters:
            - name the name of the variable to get
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomIntegrator_getGlobalVariableByName(self, *args)


    def setGlobalVariable(self, *args):
        """
        setGlobalVariable(CustomIntegrator self, int index, double value)

        Set the value of a global variable.
           Parameters:
            - index the index of the variable to set
            - value the new value of the variable
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomIntegrator_setGlobalVariable(self, *args)


    def setGlobalVariableByName(self, *args):
        """
        setGlobalVariableByName(CustomIntegrator self, std::string const & name, double value)

        Set the value of a global variable, specified by name.
           Parameters:
            - name the name of the variable to set
            - value the new value of the variable
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomIntegrator_setGlobalVariableByName(self, *args)


    def getPerDofVariableByName(self, *args):
        """
        getPerDofVariableByName(CustomIntegrator self, std::string const & name)

        Get the value of a per-DOF variable, specified by name.
           Parameters:
            - name the name of the variable to get
            - values the values of the variable for all degrees of freedom are stored into this
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomIntegrator_getPerDofVariableByName(self, *args)


    def setPerDofVariable(self, *args):
        """
        setPerDofVariable(CustomIntegrator self, int index, std::vector< Vec3,std::allocator< Vec3 > > const & values)

        Set the value of a per-DOF variable.
           Parameters:
            - index the index of the variable to set
            - values the new values of the variable for all degrees of freedom
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomIntegrator_setPerDofVariable(self, *args)


    def setPerDofVariableByName(self, *args):
        """
        setPerDofVariableByName(CustomIntegrator self, std::string const & name, std::vector< Vec3,std::allocator< Vec3 > > const & values)

        Set the value of a per-DOF variable, specified by name.
           Parameters:
            - name the name of the variable to set
            - values the new values of the variable for all degrees of freedom
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomIntegrator_setPerDofVariableByName(self, *args)


    def addComputeGlobal(self, *args):
        """
        addComputeGlobal(CustomIntegrator self, std::string const & variable, std::string const & expression) -> int

        Add a step to the integration algorithm that computes a global value.
           Parameters:
            - variable the global variable to store the computed value into
            - expression a mathematical expression involving only global variables. In each integration step, its value is computed and stored into the specified variable.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomIntegrator_addComputeGlobal(self, *args)


    def addComputePerDof(self, *args):
        """
        addComputePerDof(CustomIntegrator self, std::string const & variable, std::string const & expression) -> int

        Add a step to the integration algorithm that computes a per-DOF value.
           Parameters:
            - variable the per-DOF variable to store the computed value into
            - expression a mathematical expression involving both global and per-DOF variables. In each integration step, its value is computed for every degree of freedom and stored into the specified variable.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomIntegrator_addComputePerDof(self, *args)


    def addComputeSum(self, *args):
        """
        addComputeSum(CustomIntegrator self, std::string const & variable, std::string const & expression) -> int

        Add a step to the integration algorithm that computes a sum over degrees of freedom.
           Parameters:
            - variable the global variable to store the computed value into
            - expression a mathematical expression involving both global and per-DOF variables. In each integration step, its value is computed for every degree of freedom. Those values are then added together, and the sum is stored in the specified variable.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomIntegrator_addComputeSum(self, *args)


    def addConstrainPositions(self, *args):
        """
        addConstrainPositions(CustomIntegrator self) -> int

        Add a step to the integration algorithm that updates particle positions so all constraints are satisfied.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomIntegrator_addConstrainPositions(self, *args)


    def addConstrainVelocities(self, *args):
        """
        addConstrainVelocities(CustomIntegrator self) -> int

        Add a step to the integration algorithm that updates particle velocities so the net velocity along all constraints is 0.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomIntegrator_addConstrainVelocities(self, *args)


    def addUpdateContextState(self, *args):
        """
        addUpdateContextState(CustomIntegrator self) -> int

        Add a step to the integration algorithm that allows Forces to update the context state.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomIntegrator_addUpdateContextState(self, *args)


    def getComputationStep(self, *args):
        """
        getComputationStep(CustomIntegrator self, int index)

        Get the details of a computation step that has been added to the integration algorithm.
           Parameters:
            - index the index of the computation step to get
            - type on exit, the type of computation this step performs
            - variable on exit, the variable into which this step stores its result. If this step does not store a result in a variable, this will be an empty string.
            - expression on exit, the expression this step evaluates. If this step does not evaluate an expression, this will be an empty string.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomIntegrator_getComputationStep(self, *args)


    def getKineticEnergyExpression(self, *args):
        """
        getKineticEnergyExpression(CustomIntegrator self) -> std::string const &

        Get the expression to use for computing the kinetic energy. The expression is evaluated for every degree of freedom. Those values are then added together, and the sum is reported as the current kinetic energy.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomIntegrator_getKineticEnergyExpression(self, *args)


    def setKineticEnergyExpression(self, *args):
        """
        setKineticEnergyExpression(CustomIntegrator self, std::string const & expression)

        Set the expression to use for computing the kinetic energy. The expression is evaluated for every degree of freedom. Those values are then added together, and the sum is reported as the current kinetic energy.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomIntegrator_setKineticEnergyExpression(self, *args)


    def getRandomNumberSeed(self, *args):
        """
        getRandomNumberSeed(CustomIntegrator self) -> int

        Get the random number seed. See setRandomNumberSeed() for details.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomIntegrator_getRandomNumberSeed(self, *args)


    def setRandomNumberSeed(self, *args):
        """
        setRandomNumberSeed(CustomIntegrator self, int seed)

        Set the random number seed. The precise meaning of this parameter is undefined, and is left up to each Platform to interpret in an appropriate way. It is guaranteed that if two simulations are run with different random number seeds, the sequence of random numbers will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically.

        If seed is set to 0 (which is the default value assigned), a unique seed is chosen when a Context is created from this Force. This is done to ensure that each Context receives unique random seeds without you needing to set them explicitly.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomIntegrator_setRandomNumberSeed(self, *args)


    def step(self, *args):
        """
        step(CustomIntegrator self, int steps)

        Advance a simulation through time by taking a series of time steps.
           Parameters:
            - steps the number of time steps to take
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomIntegrator_step(self, *args)


    def getPerDofVariable(self, *args):
        """
        getPerDofVariable(CustomIntegrator self, int index)
        getPerDofVariable(CustomIntegrator self, int index) -> PyObject *
        """
        return _openmm.CustomIntegrator_getPerDofVariable(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::CustomIntegrator self, double stepSize) -> CustomIntegrator
        __init__(OpenMM::CustomIntegrator self, CustomIntegrator other) -> CustomIntegrator

        Create a CustomIntegrator.
           Parameters:
            - stepSize the step size with which to integrate the system (in picoseconds)
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_CustomIntegrator(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_CustomIntegrator
    def __del__(self):
        """__del__(OpenMM::CustomIntegrator self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

CustomIntegrator_swigregister = _openmm.CustomIntegrator_swigregister
CustomIntegrator_swigregister(CustomIntegrator)

class System(_object):
    """
    This class represents a molecular system. The definition of a System involves four elements:




    The particles and constraints are defined directly by the System object, while forces are defined by objects that extend the Force class. After creating a System, call addParticle() once for each particle, addConstraint() for each constraint, and addForce() for each Force.

    In addition, particles may be designated as "virtual sites". These are particles whose positions are computed automatically based on the positions of other particles. To define a virtual site, call setVirtualSite(), passing in a VirtualSite object that defines the rules for computing its position.
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, System, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, System, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _openmm.delete_System
    def __del__(self):
        """__del__(OpenMM::System self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass


    def getNumParticles(self, *args):
        """
        getNumParticles(System self) -> int

        Get the number of particles in this System.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.System_getNumParticles(self, *args)


    def addParticle(self, *args):
        """
        addParticle(System self, double mass) -> int

        Add a particle to the System. If the mass is 0, Integrators will ignore the particle and not modify its position or velocity. This is most often used for virtual sites, but can also be used as a way to prevent a particle from moving.
           Parameters:
            - mass the mass of the particle (in atomic mass units)
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.System_addParticle(self, *args)


    def getParticleMass(self, *args):
        """
        getParticleMass(System self, int index) -> double

        Get the mass (in atomic mass units) of a particle. If the mass is 0, Integrators will ignore the particle and not modify its position or velocity. This is most often used for virtual sites, but can also be used as a way to prevent a particle from moving.
           Parameters:
            - index the index of the particle for which to get the mass
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.System_getParticleMass(self, *args)

        val=unit.Quantity(val, unit.amu)


        return val


    def setParticleMass(self, *args):
        """
        setParticleMass(System self, int index, double mass)

        Set the mass (in atomic mass units) of a particle. If the mass is 0, Integrators will ignore the particle and not modify its position or velocity. This is most often used for virtual sites, but can also be used as a way to prevent a particle from moving.
           Parameters:
            - index the index of the particle for which to set the mass
            - mass the mass of the particle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.System_setParticleMass(self, *args)


    def setVirtualSite(self, *args):
        """
        setVirtualSite(System self, int index, VirtualSite virtualSite)

        Set a particle to be a virtual site. The VirtualSite object should have been created on the heap with the "new" operator. The System takes over ownership of it, and deletes it when the System itself is deleted.
           Parameters:
            - index the index of the particle that should be treated as a virtual site
            - virtualSite a pointer to the VirtualSite object describing it
        """

        if not args[1].thisown:
           s = "the %s object does not own its corresponding OpenMM object" \
              % args[1].__class__.__name__
           raise Exception(s)


        val = _openmm.System_setVirtualSite(self, *args)

        args[1].thisown=0


        return val


    def isVirtualSite(self, *args):
        """
        isVirtualSite(System self, int index) -> bool

        Get whether a particle is a VirtualSite.
           Parameters:
            - index the index of the particle to check
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.System_isVirtualSite(self, *args)


    def getVirtualSite(self, *args):
        """
        getVirtualSite(System self, int index) -> VirtualSite

        Get VirtualSite object for a particle. If the particle is not a virtual site, this throws an exception.
           Parameters:
            - index the index of the particle to get
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.System_getVirtualSite(self, *args)


    def getNumConstraints(self, *args):
        """
        getNumConstraints(System self) -> int

        Get the number of distance constraints in this System.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.System_getNumConstraints(self, *args)


    def addConstraint(self, *args):
        """
        addConstraint(System self, int particle1, int particle2, double distance) -> int

        Add a constraint to the System. Particles whose mass is 0 cannot participate in constraints.
           Parameters:
            - particle1 the index of the first particle involved in the constraint
            - particle2 the index of the second particle involved in the constraint
            - distance the required distance between the two particles, measured in nm
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.System_addConstraint(self, *args)


    def getConstraintParameters(self, *args):
        """
        getConstraintParameters(System self, int index)

        Get the parameters defining a distance constraint.
           Parameters:
            - index the index of the constraint for which to get parameters
            - particle1 the index of the first particle involved in the constraint
            - particle2 the index of the second particle involved in the constraint
            - distance the required distance between the two particles, measured in nm
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.System_getConstraintParameters(self, *args)

        val[2]=unit.Quantity(val[2], unit.nanometer)


        return val


    def setConstraintParameters(self, *args):
        """
        setConstraintParameters(System self, int index, int particle1, int particle2, double distance)

        Set the parameters defining a distance constraint. Particles whose mass is 0 cannot participate in constraints.
           Parameters:
            - index the index of the constraint for which to set parameters
            - particle1 the index of the first particle involved in the constraint
            - particle2 the index of the second particle involved in the constraint
            - distance the required distance between the two particles, measured in nm
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.System_setConstraintParameters(self, *args)


    def removeConstraint(self, *args):
        """
        removeConstraint(System self, int index)

        Remove a constraint from the System.
           Parameters:
            - index the index of the constraint to remove
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.System_removeConstraint(self, *args)


    def addForce(self, *args):
        """
        addForce(System self, Force force) -> int

        Add a Force to the System. The Force should have been created on the heap with the "new" operator. The System takes over ownership of it, and deletes the Force when the System itself is deleted.
           Parameters:
            - force a pointer to the Force object to be added
        """

        if not args[0].thisown:
           s = "the %s object does not own its corresponding OpenMM object" \
              % args[0].__class__.__name__
           raise Exception(s)


        val = _openmm.System_addForce(self, *args)

        args[0].thisown=0


        return val


    def getNumForces(self, *args):
        """
        getNumForces(System self) -> int

        Get the number of Force objects that have been added to the System.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.System_getNumForces(self, *args)


    def getForce(self, *args):
        """
        getForce(System self, int index) -> Force
        getForce(System self, int index) -> Force

        Get a writable reference to one of the Forces in this System.
           Parameters:
            - index the index of the Force to get
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.System_getForce(self, *args)


    def removeForce(self, *args):
        """
        removeForce(System self, int index)

        Remove a Force from the System. The memory associated with the removed Force object is deleted.
           Parameters:
            - index the index of the Force to remove
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.System_removeForce(self, *args)


    def getDefaultPeriodicBoxVectors(self, *args):
        """
        getDefaultPeriodicBoxVectors(System self)

        Get the default values of the vectors defining the axes of the periodic box (measured in nm). Any newly created Context will have its box vectors set to these. They will affect any Force added to the System that uses periodic boundary conditions.
           Parameters:
            - a on exit, this contains the vector defining the first edge of the periodic box
            - b on exit, this contains the vector defining the second edge of the periodic box
            - c on exit, this contains the vector defining the third edge of the periodic box
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.System_getDefaultPeriodicBoxVectors(self, *args)

        val[0]=unit.Quantity(val[0], unit.nanometer)
        val[1]=unit.Quantity(val[1], unit.nanometer)
        val[2]=unit.Quantity(val[2], unit.nanometer)


        return val


    def setDefaultPeriodicBoxVectors(self, *args):
        """
        setDefaultPeriodicBoxVectors(System self, Vec3 const & a, Vec3 const & b, Vec3 const & c)

        Set the default values of the vectors defining the axes of the periodic box (measured in nm). Any newly created Context will have its box vectors set to these. They will affect any Force added to the System that uses periodic boundary conditions.

        Triclinic boxes are supported, but the vectors must satisfy certain requirements. In particular, a must point in the x direction, b must point "mostly" in the y direction, and c must point "mostly" in the z direction. See the documentation for details.
           Parameters:
            - a the vector defining the first edge of the periodic box
            - b the vector defining the second edge of the periodic box
            - c the vector defining the third edge of the periodic box
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.System_setDefaultPeriodicBoxVectors(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(System self) -> bool

        Returns whether or not any forces in this System use periodic boundaries.

        If a force in this System does not implement usesPeriodicBoundaryConditions a OpenMM::OpenMMException is thrown
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.System_usesPeriodicBoundaryConditions(self, *args)


    def __getstate__(self):
        serializationString = XmlSerializer.serializeSystem(self)
        return serializationString

    def __setstate__(self, serializationString):
        system = XmlSerializer.deserializeSystem(serializationString)
        self.this = system.this
    def getForces(self):
        """Get the list of Forces in this System"""
        return [self.getForce(i) for i in range(self.getNumForces())]


    def __init__(self, *args):
        """
        __init__(OpenMM::System self) -> System
        __init__(OpenMM::System self, System other) -> System

        Create a new System.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_System(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
System_swigregister = _openmm.System_swigregister
System_swigregister(System)

class HarmonicAngleForce(Force):
    """This class implements an interaction between groups of three particles that varies harmonically with the angle between them. To use it, create a HarmonicAngleForce object then call addAngle() once for each angle. After an angle has been added, you can modify its force field parameters by calling setAngleParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext()."""
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HarmonicAngleForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HarmonicAngleForce, name)
    __repr__ = _swig_repr

    def getNumAngles(self, *args):
        """
        getNumAngles(HarmonicAngleForce self) -> int

        Get the number of harmonic bond angle terms in the potential function
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.HarmonicAngleForce_getNumAngles(self, *args)


    def addAngle(self, *args):
        """
        addAngle(HarmonicAngleForce self, int particle1, int particle2, int particle3, double angle, double k) -> int

        Add an angle term to the force field.
           Parameters:
            - particle1 the index of the first particle forming the angle
            - particle2 the index of the second particle forming the angle
            - particle3 the index of the third particle forming the angle
            - angle the equilibrium angle, measured in radians
            - k the harmonic force constant for the angle, measured in kJ/mol/radian^2
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.HarmonicAngleForce_addAngle(self, *args)


    def getAngleParameters(self, *args):
        """
        getAngleParameters(HarmonicAngleForce self, int index)

        Get the force field parameters for an angle term.
           Parameters:
            - index the index of the angle for which to get parameters
            - particle1 the index of the first particle forming the angle
            - particle2 the index of the second particle forming the angle
            - particle3 the index of the third particle forming the angle
            - angle the equilibrium angle, measured in radians
            - k the harmonic force constant for the angle, measured in kJ/mol/radian^2
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.HarmonicAngleForce_getAngleParameters(self, *args)

        val[3]=unit.Quantity(val[3], unit.radian)
        val[4]=unit.Quantity(val[4], unit.kilojoule_per_mole/(unit.radian*unit.radian))


        return val


    def setAngleParameters(self, *args):
        """
        setAngleParameters(HarmonicAngleForce self, int index, int particle1, int particle2, int particle3, double angle, double k)

        Set the force field parameters for an angle term.
           Parameters:
            - index the index of the angle for which to set parameters
            - particle1 the index of the first particle forming the angle
            - particle2 the index of the second particle forming the angle
            - particle3 the index of the third particle forming the angle
            - angle the equilibrium angle, measured in radians
            - k the harmonic force constant for the angle, measured in kJ/mol/radian^2
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.HarmonicAngleForce_setAngleParameters(self, *args)


    def updateParametersInContext(self, *args):
        """
        updateParametersInContext(HarmonicAngleForce self, Context context)

        Update the per-angle parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setAngleParameters() to modify this object's parameters, then call updateParametersInContext() to copy them over to the Context.

        The only information this method updates is the values of per-angle parameters. The set of particles involved in a angle cannot be changed, nor can new angles be added.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.HarmonicAngleForce_updateParametersInContext(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(HarmonicAngleForce self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.HarmonicAngleForce_usesPeriodicBoundaryConditions(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::HarmonicAngleForce self) -> HarmonicAngleForce
        __init__(OpenMM::HarmonicAngleForce self, HarmonicAngleForce other) -> HarmonicAngleForce

        Create a HarmonicAngleForce.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_HarmonicAngleForce(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_HarmonicAngleForce
    def __del__(self):
        """__del__(OpenMM::HarmonicAngleForce self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

HarmonicAngleForce_swigregister = _openmm.HarmonicAngleForce_swigregister
HarmonicAngleForce_swigregister(HarmonicAngleForce)

class SerializationProxy(_object):
    """
    A SerializationProxy is an object that knows how to serialize and deserialize objects of a particular type. This is an abstract class. Subclasses implement the logic for serializing particular types of logic.

    A global registry maintains the list of what SerializationProxy to use for each type of object. Call registerProxy() to register the proxy for a particular type. This is typically done at application startup or by a dynamic library's initialization code.
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SerializationProxy, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SerializationProxy, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _openmm.delete_SerializationProxy
    def __del__(self):
        """__del__(OpenMM::SerializationProxy self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass


    def registerProxy(*args):
        """
        registerProxy(std::type_info const & type, SerializationProxy proxy)

        Register a SerializationProxy to be used for objects of a particular type.
           Parameters:
            - type the type_info for the object type
            - proxy the proxy to use for objects of the specified type
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationProxy_registerProxy(*args)

    if _newclass:
        registerProxy = staticmethod(registerProxy)
    __swig_getmethods__["registerProxy"] = lambda x: registerProxy

    def getProxy(*args):
        """
        getProxy(std::string const & typeName) -> SerializationProxy
        getProxy(std::type_info const & type) -> SerializationProxy

        Get the SerializationProxy to use for objects of a particular type, specified by type_info.
           Parameters:
            - type the type_info of the object type to get a proxy for
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationProxy_getProxy(*args)

    if _newclass:
        getProxy = staticmethod(getProxy)
    __swig_getmethods__["getProxy"] = lambda x: getProxy

    def getTypeName(self, *args):
        """
        getTypeName(SerializationProxy self) -> std::string const &

        Get the name of the object type this proxy manipulates, as passed to the constructor.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationProxy_getTypeName(self, *args)


    def serialize(self, *args):
        """
        serialize(SerializationProxy self, void const * object, SerializationNode node)

        Subclasses implement this method to record information about an object being serialized.
           Parameters:
            - object a pointer to the object being serialized
            - node all data to be serialized should be stored into this node, either directly as properties or indirectly by adding child nodes to it
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationProxy_serialize(self, *args)


    def deserialize(self, *args):
        """
        deserialize(SerializationProxy self, SerializationNode node) -> void *

        Reconstruct an object from its serialized data.
           Parameters:
            - node a SerializationNode containing the object's description
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.SerializationProxy_deserialize(self, *args)

SerializationProxy_swigregister = _openmm.SerializationProxy_swigregister
SerializationProxy_swigregister(SerializationProxy)

def SerializationProxy_registerProxy(*args):
    """
    SerializationProxy_registerProxy(std::type_info const & type, SerializationProxy proxy)

    Register a SerializationProxy to be used for objects of a particular type.
       Parameters:
        - type the type_info for the object type
        - proxy the proxy to use for objects of the specified type
    """

    try: args=stripUnits(args)
    except UnboundLocalError: pass


    return _openmm.SerializationProxy_registerProxy(*args)

def SerializationProxy_getProxy(*args):
    """
    getProxy(std::string const & typeName) -> SerializationProxy
    SerializationProxy_getProxy(std::type_info const & type) -> SerializationProxy

    Get the SerializationProxy to use for objects of a particular type, specified by type_info.
       Parameters:
        - type the type_info of the object type to get a proxy for
    """

    try: args=stripUnits(args)
    except UnboundLocalError: pass


    return _openmm.SerializationProxy_getProxy(*args)

class AmoebaMultipoleForce(Force):
    """
    This class implements the Amoeba multipole interaction.

    To use it, create an AmoebaMultipoleForce object then call addMultipole() once for each atom. After an entry has been added, you can modify its force field parameters by calling setMultipoleParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext().
    """
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AmoebaMultipoleForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AmoebaMultipoleForce, name)
    __repr__ = _swig_repr
    NoCutoff = _openmm.AmoebaMultipoleForce_NoCutoff
    PME = _openmm.AmoebaMultipoleForce_PME
    Mutual = _openmm.AmoebaMultipoleForce_Mutual
    Direct = _openmm.AmoebaMultipoleForce_Direct
    ZThenX = _openmm.AmoebaMultipoleForce_ZThenX
    Bisector = _openmm.AmoebaMultipoleForce_Bisector
    ZBisect = _openmm.AmoebaMultipoleForce_ZBisect
    ThreeFold = _openmm.AmoebaMultipoleForce_ThreeFold
    ZOnly = _openmm.AmoebaMultipoleForce_ZOnly
    NoAxisType = _openmm.AmoebaMultipoleForce_NoAxisType
    LastAxisTypeIndex = _openmm.AmoebaMultipoleForce_LastAxisTypeIndex
    Covalent12 = _openmm.AmoebaMultipoleForce_Covalent12
    Covalent13 = _openmm.AmoebaMultipoleForce_Covalent13
    Covalent14 = _openmm.AmoebaMultipoleForce_Covalent14
    Covalent15 = _openmm.AmoebaMultipoleForce_Covalent15
    PolarizationCovalent11 = _openmm.AmoebaMultipoleForce_PolarizationCovalent11
    PolarizationCovalent12 = _openmm.AmoebaMultipoleForce_PolarizationCovalent12
    PolarizationCovalent13 = _openmm.AmoebaMultipoleForce_PolarizationCovalent13
    PolarizationCovalent14 = _openmm.AmoebaMultipoleForce_PolarizationCovalent14
    CovalentEnd = _openmm.AmoebaMultipoleForce_CovalentEnd

    def getNumMultipoles(self, *args):
        """
        getNumMultipoles(AmoebaMultipoleForce self) -> int

        Get the number of particles in the potential function
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_getNumMultipoles(self, *args)


    def getNonbondedMethod(self, *args):
        """
        getNonbondedMethod(AmoebaMultipoleForce self) -> OpenMM::AmoebaMultipoleForce::NonbondedMethod

        Get the method used for handling long-range nonbonded interactions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_getNonbondedMethod(self, *args)


    def setNonbondedMethod(self, *args):
        """
        setNonbondedMethod(AmoebaMultipoleForce self, OpenMM::AmoebaMultipoleForce::NonbondedMethod method)

        Set the method used for handling long-range nonbonded interactions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_setNonbondedMethod(self, *args)


    def getPolarizationType(self, *args):
        """
        getPolarizationType(AmoebaMultipoleForce self) -> OpenMM::AmoebaMultipoleForce::PolarizationType

        Get polarization type
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_getPolarizationType(self, *args)


    def setPolarizationType(self, *args):
        """
        setPolarizationType(AmoebaMultipoleForce self, OpenMM::AmoebaMultipoleForce::PolarizationType type)

        Set the polarization type
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_setPolarizationType(self, *args)


    def getCutoffDistance(self, *args):
        """
        getCutoffDistance(AmoebaMultipoleForce self) -> double

        Get the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaMultipoleForce_getCutoffDistance(self, *args)

        val=unit.Quantity(val, unit.nanometer)


        return val


    def setCutoffDistance(self, *args):
        """
        setCutoffDistance(AmoebaMultipoleForce self, double distance)

        Set the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect.
           Parameters:
            - distance the cutoff distance, measured in nm
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_setCutoffDistance(self, *args)


    def getAEwald(self, *args):
        """
        getAEwald(AmoebaMultipoleForce self) -> double

        Get the Ewald alpha parameter. If this is 0 (the default), a value is chosen automatically based on the Ewald error tolerance.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaMultipoleForce_getAEwald(self, *args)

        val=unit.Quantity(val, 1/unit.nanometer)


        return val


    def setAEwald(self, *args):
        """
        setAEwald(AmoebaMultipoleForce self, double aewald)

        Set the Ewald alpha parameter. If this is 0 (the default), a value is chosen automatically based on the Ewald error tolerance.
           Parameters:
            - Ewald alpha parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_setAEwald(self, *args)


    def getPmeBSplineOrder(self, *args):
        """
        getPmeBSplineOrder(AmoebaMultipoleForce self) -> int

        Get the B-spline order to use for PME charge spreading
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_getPmeBSplineOrder(self, *args)


    def getPmeGridDimensions(self, *args):
        """
        getPmeGridDimensions(AmoebaMultipoleForce self)

        Get the PME grid dimensions. If Ewald alpha is 0 (the default), this is ignored and grid dimensions are chosen automatically based on the Ewald error tolerance.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_getPmeGridDimensions(self, *args)


    def setPmeGridDimensions(self, *args):
        """
        setPmeGridDimensions(AmoebaMultipoleForce self, vectori gridDimension)

        Set the PME grid dimensions. If Ewald alpha is 0 (the default), this is ignored and grid dimensions are chosen automatically based on the Ewald error tolerance.
           Parameters:
            - the PME grid dimensions
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_setPmeGridDimensions(self, *args)


    def addMultipole(self, *args):
        """
        addMultipole(AmoebaMultipoleForce self, double charge, vectord molecularDipole, vectord molecularQuadrupole, int axisType, int multipoleAtomZ, int multipoleAtomX, int multipoleAtomY, double thole, double dampingFactor, double polarity) -> int

        Add multipole-related info for a particle
           Parameters:
            - charge the particle's charge
            - molecularDipole the particle's molecular dipole (vector of size 3)
            - molecularQuadrupole the particle's molecular quadrupole (vector of size 9)
            - axisType the particle's axis type
            - multipoleAtomZ index of first atom used in constructing lab<->molecular frames
            - multipoleAtomX index of second atom used in constructing lab<->molecular frames
            - multipoleAtomY index of second atom used in constructing lab<->molecular frames
            - thole Thole parameter
            - dampingFactor dampingFactor parameter
            - polarity polarity parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_addMultipole(self, *args)


    def getMultipoleParameters(self, *args):
        """
        getMultipoleParameters(AmoebaMultipoleForce self, int index)

        Get the multipole parameters for a particle.
           Parameters:
            - index the index of the atom for which to get parameters
            - charge the particle's charge
            - molecularDipole the particle's molecular dipole (vector of size 3)
            - molecularQuadrupole the particle's molecular quadrupole (vector of size 9)
            - axisType the particle's axis type
            - multipoleAtomZ index of first atom used in constructing lab<->molecular frames
            - multipoleAtomX index of second atom used in constructing lab<->molecular frames
            - multipoleAtomY index of second atom used in constructing lab<->molecular frames
            - thole Thole parameter
            - dampingFactor dampingFactor parameter
            - polarity polarity parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_getMultipoleParameters(self, *args)


    def setMultipoleParameters(self, *args):
        """
        setMultipoleParameters(AmoebaMultipoleForce self, int index, double charge, vectord molecularDipole, vectord molecularQuadrupole, int axisType, int multipoleAtomZ, int multipoleAtomX, int multipoleAtomY, double thole, double dampingFactor, double polarity)

        Set the multipole parameters for a particle.
           Parameters:
            - index the index of the atom for which to set parameters
            - charge the particle's charge
            - molecularDipole the particle's molecular dipole (vector of size 3)
            - molecularQuadrupole the particle's molecular quadrupole (vector of size 9)
            - axisType the particle's axis type
            - multipoleAtomZ index of first atom used in constructing lab<->molecular frames
            - multipoleAtomX index of second atom used in constructing lab<->molecular frames
            - multipoleAtomY index of second atom used in constructing lab<->molecular frames
            - polarity polarity parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_setMultipoleParameters(self, *args)


    def setCovalentMap(self, *args):
        """
        setCovalentMap(AmoebaMultipoleForce self, int index, OpenMM::AmoebaMultipoleForce::CovalentType typeId, vectori covalentAtoms)

        Set the CovalentMap for an atom
           Parameters:
            - index the index of the atom for which to set parameters
            - typeId CovalentTypes type
            - covalentAtoms vector of covalent atoms associated w/ the specfied CovalentType
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_setCovalentMap(self, *args)


    def getCovalentMap(self, *args):
        """
        getCovalentMap(AmoebaMultipoleForce self, int index, OpenMM::AmoebaMultipoleForce::CovalentType typeId)

        Get the CovalentMap for an atom
           Parameters:
            - index the index of the atom for which to set parameters
            - typeId CovalentTypes type
            - covalentAtoms output vector of covalent atoms associated w/ the specfied CovalentType
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_getCovalentMap(self, *args)


    def getCovalentMaps(self, *args):
        """
        getCovalentMaps(AmoebaMultipoleForce self, int index)

        Get the CovalentMap for an atom
           Parameters:
            - index the index of the atom for which to set parameters
            - covalentLists output vector of covalent lists of atoms
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_getCovalentMaps(self, *args)


    def getMutualInducedMaxIterations(self, *args):
        """
        getMutualInducedMaxIterations(AmoebaMultipoleForce self) -> int

        Get the max number of iterations to be used in calculating the mutual induced dipoles
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_getMutualInducedMaxIterations(self, *args)


    def setMutualInducedMaxIterations(self, *args):
        """
        setMutualInducedMaxIterations(AmoebaMultipoleForce self, int inputMutualInducedMaxIterations)

        Set the max number of iterations to be used in calculating the mutual induced dipoles
           Parameters:
            - max number of iterations
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_setMutualInducedMaxIterations(self, *args)


    def getMutualInducedTargetEpsilon(self, *args):
        """
        getMutualInducedTargetEpsilon(AmoebaMultipoleForce self) -> double

        Get the target epsilon to be used to test for convergence of iterative method used in calculating the mutual induced dipoles
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_getMutualInducedTargetEpsilon(self, *args)


    def setMutualInducedTargetEpsilon(self, *args):
        """
        setMutualInducedTargetEpsilon(AmoebaMultipoleForce self, double inputMutualInducedTargetEpsilon)

        Set the target epsilon to be used to test for convergence of iterative method used in calculating the mutual induced dipoles
           Parameters:
            - target epsilon
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_setMutualInducedTargetEpsilon(self, *args)


    def getEwaldErrorTolerance(self, *args):
        """
        getEwaldErrorTolerance(AmoebaMultipoleForce self) -> double

        Get the error tolerance for Ewald summation. This corresponds to the fractional error in the forces which is acceptable. This value is used to select the grid dimensions and separation (alpha) parameter so that the average error level will be less than the tolerance. There is not a rigorous guarantee that all forces on all atoms will be less than the tolerance, however.

        This can be overridden by explicitly setting an alpha parameter and grid dimensions to use.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_getEwaldErrorTolerance(self, *args)


    def setEwaldErrorTolerance(self, *args):
        """
        setEwaldErrorTolerance(AmoebaMultipoleForce self, double tol)

        Get the error tolerance for Ewald summation. This corresponds to the fractional error in the forces which is acceptable. This value is used to select the grid dimensions and separation (alpha) parameter so that the average error level will be less than the tolerance. There is not a rigorous guarantee that all forces on all atoms will be less than the tolerance, however.

        This can be overridden by explicitly setting an alpha parameter and grid dimensions to use.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_setEwaldErrorTolerance(self, *args)


    def getInducedDipoles(self, *args):
        """
        getInducedDipoles(AmoebaMultipoleForce self, Context context)

        Get the induced dipole moments of all particles.
           Parameters:
            - context the Context for which to get the induced dipoles
            - dipoles the induced dipole moment of particle i is stored into the i'th element
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_getInducedDipoles(self, *args)


    def getElectrostaticPotential(self, *args):
        """
        getElectrostaticPotential(AmoebaMultipoleForce self, std::vector< Vec3,std::allocator< Vec3 > > const & inputGrid, Context context)

        Get the electrostatic potential.
           Parameters:
            - inputGrid input grid points over which the potential is to be evaluated
            - context context
            - outputElectrostaticPotential output potential
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_getElectrostaticPotential(self, *args)


    def getSystemMultipoleMoments(self, *args):
        """
        getSystemMultipoleMoments(AmoebaMultipoleForce self, Context context)

        Get the system multipole moments.

        This method is most useful for non-periodic systems. When called for a periodic system, only the <i>lowest nonvanishing moment</i> has a well defined value. This means that if the system has a net nonzero charge, the dipole and quadrupole moments are not well defined and should be ignored. If the net charge is zero, the dipole moment is well defined (and really represents a dipole density), but the quadrupole moment is still undefined and should be ignored.
           Parameters:
            - context context
            - outputMultipoleMoments (charge, dipole_x, dipole_y, dipole_z, quadrupole_xx, quadrupole_xy, quadrupole_xz, quadrupole_yx, quadrupole_yy, quadrupole_yz, quadrupole_zx, quadrupole_zy, quadrupole_zz)
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_getSystemMultipoleMoments(self, *args)


    def updateParametersInContext(self, *args):
        """
        updateParametersInContext(AmoebaMultipoleForce self, Context context)

        Update the multipole parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setMultipoleParameters() to modify this object's parameters, then call updateParametersInContext() to copy them over to the Context.

        This method has several limitations. The only information it updates is the parameters of multipoles. All other aspects of the Force (the nonbonded method, the cutoff distance, etc.) are unaffected and can only be changed by reinitializing the Context. Furthermore, this method cannot be used to add new multipoles, only to change the parameters of existing ones.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_updateParametersInContext(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(AmoebaMultipoleForce self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaMultipoleForce_usesPeriodicBoundaryConditions(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::AmoebaMultipoleForce self) -> AmoebaMultipoleForce
        __init__(OpenMM::AmoebaMultipoleForce self, AmoebaMultipoleForce other) -> AmoebaMultipoleForce

        Create an AmoebaMultipoleForce.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_AmoebaMultipoleForce(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_AmoebaMultipoleForce
    def __del__(self):
        """__del__(OpenMM::AmoebaMultipoleForce self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

AmoebaMultipoleForce_swigregister = _openmm.AmoebaMultipoleForce_swigregister
AmoebaMultipoleForce_swigregister(AmoebaMultipoleForce)

class CustomAngleForce(Force):
    """
    This class implements interactions between sets of three particles that depend on the angle between them. Unlike HarmonicAngleForce, the functional form of the interaction is completely customizable, and may involve arbitrary algebraic expressions. In addition to the angle formed by the particles, it may depend on arbitrary global and per-angle parameters.

    To use this class, create a CustomAngleForce object, passing an algebraic expression to the constructor that defines the interaction energy between each set of particles. The expression may depend on theta, the angle formed by the particles, as well as on any parameters you choose. Then call addPerAngleParameter() to define per-angle parameters, and addGlobalParameter() to define global parameters. The values of per-angle parameters are specified as part of the system definition, while values of global parameters may be modified during a simulation by calling Context::setParameter(). Finally, call addAngle() once for each angle. After an angle has been added, you can modify its parameters by calling setAngleParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext().

    As an example, the following code creates a CustomAngleForce that implements a harmonic potential:

    <tt>CustomAngleForce* force = new CustomAngleForce("0.5*k*(theta-theta0)^2");</tt>

    This force depends on two parameters: the spring constant k and equilibrium angle theta0. The following code defines these parameters:

    <tt><pre>
    force->addPerAngleParameter("k");
    force->addPerAngleParameter("theta0");
    </pre></tt>

    Expressions may involve the operators + (add), - (subtract), * (multiply), / (divide), and ^ (power), and the following functions: sqrt, exp, log, sin, cos, sec, csc, tan, cot, asin, acos, atan, sinh, cosh, tanh, erf, erfc, min, max, abs, floor, ceil, step, delta, select. All trigonometric functions are defined in radians, and log is the natural logarithm. step(x) = 0 if x is less than 0, 1 otherwise. delta(x) = 1 if x is 0, 0 otherwise. select(x,y,z) = z if x = 0, y otherwise.
    """
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomAngleForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomAngleForce, name)
    __repr__ = _swig_repr

    def getNumAngles(self, *args):
        """
        getNumAngles(CustomAngleForce self) -> int

        Get the number of angles for which force field parameters have been defined.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomAngleForce_getNumAngles(self, *args)


    def getNumPerAngleParameters(self, *args):
        """
        getNumPerAngleParameters(CustomAngleForce self) -> int

        Get the number of per-angle parameters that the interaction depends on.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomAngleForce_getNumPerAngleParameters(self, *args)


    def getNumGlobalParameters(self, *args):
        """
        getNumGlobalParameters(CustomAngleForce self) -> int

        Get the number of global parameters that the interaction depends on.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomAngleForce_getNumGlobalParameters(self, *args)


    def getEnergyFunction(self, *args):
        """
        getEnergyFunction(CustomAngleForce self) -> std::string const &

        Get the algebraic expression that gives the interaction energy for each angle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomAngleForce_getEnergyFunction(self, *args)


    def setEnergyFunction(self, *args):
        """
        setEnergyFunction(CustomAngleForce self, std::string const & energy)

        Set the algebraic expression that gives the interaction energy for each angle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomAngleForce_setEnergyFunction(self, *args)


    def addPerAngleParameter(self, *args):
        """
        addPerAngleParameter(CustomAngleForce self, std::string const & name) -> int

        Add a new per-angle parameter that the interaction may depend on.
           Parameters:
            - name the name of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomAngleForce_addPerAngleParameter(self, *args)


    def getPerAngleParameterName(self, *args):
        """
        getPerAngleParameterName(CustomAngleForce self, int index) -> std::string const &

        Get the name of a per-angle parameter.
           Parameters:
            - index the index of the parameter for which to get the name
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomAngleForce_getPerAngleParameterName(self, *args)


    def setPerAngleParameterName(self, *args):
        """
        setPerAngleParameterName(CustomAngleForce self, int index, std::string const & name)

        Set the name of a per-angle parameter.
           Parameters:
            - index the index of the parameter for which to set the name
            - name the name of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomAngleForce_setPerAngleParameterName(self, *args)


    def addGlobalParameter(self, *args):
        """
        addGlobalParameter(CustomAngleForce self, std::string const & name, double defaultValue) -> int

        Add a new global parameter that the interaction may depend on.
           Parameters:
            - name the name of the parameter
            - defaultValue the default value of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomAngleForce_addGlobalParameter(self, *args)


    def getGlobalParameterName(self, *args):
        """
        getGlobalParameterName(CustomAngleForce self, int index) -> std::string const &

        Get the name of a global parameter.
           Parameters:
            - index the index of the parameter for which to get the name
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomAngleForce_getGlobalParameterName(self, *args)


    def setGlobalParameterName(self, *args):
        """
        setGlobalParameterName(CustomAngleForce self, int index, std::string const & name)

        Set the name of a global parameter.
           Parameters:
            - index the index of the parameter for which to set the name
            - name the name of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomAngleForce_setGlobalParameterName(self, *args)


    def getGlobalParameterDefaultValue(self, *args):
        """
        getGlobalParameterDefaultValue(CustomAngleForce self, int index) -> double

        Get the default value of a global parameter.
           Parameters:
            - index the index of the parameter for which to get the default value
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomAngleForce_getGlobalParameterDefaultValue(self, *args)


    def setGlobalParameterDefaultValue(self, *args):
        """
        setGlobalParameterDefaultValue(CustomAngleForce self, int index, double defaultValue)

        Set the default value of a global parameter.
           Parameters:
            - index the index of the parameter for which to set the default value
            - name the default value of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomAngleForce_setGlobalParameterDefaultValue(self, *args)


    def addAngle(self, *args):
        """
        addAngle(CustomAngleForce self, int particle1, int particle2, int particle3, vectord parameters) -> int

        Add an angle term to the force field.
           Parameters:
            - particle1 the index of the first particle connected by the angle
            - particle2 the index of the second particle connected by the angle
            - particle3 the index of the third particle connected by the angle
            - parameters the list of parameters for the new angle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomAngleForce_addAngle(self, *args)


    def getAngleParameters(self, *args):
        """
        getAngleParameters(CustomAngleForce self, int index)

        Get the force field parameters for an angle term.
           Parameters:
            - index the index of the angle for which to get parameters
            - particle1 the index of the first particle connected by the angle
            - particle2 the index of the second particle connected by the angle
            - particle3 the index of the third particle connected by the angle
            - parameters the list of parameters for the angle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomAngleForce_getAngleParameters(self, *args)


    def setAngleParameters(self, *args):
        """
        setAngleParameters(CustomAngleForce self, int index, int particle1, int particle2, int particle3, vectord parameters)

        Set the force field parameters for an angle term.
           Parameters:
            - index the index of the angle for which to set parameters
            - particle1 the index of the first particle connected by the angle
            - particle2 the index of the second particle connected by the angle
            - particle3 the index of the third particle connected by the angle
            - parameters the list of parameters for the angle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomAngleForce_setAngleParameters(self, *args)


    def updateParametersInContext(self, *args):
        """
        updateParametersInContext(CustomAngleForce self, Context context)

        Update the per-angle parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setAngleParameters() to modify this object's parameters, then call updateParametersInContext() to copy them over to the Context.

        This method has several limitations. The only information it updates is the values of per-angle parameters. All other aspects of the Force (such as the energy function) are unaffected and can only be changed by reinitializing the Context. The set of particles involved in a angle cannot be changed, nor can new angles be added.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomAngleForce_updateParametersInContext(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(CustomAngleForce self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomAngleForce_usesPeriodicBoundaryConditions(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::CustomAngleForce self, std::string const & energy) -> CustomAngleForce
        __init__(OpenMM::CustomAngleForce self, CustomAngleForce other) -> CustomAngleForce

        Create a CustomAngleForce.
           Parameters:
            - energy an algebraic expression giving the interaction energy between three particles as a function of theta, the angle between them
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_CustomAngleForce(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_CustomAngleForce
    def __del__(self):
        """__del__(OpenMM::CustomAngleForce self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

CustomAngleForce_swigregister = _openmm.CustomAngleForce_swigregister
CustomAngleForce_swigregister(CustomAngleForce)

class AmoebaAngleForce(Force):
    """
    This class implements an interaction between triplets of particles that varies with the angle between them. The interaction is defined by a 6th order polynomial. Only the quadratic term is set per-angle. The coefficients of the higher order terms each have a single value that is set globally.

    To use it, create an AmoebaAngleForce object then call addAngle() once for each angle. After an angle has been added, you can modify its force field parameters by calling setAngleParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext().
    """
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AmoebaAngleForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AmoebaAngleForce, name)
    __repr__ = _swig_repr

    def getNumAngles(self, *args):
        """
        getNumAngles(AmoebaAngleForce self) -> int

        Get the number of angle stretch terms in the potential function
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaAngleForce_getNumAngles(self, *args)


    def setAmoebaGlobalAngleCubic(self, *args):
        """
        setAmoebaGlobalAngleCubic(AmoebaAngleForce self, double cubicK)

        Set the global cubic term
           Parameters:
            - cubicK the cubic force constant for the angle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaAngleForce_setAmoebaGlobalAngleCubic(self, *args)


    def getAmoebaGlobalAngleCubic(self, *args):
        """
        getAmoebaGlobalAngleCubic(AmoebaAngleForce self) -> double

        Get the global cubic term
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaAngleForce_getAmoebaGlobalAngleCubic(self, *args)


    def setAmoebaGlobalAngleQuartic(self, *args):
        """
        setAmoebaGlobalAngleQuartic(AmoebaAngleForce self, double quarticK)

        Set the global quartic term
           Parameters:
            - quarticK the quartic force constant for the angle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaAngleForce_setAmoebaGlobalAngleQuartic(self, *args)


    def getAmoebaGlobalAngleQuartic(self, *args):
        """
        getAmoebaGlobalAngleQuartic(AmoebaAngleForce self) -> double

        Get the global quartic term
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaAngleForce_getAmoebaGlobalAngleQuartic(self, *args)


    def setAmoebaGlobalAnglePentic(self, *args):
        """
        setAmoebaGlobalAnglePentic(AmoebaAngleForce self, double penticK)

        Set the global pentic term
           Parameters:
            - penticK the pentic force constant for the angle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaAngleForce_setAmoebaGlobalAnglePentic(self, *args)


    def getAmoebaGlobalAnglePentic(self, *args):
        """
        getAmoebaGlobalAnglePentic(AmoebaAngleForce self) -> double

        Get the global pentic term
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaAngleForce_getAmoebaGlobalAnglePentic(self, *args)


    def setAmoebaGlobalAngleSextic(self, *args):
        """
        setAmoebaGlobalAngleSextic(AmoebaAngleForce self, double sexticK)

        Set the global sextic term
           Parameters:
            - sexticK the sextic force constant for the angle
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaAngleForce_setAmoebaGlobalAngleSextic(self, *args)


    def getAmoebaGlobalAngleSextic(self, *args):
        """
        getAmoebaGlobalAngleSextic(AmoebaAngleForce self) -> double

        Get the global sextic term
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaAngleForce_getAmoebaGlobalAngleSextic(self, *args)


    def addAngle(self, *args):
        """
        addAngle(AmoebaAngleForce self, int particle1, int particle2, int particle3, double length, double quadraticK) -> int

        Add an angle term to the force field.
           Parameters:
            - particle1 the index of the first particle connected by the angle
            - particle2 the index of the second particle connected by the angle
            - particle3 the index of the third particle connected by the angle
            - length the angle measured in degrees
            - quadratic k the quadratic force constant for the angle, measured in kJ/mol/radian^2
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaAngleForce_addAngle(self, *args)


    def getAngleParameters(self, *args):
        """
        getAngleParameters(AmoebaAngleForce self, int index)

        Get the force field parameters for an angle term.
           Parameters:
            - index the index of the angle for which to get parameters
            - particle1 the index of the first particle connected by the angle
            - particle2 the index of the second particle connected by the angle
            - particle3 the index of the third particle connected by the angle
            - length the equilibrium angle, measured in degress
            - quadratic k the quadratic force constant for the angle, measured in kJ/mol/radian^2
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaAngleForce_getAngleParameters(self, *args)

        val[3]=unit.Quantity(val[3], unit.radian)
        val[4]=unit.Quantity(val[4], unit.kilojoule_per_mole/(unit.radian*unit.radian))


        return val


    def setAngleParameters(self, *args):
        """
        setAngleParameters(AmoebaAngleForce self, int index, int particle1, int particle2, int particle3, double length, double quadraticK)

        Set the force field parameters for an angle term.
           Parameters:
            - index the index of the angle for which to set parameters
            - particle1 the index of the first particle connected by the angle
            - particle2 the index of the second particle connected by the angle
            - particle3 the index of the third particle connected by the angle
            - length the equilibrium angle, measured in degrees
            - quadratic k the quadratic force constant for the angle, measured in kJ/mol/radian^2
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaAngleForce_setAngleParameters(self, *args)


    def updateParametersInContext(self, *args):
        """
        updateParametersInContext(AmoebaAngleForce self, Context context)

        Update the per-angle parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setAngleParameters() to modify this object's parameters, then call updateParametersInContext() to copy them over to the Context.

        The only information this method updates is the values of per-angle parameters. The set of particles involved in an angle cannot be changed, nor can new angles be added.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaAngleForce_updateParametersInContext(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(AmoebaAngleForce self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaAngleForce_usesPeriodicBoundaryConditions(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::AmoebaAngleForce self) -> AmoebaAngleForce
        __init__(OpenMM::AmoebaAngleForce self, AmoebaAngleForce other) -> AmoebaAngleForce

        Create an AmoebaAngleForce.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_AmoebaAngleForce(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_AmoebaAngleForce
    def __del__(self):
        """__del__(OpenMM::AmoebaAngleForce self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

AmoebaAngleForce_swigregister = _openmm.AmoebaAngleForce_swigregister
AmoebaAngleForce_swigregister(AmoebaAngleForce)

class AmoebaVdwForce(Force):
    """
    This class implements a buffered 14-7 potential used to model van der Waals forces.

    To use it, create an AmoebaVdwForce object then call addParticle() once for each particle. After a particle has been added, you can modify its force field parameters by calling setParticleParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext().

    A unique feature of this class is that the interaction site for a particle does not need to be exactly at the particle's location. Instead, it can be placed a fraction of the distance from that particle to another one. This is typically done for hydrogens to place the interaction site slightly closer to the parent atom. The fraction is known as the "reduction factor", since it reduces the distance from the parent atom to the interaction site.
    """
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AmoebaVdwForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AmoebaVdwForce, name)
    __repr__ = _swig_repr
    NoCutoff = _openmm.AmoebaVdwForce_NoCutoff
    CutoffPeriodic = _openmm.AmoebaVdwForce_CutoffPeriodic

    def getNumParticles(self, *args):
        """
        getNumParticles(AmoebaVdwForce self) -> int

        Get the number of particles
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaVdwForce_getNumParticles(self, *args)


    def setParticleParameters(self, *args):
        """
        setParticleParameters(AmoebaVdwForce self, int particleIndex, int parentIndex, double sigma, double epsilon, double reductionFactor)

        Set the force field parameters for a vdw particle.
           Parameters:
            - particleIndex the particle index
            - parentIndex the index of the parent particle
            - sigma vdw sigma
            - epsilon vdw epsilon
            - reductionFactor the fraction of the distance along the line from the parent particle to this particle at which the interaction site should be placed
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaVdwForce_setParticleParameters(self, *args)


    def getParticleParameters(self, *args):
        """
        getParticleParameters(AmoebaVdwForce self, int particleIndex)

        Get the force field parameters for a vdw particle.
           Parameters:
            - particleIndex the particle index
            - parentIndex the index of the parent particle
            - sigma vdw sigma
            - epsilon vdw epsilon
            - reductionFactor the fraction of the distance along the line from the parent particle to this particle at which the interaction site should be placed
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaVdwForce_getParticleParameters(self, *args)

        val[1]=unit.Quantity(val[1], unit.nanometer)
        val[2]=unit.Quantity(val[2], unit.kilojoule_per_mole)


        return val


    def addParticle(self, *args):
        """
        addParticle(AmoebaVdwForce self, int parentIndex, double sigma, double epsilon, double reductionFactor) -> int

        Add the force field parameters for a vdw particle.
           Parameters:
            - parentIndex the index of the parent particle
            - sigma vdw sigma
            - epsilon vdw epsilon
            - reductionFactor the fraction of the distance along the line from the parent particle to this particle at which the interaction site should be placed
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaVdwForce_addParticle(self, *args)


    def setSigmaCombiningRule(self, *args):
        """
        setSigmaCombiningRule(AmoebaVdwForce self, std::string const & sigmaCombiningRule)

        Set sigma combining rule
           Parameters:
            - sigmaCombiningRule sigma combining rule: 'ARITHMETIC', 'GEOMETRIC'. 'CUBIC-MEAN'
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaVdwForce_setSigmaCombiningRule(self, *args)


    def getSigmaCombiningRule(self, *args):
        """
        getSigmaCombiningRule(AmoebaVdwForce self) -> std::string const &

        Get sigma combining rule
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaVdwForce_getSigmaCombiningRule(self, *args)


    def setEpsilonCombiningRule(self, *args):
        """
        setEpsilonCombiningRule(AmoebaVdwForce self, std::string const & epsilonCombiningRule)

        Set epsilon combining rule
           Parameters:
            - epsilonCombiningRule epsilon combining rule: 'ARITHMETIC', 'GEOMETRIC'. 'HARMONIC', 'HHG'
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaVdwForce_setEpsilonCombiningRule(self, *args)


    def getEpsilonCombiningRule(self, *args):
        """
        getEpsilonCombiningRule(AmoebaVdwForce self) -> std::string const &

        Get epsilon combining rule
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaVdwForce_getEpsilonCombiningRule(self, *args)


    def getUseDispersionCorrection(self, *args):
        """
        getUseDispersionCorrection(AmoebaVdwForce self) -> bool

        Get whether to add a contribution to the energy that approximately represents the effect of VdW interactions beyond the cutoff distance. The energy depends on the volume of the periodic box, and is only applicable when periodic boundary conditions are used. When running simulations at constant pressure, adding this contribution can improve the quality of results.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaVdwForce_getUseDispersionCorrection(self, *args)


    def setUseDispersionCorrection(self, *args):
        """
        setUseDispersionCorrection(AmoebaVdwForce self, bool useCorrection)

        Set whether to add a contribution to the energy that approximately represents the effect of VdW interactions beyond the cutoff distance. The energy depends on the volume of the periodic box, and is only applicable when periodic boundary conditions are used. When running simulations at constant pressure, adding this contribution can improve the quality of results.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaVdwForce_setUseDispersionCorrection(self, *args)


    def setParticleExclusions(self, *args):
        """
        setParticleExclusions(AmoebaVdwForce self, int particleIndex, vectori exclusions)

        Set exclusions for specified particle
           Parameters:
            - particleIndex particle index
            - exclusions vector of exclusions
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaVdwForce_setParticleExclusions(self, *args)


    def getParticleExclusions(self, *args):
        """
        getParticleExclusions(AmoebaVdwForce self, int particleIndex)

        Get exclusions for specified particle
           Parameters:
            - particleIndex particle index
            - exclusions vector of exclusions
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaVdwForce_getParticleExclusions(self, *args)


    def setCutoff(self, *args):
        """
        setCutoff(AmoebaVdwForce self, double cutoff)

        Set the cutoff distance.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaVdwForce_setCutoff(self, *args)


    def getCutoff(self, *args):
        """
        getCutoff(AmoebaVdwForce self) -> double

        Get the cutoff distance.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaVdwForce_getCutoff(self, *args)

        val=unit.Quantity(val, unit.nanometer)


        return val


    def getNonbondedMethod(self, *args):
        """
        getNonbondedMethod(AmoebaVdwForce self) -> OpenMM::AmoebaVdwForce::NonbondedMethod

        Get the method used for handling long range nonbonded interactions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaVdwForce_getNonbondedMethod(self, *args)


    def setNonbondedMethod(self, *args):
        """
        setNonbondedMethod(AmoebaVdwForce self, OpenMM::AmoebaVdwForce::NonbondedMethod method)

        Set the method used for handling long range nonbonded interactions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaVdwForce_setNonbondedMethod(self, *args)


    def updateParametersInContext(self, *args):
        """
        updateParametersInContext(AmoebaVdwForce self, Context context)

        Update the per-particle parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setParticleParameters() to modify this object's parameters, then call updateParametersInContext() to copy them over to the Context.

        The only information this method updates is the values of per-particle parameters. All other aspects of the Force (the nonbonded method, the cutoff distance, etc.) are unaffected and can only be changed by reinitializing the Context.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaVdwForce_updateParametersInContext(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(AmoebaVdwForce self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaVdwForce_usesPeriodicBoundaryConditions(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::AmoebaVdwForce self) -> AmoebaVdwForce
        __init__(OpenMM::AmoebaVdwForce self, AmoebaVdwForce other) -> AmoebaVdwForce

        Create an Amoeba VdwForce.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_AmoebaVdwForce(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_AmoebaVdwForce
    def __del__(self):
        """__del__(OpenMM::AmoebaVdwForce self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

AmoebaVdwForce_swigregister = _openmm.AmoebaVdwForce_swigregister
AmoebaVdwForce_swigregister(AmoebaVdwForce)

class DrudeLangevinIntegrator(Integrator):
    """
    This Integrator simulates systems that include Drude particles. It applies two different Langevin thermostats to different parts of the system. The first is applied to ordinary particles (ones that are not part of a Drude particle pair), as well as to the center of mass of each Drude particle pair. A second thermostat, typically with a much lower temperature, is applied to the relative internal displacement of each pair.

    This Integrator requires the System to include a DrudeForce, which it uses to identify the Drude particles.
    """
    __swig_setmethods__ = {}
    for _s in [Integrator]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DrudeLangevinIntegrator, name, value)
    __swig_getmethods__ = {}
    for _s in [Integrator]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DrudeLangevinIntegrator, name)
    __repr__ = _swig_repr

    def getTemperature(self, *args):
        """
        getTemperature(DrudeLangevinIntegrator self) -> double

        Get the temperature of the main heat bath (in Kelvin).
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.DrudeLangevinIntegrator_getTemperature(self, *args)

        val=unit.Quantity(val, unit.kelvin)


        return val


    def setTemperature(self, *args):
        """
        setTemperature(DrudeLangevinIntegrator self, double temp)

        Set the temperature of the main heat bath (in Kelvin).
           Parameters:
            - temp the temperature of the heat bath, measured in Kelvin
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.DrudeLangevinIntegrator_setTemperature(self, *args)


    def getFriction(self, *args):
        """
        getFriction(DrudeLangevinIntegrator self) -> double

        Get the friction coefficient which determines how strongly the system is coupled to the main heat bath (in inverse ps).
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.DrudeLangevinIntegrator_getFriction(self, *args)

        val=unit.Quantity(val, 1/unit.picosecond)


        return val


    def setFriction(self, *args):
        """
        setFriction(DrudeLangevinIntegrator self, double coeff)

        Set the friction coefficient which determines how strongly the system is coupled to the main heat bath (in inverse ps).
           Parameters:
            - coeff the friction coefficient, measured in 1/ps
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.DrudeLangevinIntegrator_setFriction(self, *args)


    def getDrudeTemperature(self, *args):
        """
        getDrudeTemperature(DrudeLangevinIntegrator self) -> double

        Get the temperature of the heat bath applied to internal coordinates of Drude particles (in Kelvin).
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.DrudeLangevinIntegrator_getDrudeTemperature(self, *args)

        val=unit.Quantity(val, unit.kelvin)


        return val


    def setDrudeTemperature(self, *args):
        """
        setDrudeTemperature(DrudeLangevinIntegrator self, double temp)

        Set the temperature of the heat bath applied to internal coordinates of Drude particles (in Kelvin).
           Parameters:
            - temp the temperature of the heat bath, measured in Kelvin
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.DrudeLangevinIntegrator_setDrudeTemperature(self, *args)


    def getDrudeFriction(self, *args):
        """
        getDrudeFriction(DrudeLangevinIntegrator self) -> double

        Get the friction coefficient which determines how strongly the internal coordinates of Drude particles are coupled to the heat bath (in inverse ps).
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.DrudeLangevinIntegrator_getDrudeFriction(self, *args)

        val=unit.Quantity(val, 1/unit.picosecond)


        return val


    def setDrudeFriction(self, *args):
        """
        setDrudeFriction(DrudeLangevinIntegrator self, double coeff)

        Set the friction coefficient which determines how strongly the internal coordinates of Drude particles are coupled to the heat bath (in inverse ps).
           Parameters:
            - coeff the friction coefficient, measured in 1/ps
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.DrudeLangevinIntegrator_setDrudeFriction(self, *args)


    def getRandomNumberSeed(self, *args):
        """
        getRandomNumberSeed(DrudeLangevinIntegrator self) -> int

        Get the random number seed. See setRandomNumberSeed() for details.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.DrudeLangevinIntegrator_getRandomNumberSeed(self, *args)


    def setRandomNumberSeed(self, *args):
        """
        setRandomNumberSeed(DrudeLangevinIntegrator self, int seed)

        Set the random number seed. The precise meaning of this parameter is undefined, and is left up to each Platform to interpret in an appropriate way. It is guaranteed that if two simulations are run with different random number seeds, the sequence of random forces will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically.

        If seed is set to 0 (which is the default value assigned), a unique seed is chosen when a Context is created from this Force. This is done to ensure that each Context receives unique random seeds without you needing to set them explicitly.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.DrudeLangevinIntegrator_setRandomNumberSeed(self, *args)


    def step(self, *args):
        """
        step(DrudeLangevinIntegrator self, int steps)

        Advance a simulation through time by taking a series of time steps.
           Parameters:
            - steps the number of time steps to take
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.DrudeLangevinIntegrator_step(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::DrudeLangevinIntegrator self, double temperature, double frictionCoeff, double drudeTemperature, double drudeFrictionCoeff, double stepSize) -> DrudeLangevinIntegrator
        __init__(OpenMM::DrudeLangevinIntegrator self, DrudeLangevinIntegrator other) -> DrudeLangevinIntegrator

        Create a DrudeLangevinIntegrator.
           Parameters:
            - temperature the temperature of the main heat bath (in Kelvin)
            - frictionCoeff the friction coefficient which couples the system to the main heat bath (in inverse picoseconds)
            - drudeTemperature the temperature of the heat bath applied to internal coordinates of Drude particles (in Kelvin)
            - drudeFrictionCoeff the friction coefficient which couples the system to the heat bath applied to internal coordinates of Drude particles (in inverse picoseconds)
            - stepSize the step size with which to integrator the system (in picoseconds)
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_DrudeLangevinIntegrator(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_DrudeLangevinIntegrator
    def __del__(self):
        """__del__(OpenMM::DrudeLangevinIntegrator self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

DrudeLangevinIntegrator_swigregister = _openmm.DrudeLangevinIntegrator_swigregister
DrudeLangevinIntegrator_swigregister(DrudeLangevinIntegrator)

class AndersenThermostat(Force):
    """This class uses the Andersen method to maintain constant temperature."""
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AndersenThermostat, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AndersenThermostat, name)
    __repr__ = _swig_repr

    def Temperature(*args):
        """
        Temperature() -> std::string const &

        This is the name of the parameter which stores the current temperature of the heat bath (in Kelvin).
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AndersenThermostat_Temperature(*args)

    if _newclass:
        Temperature = staticmethod(Temperature)
    __swig_getmethods__["Temperature"] = lambda x: Temperature

    def CollisionFrequency(*args):
        """
        CollisionFrequency() -> std::string const &

        This is the name of the parameter which store the current collision frequency (in 1/ps).
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AndersenThermostat_CollisionFrequency(*args)

    if _newclass:
        CollisionFrequency = staticmethod(CollisionFrequency)
    __swig_getmethods__["CollisionFrequency"] = lambda x: CollisionFrequency

    def getDefaultTemperature(self, *args):
        """
        getDefaultTemperature(AndersenThermostat self) -> double

        Get the default temperature of the heat bath (in Kelvin).
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AndersenThermostat_getDefaultTemperature(self, *args)

        val=unit.Quantity(val, unit.kelvin)


        return val


    def setDefaultTemperature(self, *args):
        """
        setDefaultTemperature(AndersenThermostat self, double temperature)

        Set the default temperature of the heat bath. This will affect any new Contexts you create, but not ones that already exist.
           Parameters:
            - temperature the default temperature of the heat bath (in Kelvin)
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AndersenThermostat_setDefaultTemperature(self, *args)


    def getDefaultCollisionFrequency(self, *args):
        """
        getDefaultCollisionFrequency(AndersenThermostat self) -> double

        Get the default collision frequency (in 1/ps).
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AndersenThermostat_getDefaultCollisionFrequency(self, *args)

        val=unit.Quantity(val, 1/unit.picosecond)


        return val


    def setDefaultCollisionFrequency(self, *args):
        """
        setDefaultCollisionFrequency(AndersenThermostat self, double frequency)

        Set the default collision frequency. This will affect any new Contexts you create, but not ones that already exist.
           Parameters:
            - frequency the default collision frequency (in 1/ps)
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AndersenThermostat_setDefaultCollisionFrequency(self, *args)


    def getRandomNumberSeed(self, *args):
        """
        getRandomNumberSeed(AndersenThermostat self) -> int

        Get the random number seed. See setRandomNumberSeed() for details.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AndersenThermostat_getRandomNumberSeed(self, *args)


    def setRandomNumberSeed(self, *args):
        """
        setRandomNumberSeed(AndersenThermostat self, int seed)

        Set the random number seed. The precise meaning of this parameter is undefined, and is left up to each Platform to interpret in an appropriate way. It is guaranteed that if two simulations are run with different random number seeds, the sequence of collisions will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically.

        If seed is set to 0 (which is the default value assigned), a unique seed is chosen when a Context is created from this Force. This is done to ensure that each Context receives unique random seeds without you needing to set them explicitly.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AndersenThermostat_setRandomNumberSeed(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(AndersenThermostat self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AndersenThermostat_usesPeriodicBoundaryConditions(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::AndersenThermostat self, double defaultTemperature, double defaultCollisionFrequency) -> AndersenThermostat
        __init__(OpenMM::AndersenThermostat self, AndersenThermostat other) -> AndersenThermostat

        Create an AndersenThermostat.
           Parameters:
            - defaultTemperature the default temperature of the heat bath (in Kelvin)
            - defaultCollisionFrequency the default collision frequency (in 1/ps)
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_AndersenThermostat(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_AndersenThermostat
    def __del__(self):
        """__del__(OpenMM::AndersenThermostat self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

AndersenThermostat_swigregister = _openmm.AndersenThermostat_swigregister
AndersenThermostat_swigregister(AndersenThermostat)

def AndersenThermostat_Temperature(*args):
    """
    AndersenThermostat_Temperature() -> std::string const &

    This is the name of the parameter which stores the current temperature of the heat bath (in Kelvin).
    """

    try: args=stripUnits(args)
    except UnboundLocalError: pass


    return _openmm.AndersenThermostat_Temperature(*args)

def AndersenThermostat_CollisionFrequency(*args):
    """
    AndersenThermostat_CollisionFrequency() -> std::string const &

    This is the name of the parameter which store the current collision frequency (in 1/ps).
    """

    try: args=stripUnits(args)
    except UnboundLocalError: pass


    return _openmm.AndersenThermostat_CollisionFrequency(*args)

class HarmonicBondForce(Force):
    """This class implements an interaction between pairs of particles that varies harmonically with the distance between them. To use it, create a HarmonicBondForce object then call addBond() once for each bond. After a bond has been added, you can modify its force field parameters by calling setBondParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext()."""
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HarmonicBondForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HarmonicBondForce, name)
    __repr__ = _swig_repr

    def getNumBonds(self, *args):
        """
        getNumBonds(HarmonicBondForce self) -> int

        Get the number of harmonic bond stretch terms in the potential function
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.HarmonicBondForce_getNumBonds(self, *args)


    def addBond(self, *args):
        """
        addBond(HarmonicBondForce self, int particle1, int particle2, double length, double k) -> int

        Add a bond term to the force field.
           Parameters:
            - particle1 the index of the first particle connected by the bond
            - particle2 the index of the second particle connected by the bond
            - length the equilibrium length of the bond, measured in nm
            - k the harmonic force constant for the bond, measured in kJ/mol/nm^2
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.HarmonicBondForce_addBond(self, *args)


    def getBondParameters(self, *args):
        """
        getBondParameters(HarmonicBondForce self, int index)

        Get the force field parameters for a bond term.
           Parameters:
            - index the index of the bond for which to get parameters
            - particle1 the index of the first particle connected by the bond
            - particle2 the index of the second particle connected by the bond
            - length the equilibrium length of the bond, measured in nm
            - k the harmonic force constant for the bond, measured in kJ/mol/nm^2
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.HarmonicBondForce_getBondParameters(self, *args)

        val[2]=unit.Quantity(val[2], unit.nanometer)
        val[3]=unit.Quantity(val[3], unit.kilojoule_per_mole/(unit.nanometer*unit.nanometer))


        return val


    def setBondParameters(self, *args):
        """
        setBondParameters(HarmonicBondForce self, int index, int particle1, int particle2, double length, double k)

        Set the force field parameters for a bond term.
           Parameters:
            - index the index of the bond for which to set parameters
            - particle1 the index of the first particle connected by the bond
            - particle2 the index of the second particle connected by the bond
            - length the equilibrium length of the bond, measured in nm
            - k the harmonic force constant for the bond, measured in kJ/mol/nm^2
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.HarmonicBondForce_setBondParameters(self, *args)


    def updateParametersInContext(self, *args):
        """
        updateParametersInContext(HarmonicBondForce self, Context context)

        Update the per-bond parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setBondParameters() to modify this object's parameters, then call updateParametersInContext() to copy them over to the Context.

        The only information this method updates is the values of per-bond parameters. The set of particles involved in a bond cannot be changed, nor can new bonds be added.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.HarmonicBondForce_updateParametersInContext(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(HarmonicBondForce self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.HarmonicBondForce_usesPeriodicBoundaryConditions(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::HarmonicBondForce self) -> HarmonicBondForce
        __init__(OpenMM::HarmonicBondForce self, HarmonicBondForce other) -> HarmonicBondForce

        Create a HarmonicBondForce.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_HarmonicBondForce(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_HarmonicBondForce
    def __del__(self):
        """__del__(OpenMM::HarmonicBondForce self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

HarmonicBondForce_swigregister = _openmm.HarmonicBondForce_swigregister
HarmonicBondForce_swigregister(HarmonicBondForce)

class CMAPTorsionForce(Force):
    """
    This class implements an interaction between pairs of dihedral angles. The interaction energy is defined by an "energy correction map" (CMAP), which is simply a set of tabulated energy values on a regular grid of (phi, psi) angles. Natural cubic spline interpolation is used to compute forces and energies at arbitrary values of the two angles.

    To use this class, first create one or more energy correction maps by calling addMap(). For each one, you provide an array of energies at uniformly spaced values of the two angles. Next, add interactions by calling addTorsion(). For each one, you specify the sequence of particles used to calculate each of the two dihedral angles, and the index of the map used to calculate their interaction energy.
    """
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CMAPTorsionForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CMAPTorsionForce, name)
    __repr__ = _swig_repr

    def getNumMaps(self, *args):
        """
        getNumMaps(CMAPTorsionForce self) -> int

        Get the number of maps that have been defined.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CMAPTorsionForce_getNumMaps(self, *args)


    def getNumTorsions(self, *args):
        """
        getNumTorsions(CMAPTorsionForce self) -> int

        Get the number of CMAP torsion terms in the potential function
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CMAPTorsionForce_getNumTorsions(self, *args)


    def addMap(self, *args):
        """
        addMap(CMAPTorsionForce self, int size, vectord energy) -> int

        Create a new map that can be used for torsion pairs.
           Parameters:
            - size the size of the map along each dimension
            - energy the energy values for the map. This must be of length size*size. The element energy[i+size*j] contains the energy when the first torsion angle equals i*2*PI/size and the second torsion angle equals j*2*PI/size.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CMAPTorsionForce_addMap(self, *args)


    def getMapParameters(self, *args):
        """
        getMapParameters(CMAPTorsionForce self, int index)

        Get the energy values of a map.
           Parameters:
            - index the index of the map for which to get energy values
            - size the size of the map along each dimension
            - energy the energy values for the map. This must be of length size*size. The element energy[i+size*j] contains the energy when the first torsion angle equals i*2*PI/size and the second torsion angle equals j*2*PI/size.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CMAPTorsionForce_getMapParameters(self, *args)


    def setMapParameters(self, *args):
        """
        setMapParameters(CMAPTorsionForce self, int index, int size, vectord energy)

        Set the energy values of a map.
           Parameters:
            - index the index of the map for which to set energy values
            - size the size of the map along each dimension
            - energy the energy values for the map. This must be of length size*size. The element energy[i+size*j] contains the energy when the first torsion angle equals i*2*PI/size and the second torsion angle equals j*2*PI/size.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CMAPTorsionForce_setMapParameters(self, *args)


    def addTorsion(self, *args):
        """
        addTorsion(CMAPTorsionForce self, int map, int a1, int a2, int a3, int a4, int b1, int b2, int b3, int b4) -> int

        Add a CMAP torsion term to the force field.
           Parameters:
            - map the index of the map to use for this term
            - a1 the index of the first particle forming the first torsion
            - a2 the index of the second particle forming the first torsion
            - a3 the index of the third particle forming the first torsion
            - a4 the index of the fourth particle forming the first torsion
            - b1 the index of the first particle forming the second torsion
            - b2 the index of the second particle forming the second torsion
            - b3 the index of the third particle forming the second torsion
            - b4 the index of the fourth particle forming the second torsion
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CMAPTorsionForce_addTorsion(self, *args)


    def getTorsionParameters(self, *args):
        """
        getTorsionParameters(CMAPTorsionForce self, int index)

        Get the force field parameters for a CMAP torsion term.
           Parameters:
            - index the index of the torsion for which to get parameters
            - map the index of the map to use for this term
            - a1 the index of the first particle forming the first torsion
            - a2 the index of the second particle forming the first torsion
            - a3 the index of the third particle forming the first torsion
            - a4 the index of the fourth particle forming the first torsion
            - b1 the index of the first particle forming the second torsion
            - b2 the index of the second particle forming the second torsion
            - b3 the index of the third particle forming the second torsion
            - b4 the index of the fourth particle forming the second torsion
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CMAPTorsionForce_getTorsionParameters(self, *args)


    def setTorsionParameters(self, *args):
        """
        setTorsionParameters(CMAPTorsionForce self, int index, int map, int a1, int a2, int a3, int a4, int b1, int b2, int b3, int b4)

        Set the force field parameters for a CMAP torsion term.
           Parameters:
            - index the index of the torsion for which to set parameters
            - map the index of the map to use for this term
            - a1 the index of the first particle forming the first torsion
            - a2 the index of the second particle forming the first torsion
            - a3 the index of the third particle forming the first torsion
            - a4 the index of the fourth particle forming the first torsion
            - b1 the index of the first particle forming the second torsion
            - b2 the index of the second particle forming the second torsion
            - b3 the index of the third particle forming the second torsion
            - b4 the index of the fourth particle forming the second torsion
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CMAPTorsionForce_setTorsionParameters(self, *args)


    def updateParametersInContext(self, *args):
        """
        updateParametersInContext(CMAPTorsionForce self, Context context)

        Update the map and torsion parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setMapParameters() and setTorsionParameters() to modify this object's parameters, then call updateParametersInContext() to copy them over to the Context.

        The only information that can be updated with this method is the energy values for a map, and the map index for a torsion. The size of a map and the set of particles involved in a torsion cannot be changed. Also, new bonds and torsions cannot be added.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CMAPTorsionForce_updateParametersInContext(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(CMAPTorsionForce self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CMAPTorsionForce_usesPeriodicBoundaryConditions(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::CMAPTorsionForce self) -> CMAPTorsionForce
        __init__(OpenMM::CMAPTorsionForce self, CMAPTorsionForce other) -> CMAPTorsionForce

        Create a CMAPTorsionForce.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_CMAPTorsionForce(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_CMAPTorsionForce
    def __del__(self):
        """__del__(OpenMM::CMAPTorsionForce self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

CMAPTorsionForce_swigregister = _openmm.CMAPTorsionForce_swigregister
CMAPTorsionForce_swigregister(CMAPTorsionForce)

class CustomBondForce(Force):
    """
    This class implements bonded interactions between pairs of particles. Unlike HarmonicBondForce, the functional form of the interaction is completely customizable, and may involve arbitrary algebraic expressions. It may depend on the distance between particles, as well as on arbitrary global and per-bond parameters.

    To use this class, create a CustomBondForce object, passing an algebraic expression to the constructor that defines the interaction energy between each pair of bonded particles. The expression may depend on r, the distance between the particles, as well as on any parameters you choose. Then call addPerBondParameter() to define per-bond parameters, and addGlobalParameter() to define global parameters. The values of per-bond parameters are specified as part of the system definition, while values of global parameters may be modified during a simulation by calling Context::setParameter(). Finally, call addBond() once for each bond. After a bond has been added, you can modify its parameters by calling setBondParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext().

    As an example, the following code creates a CustomBondForce that implements a harmonic potential:

    <tt>CustomBondForce* force = new CustomBondForce("0.5*k*(r-r0)^2");</tt>

    This force depends on two parameters: the spring constant k and equilibrium distance r0. The following code defines these parameters:

    <tt><pre>
    force->addPerBondParameter("k");
    force->addPerBondParameter("r0");
    </pre></tt>

    Expressions may involve the operators + (add), - (subtract), * (multiply), / (divide), and ^ (power), and the following functions: sqrt, exp, log, sin, cos, sec, csc, tan, cot, asin, acos, atan, sinh, cosh, tanh, erf, erfc, min, max, abs, floor, ceil, step, delta, select. All trigonometric functions are defined in radians, and log is the natural logarithm. step(x) = 0 if x is less than 0, 1 otherwise. delta(x) = 1 if x is 0, 0 otherwise. select(x,y,z) = z if x = 0, y otherwise.
    """
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomBondForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomBondForce, name)
    __repr__ = _swig_repr

    def getNumBonds(self, *args):
        """
        getNumBonds(CustomBondForce self) -> int

        Get the number of bonds for which force field parameters have been defined.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomBondForce_getNumBonds(self, *args)


    def getNumPerBondParameters(self, *args):
        """
        getNumPerBondParameters(CustomBondForce self) -> int

        Get the number of per-bond parameters that the interaction depends on.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomBondForce_getNumPerBondParameters(self, *args)


    def getNumGlobalParameters(self, *args):
        """
        getNumGlobalParameters(CustomBondForce self) -> int

        Get the number of global parameters that the interaction depends on.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomBondForce_getNumGlobalParameters(self, *args)


    def getEnergyFunction(self, *args):
        """
        getEnergyFunction(CustomBondForce self) -> std::string const &

        Get the algebraic expression that gives the interaction energy for each bond
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomBondForce_getEnergyFunction(self, *args)


    def setEnergyFunction(self, *args):
        """
        setEnergyFunction(CustomBondForce self, std::string const & energy)

        Set the algebraic expression that gives the interaction energy for each bond
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomBondForce_setEnergyFunction(self, *args)


    def addPerBondParameter(self, *args):
        """
        addPerBondParameter(CustomBondForce self, std::string const & name) -> int

        Add a new per-bond parameter that the interaction may depend on.
           Parameters:
            - name the name of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomBondForce_addPerBondParameter(self, *args)


    def getPerBondParameterName(self, *args):
        """
        getPerBondParameterName(CustomBondForce self, int index) -> std::string const &

        Get the name of a per-bond parameter.
           Parameters:
            - index the index of the parameter for which to get the name
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomBondForce_getPerBondParameterName(self, *args)


    def setPerBondParameterName(self, *args):
        """
        setPerBondParameterName(CustomBondForce self, int index, std::string const & name)

        Set the name of a per-bond parameter.
           Parameters:
            - index the index of the parameter for which to set the name
            - name the name of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomBondForce_setPerBondParameterName(self, *args)


    def addGlobalParameter(self, *args):
        """
        addGlobalParameter(CustomBondForce self, std::string const & name, double defaultValue) -> int

        Add a new global parameter that the interaction may depend on.
           Parameters:
            - name the name of the parameter
            - defaultValue the default value of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomBondForce_addGlobalParameter(self, *args)


    def getGlobalParameterName(self, *args):
        """
        getGlobalParameterName(CustomBondForce self, int index) -> std::string const &

        Get the name of a global parameter.
           Parameters:
            - index the index of the parameter for which to get the name
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomBondForce_getGlobalParameterName(self, *args)


    def setGlobalParameterName(self, *args):
        """
        setGlobalParameterName(CustomBondForce self, int index, std::string const & name)

        Set the name of a global parameter.
           Parameters:
            - index the index of the parameter for which to set the name
            - name the name of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomBondForce_setGlobalParameterName(self, *args)


    def getGlobalParameterDefaultValue(self, *args):
        """
        getGlobalParameterDefaultValue(CustomBondForce self, int index) -> double

        Get the default value of a global parameter.
           Parameters:
            - index the index of the parameter for which to get the default value
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomBondForce_getGlobalParameterDefaultValue(self, *args)


    def setGlobalParameterDefaultValue(self, *args):
        """
        setGlobalParameterDefaultValue(CustomBondForce self, int index, double defaultValue)

        Set the default value of a global parameter.
           Parameters:
            - index the index of the parameter for which to set the default value
            - name the default value of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomBondForce_setGlobalParameterDefaultValue(self, *args)


    def addBond(self, *args):
        """
        addBond(CustomBondForce self, int particle1, int particle2, vectord parameters) -> int

        Add a bond term to the force field.
           Parameters:
            - particle1 the index of the first particle connected by the bond
            - particle2 the index of the second particle connected by the bond
            - parameters the list of parameters for the new bond
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomBondForce_addBond(self, *args)


    def getBondParameters(self, *args):
        """
        getBondParameters(CustomBondForce self, int index)

        Get the force field parameters for a bond term.
           Parameters:
            - index the index of the bond for which to get parameters
            - particle1 the index of the first particle connected by the bond
            - particle2 the index of the second particle connected by the bond
            - parameters the list of parameters for the bond
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomBondForce_getBondParameters(self, *args)


    def setBondParameters(self, *args):
        """
        setBondParameters(CustomBondForce self, int index, int particle1, int particle2, vectord parameters)

        Set the force field parameters for a bond term.
           Parameters:
            - index the index of the bond for which to set parameters
            - particle1 the index of the first particle connected by the bond
            - particle2 the index of the second particle connected by the bond
            - parameters the list of parameters for the bond
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomBondForce_setBondParameters(self, *args)


    def updateParametersInContext(self, *args):
        """
        updateParametersInContext(CustomBondForce self, Context context)

        Update the per-bond parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setBondParameters() to modify this object's parameters, then call updateParametersInContext() to copy them over to the Context.

        This method has several limitations. The only information it updates is the values of per-bond parameters. All other aspects of the Force (such as the energy function) are unaffected and can only be changed by reinitializing the Context. The set of particles involved in a bond cannot be changed, nor can new bonds be added.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomBondForce_updateParametersInContext(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(CustomBondForce self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomBondForce_usesPeriodicBoundaryConditions(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::CustomBondForce self, std::string const & energy) -> CustomBondForce
        __init__(OpenMM::CustomBondForce self, CustomBondForce other) -> CustomBondForce

        Create a CustomBondForce.
           Parameters:
            - energy an algebraic expression giving the interaction energy between two bonded particles as a function of r, the distance between them
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_CustomBondForce(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_CustomBondForce
    def __del__(self):
        """__del__(OpenMM::CustomBondForce self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

CustomBondForce_swigregister = _openmm.CustomBondForce_swigregister
CustomBondForce_swigregister(CustomBondForce)

class Continuous2DFunction(TabulatedFunction):
    """This is a TabulatedFunction that computes a continuous two dimensional function."""
    __swig_setmethods__ = {}
    for _s in [TabulatedFunction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Continuous2DFunction, name, value)
    __swig_getmethods__ = {}
    for _s in [TabulatedFunction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Continuous2DFunction, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OpenMM::Continuous2DFunction self, int xsize, int ysize, vectord values, double xmin, double xmax, double ymin, double ymax) -> Continuous2DFunction

        This is a TabulatedFunction that computes a continuous two dimensional function.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_Continuous2DFunction(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def getFunctionParameters(self, *args):
        """getFunctionParameters(Continuous2DFunction self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Continuous2DFunction_getFunctionParameters(self, *args)


    def setFunctionParameters(self, *args):
        """setFunctionParameters(Continuous2DFunction self, int xsize, int ysize, vectord values, double xmin, double xmax, double ymin, double ymax)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Continuous2DFunction_setFunctionParameters(self, *args)


    def Copy(self, *args):
        """Copy(Continuous2DFunction self) -> Continuous2DFunction"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.Continuous2DFunction_Copy(self, *args)

    __swig_destroy__ = _openmm.delete_Continuous2DFunction
    def __del__(self):
        """__del__(OpenMM::Continuous2DFunction self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

Continuous2DFunction_swigregister = _openmm.Continuous2DFunction_swigregister
Continuous2DFunction_swigregister(Continuous2DFunction)

class AmoebaStretchBendForce(Force):
    """
    This class implements the Amoeba stretch-bend interaction.

    To use it, create a StretchBendForce object then call addStretchBend() once for each stretch-bend. After a stretch-bend has been added, you can modify its force field parameters by calling setStretchBendParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext().
    """
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AmoebaStretchBendForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AmoebaStretchBendForce, name)
    __repr__ = _swig_repr

    def getNumStretchBends(self, *args):
        """
        getNumStretchBends(AmoebaStretchBendForce self) -> int

        Get the number of stretch-bend terms in the potential function
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaStretchBendForce_getNumStretchBends(self, *args)


    def addStretchBend(self, *args):
        """
        addStretchBend(AmoebaStretchBendForce self, int particle1, int particle2, int particle3, double lengthAB, double lengthCB, double angle, double k1, double k2) -> int

        Add a stretch-bend term to the force field.
           Parameters:
            - particle1 the index of the first particle connected by the stretch-bend
            - particle2 the index of the second particle connected by the stretch-bend
            - particle3 the index of the third particle connected by the stretch-bend
            - lengthAB the equilibrium length of the stretch-bend in bond ab [particle1, particle2], measured in nm
            - lengthCB the equilibrium length of the stretch-bend in bond cb [particle3, particle2], measured in nm
            - angle the equilibrium angle in radians
            - k1 the force constant of the product of bond ab and angle a-b-c
            - k2 the force constant of the product of bond bc and angle a-b-c (optional, default is the same as k1)
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaStretchBendForce_addStretchBend(self, *args)


    def getStretchBendParameters(self, *args):
        """
        getStretchBendParameters(AmoebaStretchBendForce self, int index)

        Get the force field parameters for a stretch-bend term.
           Parameters:
            - index the index of the stretch-bend for which to get parameters
            - particle1 the index of the first particle connected by the stretch-bend
            - particle2 the index of the second particle connected by the stretch-bend
            - particle3 the index of the third particle connected by the stretch-bend
            - lengthAB the equilibrium length of the stretch-bend in bond ab [particle1, particle2], measured in nm
            - lengthCB the equilibrium length of the stretch-bend in bond cb [particle3, particle2], measured in nm
            - angle the equilibrium angle in radians
            - k1 the force constant of the product of bond ab and angle a-b-c
            - k2 the force constant of the product of bond bc and angle a-b-c
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.AmoebaStretchBendForce_getStretchBendParameters(self, *args)

        val[3]=unit.Quantity(val[3], unit.nanometer)
        val[4]=unit.Quantity(val[4], unit.nanometer)
        val[5]=unit.Quantity(val[5], unit.radian)
        val[6]=unit.Quantity(val[6], unit.kilojoule_per_mole/unit.nanometer/unit.degree)
        val[7]=unit.Quantity(val[7], unit.kilojoule_per_mole/unit.nanometer/unit.degree)


        return val


    def setStretchBendParameters(self, *args):
        """
        setStretchBendParameters(AmoebaStretchBendForce self, int index, int particle1, int particle2, int particle3, double lengthAB, double lengthCB, double angle, double k1, double k2)

        Set the force field parameters for a stretch-bend term.
           Parameters:
            - index the index of the stretch-bend for which to set parameters
            - particle1 the index of the first particle connected by the stretch-bend
            - particle2 the index of the second particle connected by the stretch-bend
            - particle3 the index of the third particle connected by the stretch-bend
            - lengthAB the equilibrium length of the stretch-bend in bond ab [particle1, particle2], measured in nm
            - lengthCB the equilibrium length of the stretch-bend in bond cb [particle3, particle2], measured in nm
            - angle the equilibrium angle in radians
            - k1 the force constant of the product of bond ab and angle a-b-c
            - k2 the force constant of the product of bond bc and angle a-b-c (optional, default is the same as k1)
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaStretchBendForce_setStretchBendParameters(self, *args)


    def updateParametersInContext(self, *args):
        """
        updateParametersInContext(AmoebaStretchBendForce self, Context context)

        Update the per-stretch-bend term parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setStretchBendParameters() to modify this object's parameters, then call updateParametersInContext() to copy them over to the Context.

        The only information this method updates is the values of per-stretch-bend term parameters. The set of particles involved in a term cannot be changed, nor can new terms be added.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaStretchBendForce_updateParametersInContext(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(AmoebaStretchBendForce self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.AmoebaStretchBendForce_usesPeriodicBoundaryConditions(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::AmoebaStretchBendForce self) -> AmoebaStretchBendForce
        __init__(OpenMM::AmoebaStretchBendForce self, AmoebaStretchBendForce other) -> AmoebaStretchBendForce

        Create an AmoebaStretchBendForce.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_AmoebaStretchBendForce(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_AmoebaStretchBendForce
    def __del__(self):
        """__del__(OpenMM::AmoebaStretchBendForce self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

AmoebaStretchBendForce_swigregister = _openmm.AmoebaStretchBendForce_swigregister
AmoebaStretchBendForce_swigregister(AmoebaStretchBendForce)

class CustomTorsionForce(Force):
    """
    This class implements interactions between sets of four particles that depend on the torsion angle between them. Unlike PeriodicTorsionForce, the functional form of the interaction is completely customizable, and may involve arbitrary algebraic expressions. In addition to the angle formed by the particles, it may depend on arbitrary global and per-torsion parameters.

    To use this class, create a CustomTorsionForce object, passing an algebraic expression to the constructor that defines the interaction energy between each set of particles. The expression may depend on theta, the torsion angle formed by the particles, as well as on any parameters you choose. Then call addPerTorsionParameter() to define per-torsion parameters, and addGlobalParameter() to define global parameters. The values of per-torsion parameters are specified as part of the system definition, while values of global parameters may be modified during a simulation by calling Context::setParameter(). Finally, call addTorsion() once for each torsion. After an torsion has been added, you can modify its parameters by calling setTorsionParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext().

    As an example, the following code creates a CustomTorsionForce that implements a harmonic potential:

    <tt>CustomTorsionForce* force = new CustomTorsionForce("0.5*k*(theta-theta0)^2");</tt>

    This force depends on two parameters: the spring constant k and equilibrium angle theta0. The following code defines these parameters:

    <tt><pre>
    force->addPerTorsionParameter("k");
    force->addPerTorsionParameter("theta0");
    </pre></tt>

    Expressions may involve the operators + (add), - (subtract), * (multiply), / (divide), and ^ (power), and the following functions: sqrt, exp, log, sin, cos, sec, csc, tan, cot, asin, acos, atan, sinh, cosh, tanh, erf, erfc, min, max, abs, floor, ceil, step, delta, select. All trigonometric functions are defined in radians, and log is the natural logarithm. step(x) = 0 if x is less than 0, 1 otherwise. delta(x) = 1 if x is 0, 0 otherwise. select(x,y,z) = z if x = 0, y otherwise.
    """
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomTorsionForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomTorsionForce, name)
    __repr__ = _swig_repr

    def getNumTorsions(self, *args):
        """
        getNumTorsions(CustomTorsionForce self) -> int

        Get the number of torsions for which force field parameters have been defined.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomTorsionForce_getNumTorsions(self, *args)


    def getNumPerTorsionParameters(self, *args):
        """
        getNumPerTorsionParameters(CustomTorsionForce self) -> int

        Get the number of per-torsion parameters that the interaction depends on.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomTorsionForce_getNumPerTorsionParameters(self, *args)


    def getNumGlobalParameters(self, *args):
        """
        getNumGlobalParameters(CustomTorsionForce self) -> int

        Get the number of global parameters that the interaction depends on.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomTorsionForce_getNumGlobalParameters(self, *args)


    def getEnergyFunction(self, *args):
        """
        getEnergyFunction(CustomTorsionForce self) -> std::string const &

        Get the algebraic expression that gives the interaction energy for each torsion
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomTorsionForce_getEnergyFunction(self, *args)


    def setEnergyFunction(self, *args):
        """
        setEnergyFunction(CustomTorsionForce self, std::string const & energy)

        Set the algebraic expression that gives the interaction energy for each torsion
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomTorsionForce_setEnergyFunction(self, *args)


    def addPerTorsionParameter(self, *args):
        """
        addPerTorsionParameter(CustomTorsionForce self, std::string const & name) -> int

        Add a new per-torsion parameter that the interaction may depend on.
           Parameters:
            - name the name of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomTorsionForce_addPerTorsionParameter(self, *args)


    def getPerTorsionParameterName(self, *args):
        """
        getPerTorsionParameterName(CustomTorsionForce self, int index) -> std::string const &

        Get the name of a per-torsion parameter.
           Parameters:
            - index the index of the parameter for which to get the name
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomTorsionForce_getPerTorsionParameterName(self, *args)


    def setPerTorsionParameterName(self, *args):
        """
        setPerTorsionParameterName(CustomTorsionForce self, int index, std::string const & name)

        Set the name of a per-torsion parameter.
           Parameters:
            - index the index of the parameter for which to set the name
            - name the name of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomTorsionForce_setPerTorsionParameterName(self, *args)


    def addGlobalParameter(self, *args):
        """
        addGlobalParameter(CustomTorsionForce self, std::string const & name, double defaultValue) -> int

        Add a new global parameter that the interaction may depend on.
           Parameters:
            - name the name of the parameter
            - defaultValue the default value of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomTorsionForce_addGlobalParameter(self, *args)


    def getGlobalParameterName(self, *args):
        """
        getGlobalParameterName(CustomTorsionForce self, int index) -> std::string const &

        Get the name of a global parameter.
           Parameters:
            - index the index of the parameter for which to get the name
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomTorsionForce_getGlobalParameterName(self, *args)


    def setGlobalParameterName(self, *args):
        """
        setGlobalParameterName(CustomTorsionForce self, int index, std::string const & name)

        Set the name of a global parameter.
           Parameters:
            - index the index of the parameter for which to set the name
            - name the name of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomTorsionForce_setGlobalParameterName(self, *args)


    def getGlobalParameterDefaultValue(self, *args):
        """
        getGlobalParameterDefaultValue(CustomTorsionForce self, int index) -> double

        Get the default value of a global parameter.
           Parameters:
            - index the index of the parameter for which to get the default value
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomTorsionForce_getGlobalParameterDefaultValue(self, *args)


    def setGlobalParameterDefaultValue(self, *args):
        """
        setGlobalParameterDefaultValue(CustomTorsionForce self, int index, double defaultValue)

        Set the default value of a global parameter.
           Parameters:
            - index the index of the parameter for which to set the default value
            - name the default value of the parameter
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomTorsionForce_setGlobalParameterDefaultValue(self, *args)


    def addTorsion(self, *args):
        """
        addTorsion(CustomTorsionForce self, int particle1, int particle2, int particle3, int particle4, vectord parameters) -> int

        Add a torsion term to the force field.
           Parameters:
            - particle1 the index of the first particle connected by the torsion
            - particle2 the index of the second particle connected by the torsion
            - particle3 the index of the third particle connected by the torsion
            - particle4 the index of the fourth particle connected by the torsion
            - parameters the list of parameters for the new torsion
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomTorsionForce_addTorsion(self, *args)


    def getTorsionParameters(self, *args):
        """
        getTorsionParameters(CustomTorsionForce self, int index)

        Get the force field parameters for a torsion term.
           Parameters:
            - index the index of the torsion for which to get parameters
            - particle1 the index of the first particle connected by the torsion
            - particle2 the index of the second particle connected by the torsion
            - particle3 the index of the third particle connected by the torsion
            - particle4 the index of the fourth particle connected by the torsion
            - parameters the list of parameters for the torsion
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomTorsionForce_getTorsionParameters(self, *args)


    def setTorsionParameters(self, *args):
        """
        setTorsionParameters(CustomTorsionForce self, int index, int particle1, int particle2, int particle3, int particle4, vectord parameters)

        Set the force field parameters for a torsion term.
           Parameters:
            - index the index of the torsion for which to set parameters
            - particle1 the index of the first particle connected by the torsion
            - particle2 the index of the second particle connected by the torsion
            - particle3 the index of the third particle connected by the torsion
            - particle4 the index of the fourth particle connected by the torsion
            - parameters the list of parameters for the torsion
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomTorsionForce_setTorsionParameters(self, *args)


    def updateParametersInContext(self, *args):
        """
        updateParametersInContext(CustomTorsionForce self, Context context)

        Update the per-torsion parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setTorsionParameters() to modify this object's parameters, then call updateParametersInContext() to copy them over to the Context.

        This method has several limitations. The only information it updates is the values of per-torsion parameters. All other aspects of the Force (such as the energy function) are unaffected and can only be changed by reinitializing the Context. The set of particles involved in a torsion cannot be changed, nor can new torsions be added.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomTorsionForce_updateParametersInContext(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(CustomTorsionForce self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.CustomTorsionForce_usesPeriodicBoundaryConditions(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::CustomTorsionForce self, std::string const & energy) -> CustomTorsionForce
        __init__(OpenMM::CustomTorsionForce self, CustomTorsionForce other) -> CustomTorsionForce

        Create a CustomTorsionForce.
           Parameters:
            - energy an algebraic expression giving the interaction energy between three particles as a function of theta, the torsion angle between them
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_CustomTorsionForce(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_CustomTorsionForce
    def __del__(self):
        """__del__(OpenMM::CustomTorsionForce self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

CustomTorsionForce_swigregister = _openmm.CustomTorsionForce_swigregister
CustomTorsionForce_swigregister(CustomTorsionForce)

class PeriodicTorsionForce(Force):
    """This class implements an interaction between groups of four particles that varies periodically with the torsion angle between them. To use it, create a PeriodicTorsionForce object then call addTorsion() once for each torsion. After a torsion has been added, you can modify its force field parameters by calling setTorsionParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext()."""
    __swig_setmethods__ = {}
    for _s in [Force]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PeriodicTorsionForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Force]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PeriodicTorsionForce, name)
    __repr__ = _swig_repr

    def getNumTorsions(self, *args):
        """
        getNumTorsions(PeriodicTorsionForce self) -> int

        Get the number of periodic torsion terms in the potential function
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.PeriodicTorsionForce_getNumTorsions(self, *args)


    def addTorsion(self, *args):
        """
        addTorsion(PeriodicTorsionForce self, int particle1, int particle2, int particle3, int particle4, int periodicity, double phase, double k) -> int

        Add a periodic torsion term to the force field.
           Parameters:
            - particle1 the index of the first particle forming the torsion
            - particle2 the index of the second particle forming the torsion
            - particle3 the index of the third particle forming the torsion
            - particle4 the index of the fourth particle forming the torsion
            - periodicity the periodicity of the torsion
            - phase the phase offset of the torsion, measured in radians
            - k the force constant for the torsion
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.PeriodicTorsionForce_addTorsion(self, *args)


    def getTorsionParameters(self, *args):
        """
        getTorsionParameters(PeriodicTorsionForce self, int index)

        Get the force field parameters for a periodic torsion term.
           Parameters:
            - index the index of the torsion for which to get parameters
            - particle1 the index of the first particle forming the torsion
            - particle2 the index of the second particle forming the torsion
            - particle3 the index of the third particle forming the torsion
            - particle4 the index of the fourth particle forming the torsion
            - periodicity the periodicity of the torsion
            - phase the phase offset of the torsion, measured in radians
            - k the force constant for the torsion
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        val = _openmm.PeriodicTorsionForce_getTorsionParameters(self, *args)

        val[5]=unit.Quantity(val[5], unit.radian)
        val[6]=unit.Quantity(val[6], unit.kilojoule_per_mole)


        return val


    def setTorsionParameters(self, *args):
        """
        setTorsionParameters(PeriodicTorsionForce self, int index, int particle1, int particle2, int particle3, int particle4, int periodicity, double phase, double k)

        Set the force field parameters for a periodic torsion term.
           Parameters:
            - index the index of the torsion for which to set parameters
            - particle1 the index of the first particle forming the torsion
            - particle2 the index of the second particle forming the torsion
            - particle3 the index of the third particle forming the torsion
            - particle4 the index of the fourth particle forming the torsion
            - periodicity the periodicity of the torsion
            - phase the phase offset of the torsion, measured in radians
            - k the force constant for the torsion
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.PeriodicTorsionForce_setTorsionParameters(self, *args)


    def updateParametersInContext(self, *args):
        """
        updateParametersInContext(PeriodicTorsionForce self, Context context)

        Update the per-torsion parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setTorsionParameters() to modify this object's parameters, then call updateParametersInContext() to copy them over to the Context.

        The only information this method updates is the values of per-torsion parameters. The set of particles involved in a torsion cannot be changed, nor can new torsions be added.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.PeriodicTorsionForce_updateParametersInContext(self, *args)


    def usesPeriodicBoundaryConditions(self, *args):
        """
        usesPeriodicBoundaryConditions(PeriodicTorsionForce self) -> bool

        Returns whether or not this force makes use of periodic boundary conditions.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        return _openmm.PeriodicTorsionForce_usesPeriodicBoundaryConditions(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenMM::PeriodicTorsionForce self) -> PeriodicTorsionForce
        __init__(OpenMM::PeriodicTorsionForce self, PeriodicTorsionForce other) -> PeriodicTorsionForce

        Create a PeriodicTorsionForce.
        """

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        this = _openmm.new_PeriodicTorsionForce(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmm.delete_PeriodicTorsionForce
    def __del__(self):
        """__del__(OpenMM::PeriodicTorsionForce self)"""

        try: args=stripUnits(args)
        except UnboundLocalError: pass


        pass

PeriodicTorsionForce_swigregister = _openmm.PeriodicTorsionForce_swigregister
PeriodicTorsionForce_swigregister(PeriodicTorsionForce)


  # when we import * from the python module, we only want to import the
  # actual classes, and not the swigregistration methods, which have already
  # been called, and are now unneeded by the user code, and only pollute the
  # namespace
__all__ = [k for k in locals().keys() if not (k.endswith('_swigregister') or k.startswith('_'))]

# This file is compatible with both classic and new-style classes.


